Sections:
00: ".bss" (0-0)
01: ".text" (0-2240)


Source: "Femtikia.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .include "../inc/config.qpa"

Source: "..\inc\config.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # These constants are used in the code.
                            	    38: # They are not used by the variable declarations. The varible declarations
                            	    39: # will have to updated to match these constants.
                            	    40: 
                            	    41: .set MAX_TID,4095
                            	    42: .set NR_TCB,4095
                            	    43: # number of tasks allowed
                            	    44: .set NTASK,4095
                            	    45: # TCB size in bits of address space    		
                            	    46: .set LOG_TCBSZ,10
                            	    47: # MMU page size			
                            	    48: .set LOG_PGSZ,14
                            	    49: # ACB size in bits of address space			
                            	    50: .set LOG_ACBSZ,14
                            	    51: # pages of memory dedicated to OS			
                            	    52: .set OSPAGES,512
                            	    53: # size of a page of memory			
                            	    54: .set PAGESZ,16384
                            	    55: # number of pages of memory  		
                            	    56: .set MEMSZ,65536
                            	    57: # number of block pointer entries   		
                            	    58: .set MBX_BLOCKPTR_BUFSZ,8 	
                            	    59: # number of messages available
                            	    60: .set NR_MSG,32768
                            	    61: # number of mailboxes			
                            	    62: .set NR_MBX,16384			
                            	    63: 
                            	    64: 
                            	    65: 

Source: "Femtikia.qpa"
                            	    38: .include "../inc/const.qpa"

Source: "..\inc\const.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # task states
                            	    38: .set TS_NONE,0
                            	    39: .set TS_READY,1
                            	    40: .set TS_DEAD,2
                            	    41: .set TS_MSGRDY,4
                            	    42: .set TS_WAITMSG,8
                            	    43: .set TS_TIMEOUT,16
                            	    44: .set TS_PREEMPT,32
                            	    45: .set TS_RUNNING,128
                            	    46: 
                            	    47: # Comamnds to the timer ISR
                            	    48: .set TSC_NONE,0
                            	    49: .set TSC_ALLOCTCB,1
                            	    50: .set TSC_FREETCB,2
                            	    51: .set TSC_SLEEP,3
                            	    52: 
                            	    53: # error codes
                            	    54: .set E_Ok,00
                            	    55: .set E_Arg,01
                            	    56: .set E_Func,02
                            	    57: .set E_BadMbx,4
                            	    58: .set E_QueFull,5
                            	    59: .set E_NoThread,6
                            	    60: .set E_NotAlloc,7
                            	    61: .set E_NoMsg,8
                            	    62: .set E_Timeout,10
                            	    63: .set E_BadAlarm,11
                            	    64: .set E_NotOwner,12
                            	    65: .set E_QueStrategy,13
                            	    66: .set E_Busy,14
                            	    67: .set E_DCBInUse,19
                            	    68: # Device driver errors
                            	    69: .set E_BadDevNum,20
                            	    70: .set E_NoDev,21
                            	    71: .set E_BadDevOp,22
                            	    72: .set E_ReadError,23
                            	    73: .set E_WriteError,24
                            	    74: .set E_BadBlockNum,25
                            	    75: .set E_TooManyBlocks,26
                            	    76: 
                            	    77: # resource errors
                            	    78: .set E_NoMoreMbx,40
                            	    79: .set E_NoMoreMsgBlks,41
                            	    80: .set E_NoMoreAlarmBlks,44
                            	    81: .set E_NoMoreTCBs,45
                            	    82: .set E_NoMem,46
                            	    83: 
                            	    84: # codes for CSR registers in the CPU
                            	    85: .set M_SR,0x3004
                            	    86: .set M_SEMA,0x300C
                            	    87: 

Source: "Femtikia.qpa"
                            	    39: .include "../inc/types.qpa"

Source: "..\inc\types.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Stratford
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .set OBJMagic,0
                            	    38: .set OBJSize,4
                            	    39: .set OBJTypenum,8
                            	    40: .set OBJID,12
                            	    41: # WHITE, GREY, BLACK
                            	    42: .set OBJStat,16 
                            	    43: # scavange count   		
                            	    44: .set OBJScavcnt,20    
                            	    45: .set OBJOwningMap,24
                            	    46: .set OBJCollectionIndex,28
                            	    47: # used in map
                            	    48: .set OBJUsedInMap,32
                            	    49: # forwarding address  
                            	    50: .set OBJFWAddr,36    	
                            	    51: .set OBJFinalizer,40
                            	    52: .set OBJ_SIZE,44
                            	    53: 
                            	    54: # Task Control Block
                            	    55: # integer register set storage area
                            	    56: .set TCBIntRegs,000    
                            	    57: # Condition Registers
                            	    58: .set TCBxCR0,4
                            	    59: .set TCBxCR1,5
                            	    60: .set TCBxCR2,6
                            	    61: .set TCBxCR3,7
                            	    62: .set TCBxCR4,8
                            	    63: .set TCBxCR5,9
                            	    64: .set TCBxCR6,10
                            	    65: .set TCBxCR7,11
                            	    66: # Branch Registers
                            	    67: .set TCBxBR1,16
                            	    68: .set TCBxBR2,24
                            	    69: .set TCBxBR3,32
                            	    70: .set TCBxBR4,40
                            	    71: .set TCBxBR5,48
                            	    72: .set TCBxBR6,56
                            	    73: # Fixed point registers
                            	    74: .set TCBxA0,64
                            	    75: .set TCBxA1,72
                            	    76: .set TCBxA2,80
                            	    77: .set TCBxA3,88
                            	    78: .set TCBxA4,96
                            	    79: .set TCBxA5,104
                            	    80: .set TCBxA6,112
                            	    81: .set TCBxA7,120
                            	    82: .set TCBxT0,128
                            	    83: .set TCBxT1,136
                            	    84: .set TCBxT2,144
                            	    85: .set TCBxT3,152
                            	    86: .set TCBxT4,160
                            	    87: .set TCBxT5,168
                            	    88: .set TCBxT6,176
                            	    89: .set TCBxT7,184
                            	    90: .set TCBxT8,192
                            	    91: .set TCBxT9,200
                            	    92: .set TCBxS0,208
                            	    93: .set TCBxS1,216
                            	    94: .set TCBxS2,224
                            	    95: .set TCBxS3,232
                            	    96: .set TCBxS4,240
                            	    97: .set TCBxS5,248
                            	    98: .set TCBxS6,256
                            	    99: .set TCBxS7,264
                            	   100: .set TCBxS8,272
                            	   101: .set TCBxS9,280
                            	   102: .set TCBxGP,288
                            	   103: .set TCBxFP,296
                            	   104: # Stack pointers
                            	   105: .set TCBxUSP,304
                            	   106: .set TCBxSSP,312
                            	   107: .set TCBxHSP,320
                            	   108: # Loop Counter
                            	   109: .set TCBxLC,328
                            	   110: # Floating-point registers
                            	   111: .set TCBxF0,336
                            	   112: .set TCBxF1,344
                            	   113: .set TCBxF2,352
                            	   114: .set TCBxF3,360
                            	   115: .set TCBxF4,368
                            	   116: .set TCBxF5,376
                            	   117: .set TCBxF6,384
                            	   118: .set TCBxF7,392
                            	   119: .set TCBxF8,400
                            	   120: .set TCBxF9,408
                            	   121: .set TCBxF10,416
                            	   122: .set TCBxF11,424
                            	   123: .set TCBxF12,432
                            	   124: .set TCBxF13,440
                            	   125: .set TCBxF14,448
                            	   126: .set TCBxF15,456
                            	   127: .set TCBxF16,464
                            	   128: .set TCBxF17,472
                            	   129: .set TCBxF18,480
                            	   130: .set TCBxF19,488
                            	   131: .set TCBxF20,496
                            	   132: .set TCBxF21,504
                            	   133: .set TCBxF22,512
                            	   134: .set TCBxF23,520
                            	   135: .set TCBxF24,528
                            	   136: .set TCBxF25,536
                            	   137: .set TCBxF26,544
                            	   138: .set TCBxF27,552
                            	   139: .set TCBxF28,560
                            	   140: .set TCBxF29,568
                            	   141: .set TCBxF30,576
                            	   142: .set TCBxF31,584
                            	   143: .set TCBxPC,592
                            	   144: .set TCBxXH,600
                            	   145: # Status registers
                            	   146: .set TCBxSR,664
                            	   147: .set TCBxFPSR,672
                            	   148: # OS
                            	   149: .set TCBStatus,700
                            	   150: .set TCBPriority,701
                            	   151: .set TCBWaitMbx,704
                            	   152: .set TCBHasFocus,708
                            	   153: .set TCBStackBot,712
                            	   154: .set TCBMsgD1,716
                            	   155: .set TCBMsgD2,724
                            	   156: .set TCBMsgD3,732
                            	   157: .set TCBStartTick,740
                            	   158: .set TCBEndTick,748
                            	   159: .set TCBTicks,756
                            	   160: .set TCBException,764
                            	   161: .set TCBNext,772
                            	   162: .set TCBPrev,780
                            	   163: .set TCBAffinity,788
                            	   164: .set TCBTimeout,796
                            	   165: .set TCBtid,804
                            	   166: .set TCBmid,808
                            	   167: .set TCBappid,812
                            	   168: .set TCBOpMode,816
                            	   169: .set TCBMbxNext,824
                            	   170: .set TCBMbxPrev,832
                            	   171: .set TCBTaskNum,840
                            	   172: .set TCBAcbNext,848
                            	   173: .set TCBAcbPrev,852
                            	   174: .set TCBTsCmd,856
                            	   175: .set TCBTsResp,864
                            	   176: .set TCBTsCmdParm,872
                            	   177: # room for 10 mailbox handles
                            	   178: .set TCBhMailboxes,880	
                            	   179: # memoey brk point
                            	   180: .set TCBbrk,920					
                            	   181: .set TCBMsg,924
                            	   182: # room for 32 16-bit characters
                            	   183: .set TCBName,952				
                            	   184: .set TCB_SIZE,1024
                            	   185: 
                            	   186: # Application Control Block
                            	   187: .set ACBObject,0
                            	   188: .set ACBNumTask,66
                            	   189: .set ACBStackSize,72
                            	   190: .set ACBpData,80
                            	   191: .set ACBDataSize,88
                            	   192: .set ACBpUIData,96
                            	   193: .set ACBUIDataSize,104
                            	   194: .set ACBGCRoots,112
                            	   195: .set ACBGCRootCnt,120
                            	   196: .set ACBGCNdx,128
                            	   197: .set ACBGCMarkingQue,136
                            	   198: .set ACBGCMarkingQueFull,144
                            	   199: .set ACBGCMarkingQueEmpty,145
                            	   200: .set ACBGCOverflow,146
                            	   201: .set ACBpCode,152
                            	   202: .set ACBObjectList,160
                            	   203: .set ACBGarbageList,168
                            	   204: # 640+ bytes for heap object info
                            	   205: .set ACBHeap,176   				
                            	   206: .set ACBiofNext,824
                            	   207: .set ACBiofPrev,832
                            	   208: # 2 byte index of string in string area
                            	   209: .set ACBUserName,840 
                            	   210: # 2 byte index of string in string area  		
                            	   211: .set ACBPath,842
                            	   212: # 2 byte index of string in string area   				
                            	   213: .set ACBExitRunFile,844
                            	   214: # 2 byte index of string in string area 	
                            	   215: .set ACBCommandLine,846 	
                            	   216: .set ACBpVidMem,848
                            	   217: .set ACBpVirtVidMem,856
                            	   218: .set ACBVideoRows,864
                            	   219: .set ACBVideoCols,865
                            	   220: .set ACBCursorRow,866
                            	   221: .set ACBCursorCol,867
                            	   222: .set ACBNormAttr,872
                            	   223: .set ACBKeyState1,880
                            	   224: .set ACBKeyState2,882
                            	   225: .set ACBKeybdWaitFlag,884
                            	   226: .set ACBKeybdHead,886
                            	   227: .set ACBKeybdTail,887
                            	   228: .set ACBKeybdBuffer,888
                            	   229: .set ACBnumber,944
                            	   230: .set ACBNext,952
                            	   231: .set ACBTaskList,960
                            	   232: .set ACBHasFocus,968
                            	   233: .set ACBmid,970
                            	   234: .set ACBStatus,972
                            	   235: .set ACBpFrameBuffer,984
                            	   236: # 256 * 8 bytes reserved for template pointers
                            	   237: .set ACBTemplates,992   	
                            	   238: .set ACBPad,3040
                            	   239: # start of 1kB string area
                            	   240: .set ACBStrings,3072
                            	   241: # 8kB Text screen  		
                            	   242: .set ACBVTextScreen,8192	
                            	   243: .set ACBEnd,16384
                            	   244: .set ACB_SIZE,16384
                            	   245: 
                            	   246: # Application startup record
                            	   247: .set ASRPageSize,0
                            	   248: .set ASRPriority,1
                            	   249: .set ASRRegset,2
                            	   250: .set ASRmid,3
                            	   251: .set ASRAffinity,4
                            	   252: .set ASRCodeSize,8
                            	   253: .set ASRDataSize,16
                            	   254: .set ASRUIDataSize,24
                            	   255: .set ASRHeapSize,32
                            	   256: .set ASRStackSize,40
                            	   257: .set ASRpCode,48
                            	   258: .set ASRpData,56
                            	   259: .set ASRpUIData,64
                            	   260: .set ASR_SIZE,72
                            	   261: 
                            	   262: # tid of owning task
                            	   263: .set MBX_OWNER,0	
                            	   264: #MBX_WTIDS			equ		4		; tasks waiting at mailbox
                            	   265: .set MBXLink,4
                            	   266: # link field for free list shared with task queue head
                            	   267: .set MBXTQHead,8	
                            	   268: .set MBXTQTail,12
                            	   269: .set MBXTQCount,16
                            	   270: .set MBXMQHead,20
                            	   271: .set MBXMQTail,24
                            	   272: .set MBXMQCount,28
                            	   273: .set MBXMQSize,32
                            	   274: .set MBXMQMissed,36
                            	   275: .set MBXMQStrategy,40
                            	   276: .set MBX_SIZE,44
                            	   277: 
                            	   278: .set MSGLink,0
                            	   279: .set MSGRetAdr,4
                            	   280: .set MSGDestAdr,8
                            	   281: .set MSGType,12
                            	   282: .set MSGD1,16
                            	   283: .set MSGD2,20
                            	   284: .set MSGD3,24
                            	   285: .set MSG_SIZE,28
                            	   286: 
                            	   287: .set PMT_SIZE,64
                            	   288: 
                            	   289: 

Source: "Femtikia.qpa"
                            	    40: #include "../inc/io_equates.qpa"
                            	    41: .include "./Femtiki_vars.qpa"

Source: ".\Femtiki_vars.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # These OS structures and variables are statically allocatedfor now until the
                            	    38: # the OS is in a better working state.
                            	    39: # 65536 bits (8kB)
                            	    40: 	.bss
                            	    41: 	.align 4
                            	    42: .set _PAM,0x00002000										
                            	    43: .set _PAMend,0x00004000
                            	    44: # 65536 16B PMTEs
                            	    45: .set _PageManagementTable,0x00004000		
                            	    46: .set _PageManagementTableEnd,0x00104000
                            	    47: # 32 16kB ACBs
                            	    48: .set acbs,0x00104000
                            	    49: .set acbs_end,0x00184000			
                            	    50: # 4096 1kB TCBs
                            	    51: .set tcbs,0x00184000
                            	    52: .set tcbs_end,0x00584000			
                            	    53: # 32768 32B MSGs
                            	    54: .set messages,0x00584000
                            	    55: .set messages_end,0x00684000	
                            	    56: # 16384 34B MBXs
                            	    57: .set mailboxes,0x00684000
                            	    58: .set mailboxes_end,0x006E4000	
                            	    59: 
                            	    60: .set sys_stacks,0xFFFB0000
                            	    61: .set FemtikiVars,0xFFF80020
                            	    62: .set PAMLastAllocate2,0xFFF80020
                            	    63: .set RunningAID,0xFFF80024
                            	    64: .set RunningID,0xFFF80028
                            	    65: .set ACBPtrs,0xFFF8002C
                            	    66: .set MidStackBottoms,0xFFF800AC
                            	    67: .set FemtikiInited,0xFFF800B0
                            	    68: missed_ticks:
                            	    69: 	.type	missed_ticks,@object
                            	    70: 	.size	missed_ticks,4
                            	    71: OSSEMA:
                            	    72: 	.type	OSSEMA,@object
                            	    73: 	.size	OSSEMA,4
                            	    74: MSGSEMA:
                            	    75: 	.type	MSGSEMA,@object
                            	    76: 	.size	MSGSEMA,4
                            	    77: TCBSEMA:
                            	    78: 	.type	TCBSEMA,@object
                            	    79: 	.size	TCBSEMA,4
                            	    80: MMUSEMA:
                            	    81: 	.type	MMUSEMA,@object
                            	    82: 	.size	MMUSEMA,4
                            	    83: ACBSEMA:
                            	    84: 	.type	ACBSEMA,@object
                            	    85: 	.size	ACBSEMA,4
                            	    86: PMTSEMA:
                            	    87: 	.type	PMTSEMA,@object
                            	    88: 	.size	PMTSEMA,4
                            	    89: #.set missed_ticks,0xFFF800B4
                            	    90: .set IOFocusList,0xFFF800B8
                            	    91: .set IOFocusID,0xFFF800B9
                            	    92: .set iof_switch,0xFFF800BA
                            	    93: .set nMessage,0xFFF800BC
                            	    94: .set nMailbox,0xFFF800C0
                            	    95: .set FreeACB,0xFFF800C4
                            	    96: .set FreeTCB,0xFFF800C8
                            	    97: .set FreeMSG,0xFFF800CC
                            	    98: .set FreeMBX,0xFFF800D0
                            	    99: .set TimeoutList,0xFFF800D4
                            	   100: .set hKeybdMbx,0xFFF800D8
                            	   101: .set hFocusSwitchMbx,0xFFF800DC
                            	   102: .set BIOS_RespMbx,0xFFF800E0
                            	   103: .set hasUltraHighPriorityTasks,0xFFF800E4
                            	   104: .set im_save,0xFFF800E8
                            	   105: .set sp_tmp,0xFFF800EC
                            	   106: .set readyQ,0xFFF800F0
                            	   107: .set readyQTail,0xFFF800F4
                            	   108: .set NPAGES,0xFFF800F8
                            	   109: .set syspages,0xFFF800FC
                            	   110: .set mmu_FreeMaps,0xFFF80100
                            	   111: .set mmu_entries,0xFFF80104
                            	   112: .set freelist,0xFFF80108
                            	   113: .set hSearchMap,0xFFF8010C
                            	   114: .set OSActive,0xFFF80110
                            	   115: .set FemtikiVars_end,0xFFF80114
                            	   116: 
                            	   117: #gc_stack		rmb		512
                            	   118: #gc_pc				fcdw		0
                            	   119: #gc_omapno		fcw			0
                            	   120: #gc_mapno		fcw			0
                            	   121: #gc_dl				fcw			0
                            	   122: 

Source: "Femtikia.qpa"
                            	    42: 
                            	    43: .set IRQFlag,0xFFFC0012
                            	    44: .set InTimerISRFlag,1
                            	    45: 
                            	    46: .set MMUxVIRTADR,0xFFF40040
                            	    47: .set MMUxPHYSADR,0xFFF40050
                            	    48: .set MMUxPADRV,0xFFF40060
                            	    49: 
                            	    50: .set CB_XOR,0x00312345
                            	    51: .set FPSR,0x0014
                            	    52: .set SR,0x3004
                            	    53: .set XS,0x3010
                            	    54: .set SCRATCH,0x3041
                            	    55: .set ESR0,0x3080
                            	    56: .set EPC0,0x3108
                            	    57: .set FPStateBegin,3
                            	    58: .set FPStateEnd,4
                            	    59: 
                            	    60: 	.text
                            	    61: 
                            	    62: #------------------------------------------------------------------------------
                            	    63: # Perform an address range check on an argument. Note we use only 1 branch
                            	    64: # here by combining CR register values.
                            	    65: #------------------------------------------------------------------------------
                            	    66: 
                            	    67: .macro macAdrCheck regno
                            	    68: 	cmpai %cr0,\regno,0						# NULL pointer?
                            	    69: 	cmpai %cr1,\regno,0x00800000		# too low
                            	    70: 	cmpai %cr2,\regno,0xC0000000		# too high
                            	    71: 	cror %cr0?eq,%cr0?eq,%cr1?lt
                            	    72: 	crorc %cr0?eq,%cr0?eq,%cr2?le
                            	    73: 	peq %cr0,.0001\@
                            	    74: 	loadi %a0,E_Arg
                            	    75: 	b OSExit
                            	    76: .0001\@:
                            	    77: .endm
                            	    78: 
                            	    79: #------------------------------------------------------------------------------
                            	    80: # Perform a store operation using the previous mode found on the stack.
                            	    81: #------------------------------------------------------------------------------
                            	    82: 
                            	    83: .macro macStorePM
                            	    84:   push %a2
                            	    85: 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
                            	    86: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
                            	    87:   sync
                            	    88: 	store %a0,[%a1]						# do the store to the proper address space
                            	    89: 	csrrw %r0,M_SR,%a2				# restore SR settings
                            	    90:   sync
                            	    91:   pop %a2
                            	    92: .endm
                            	    93: 
                            	    94: .macro macStorePtrPM
                            	    95:   push %a2
                            	    96: 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
                            	    97: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
                            	    98:   sync
                            	    99: 	stptr %a0,[%a1]						# do the store to the proper address space
                            	   100: 	csrrw %r0,M_SR,%a2				# restore SR settings
                            	   101:   sync
                            	   102:   pop %a2
                            	   103: .endm
                            	   104: 
                            	   105: #------------------------------------------------------------------------------
                            	   106: # Convert a TCB handle into a pointer to the corresponding TCB.
                            	   107: # The handle is just the address for the TCB shifted right and XOR'd to
                            	   108: # randomize it. Got to be simple and turned into a .macro for performance
                            	   109: # reasons. So, it is just a matter of reversing the steps.
                            	   110: #------------------------------------------------------------------------------
                            	   111: 
                            	   112: .macro macTCBHandleToPointer
                            	   113: 	xori %a0,%a0,CB_XOR
                            	   114: 	slli %a0,%a0,LOG_TCBSZ
                            	   115: .endm
                            	   116: 
                            	   117: TCBHandleToPointer:
01:00000000 4408FEFF        	   118: 	subi %a0,%a0,1
01:00000004 42081480        	   119: 	slli %a0,%a0,LOG_TCBSZ
01:00000008 440800A0        	   120: 	addi %a0,%a0,tcbs
01:0000000C 1A000024        	   121: 	blr
                            	   122: 
                            	   123: #------------------------------------------------------------------------------
                            	   124: # Convert an ACB handle into a pointer to the corresponding ACB.
                            	   125: # Handles vary from 1 to 32.
                            	   126: #------------------------------------------------------------------------------
                            	   127: 
                            	   128: .macro macACBHandleToPointer
                            	   129: 	xori %a0,%a0,CB_XOR
                            	   130: 	slli %a0,%a0,LOG_ACBSZ
                            	   131: .endm
                            	   132: 
                            	   133: ACBHandleToPointer:
01:00000010 4408FEFF        	   134: 	subi %a0,%a0,1
01:00000014 42081C80        	   135: 	slli %a0,%a0,LOG_ACBSZ
01:00000018 440804A0        	   136: 	addi %a0,%a0,acbs
01:0000001C 1A000024        	   137: 	blr
                            	   138: 
                            	   139: #------------------------------------------------------------------------------
                            	   140: # Convert a TCB pointer into a handle for the TCB.
                            	   141: #------------------------------------------------------------------------------
                            	   142: 
                            	   143: .macro macTCBPointerToHandle
                            	   144: 	srli %a0,%a0,LOG_TCBSZ
                            	   145: 	xori %a0,%a0,CB_XOR
                            	   146: .endm
                            	   147: 
                            	   148: TCBPointerToHandle:
01:00000020 440808A0        	   149: 	subi %a0,%a0,tcbs
01:00000024 42081482        	   150: 	srli %a0,%a0,LOG_TCBSZ
01:00000028 44080280        	   151: 	addi %a0,%a0,1
01:0000002C 1A000024        	   152: 	blr
                            	   153: 
                            	   154: .macro macACBPointerToHandle
                            	   155: 	srli %a0,%a0,LOG_ACBSZ
                            	   156: 	xori %a0,%a0,CB_XOR
                            	   157: .endm
                            	   158: 
                            	   159: #------------------------------------------------------------------------------
                            	   160: # Set the TCB status in an atomic fasion.
                            	   161: # There is no error checking on the handle for performance reasons.
                            	   162: # This function is called by the OS and assumes it has valid parameters.
                            	   163: #
                            	   164: # Side effects
                            	   165: #		TCB status updated
                            	   166: # Registers Affected
                            	   167: #		a0: converted from handle to pointer
                            	   168: #		%br2: used to stack the return address
                            	   169: # Parameters
                            	   170: #		a0 = handle of TCB to set status of
                            	   171: #		a1 = status to set
                            	   172: # Returns:
                            	   173: #		none
                            	   174: #------------------------------------------------------------------------------
                            	   175: 
                            	   176: .macro macTCBSetStatusBit
                            	   177: 	macTCBHandleToPointer
                            	   178: 	addi %a0,%a0,TCBStatus
                            	   179: 	amoorb %r0,%a1,[%a0]
                            	   180: .endm
                            	   181: 
                            	   182: TCBSetStatusBit:
                            	   183: 	macTCBHandleToPointer
01:00000030 4A080CA000401800	     1M 	xori %a0,%a0,CB_XOR
01:00000038 0040100000C0E7FF
01:00000040 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000044 44087885        	   184: 	addi %a0,%a0,TCBStatus
01:00000048 3B180082        	   185: 	amoorb %r0,%a1,[%a0]
01:0000004C 1A000024        	   186: 	blr
                            	   187: 
                            	   188: #------------------------------------------------------------------------------
                            	   189: # Clear the TCB status in an atomic fasion.
                            	   190: #
                            	   191: # Side effects
                            	   192: #		TCB status updated
                            	   193: # Registers Affected
                            	   194: #		a0: converted from handle to pointer
                            	   195: #		%br2: used to stack the return address
                            	   196: # Parameters
                            	   197: #		a0 = handle of TCB to clear status of
                            	   198: #		a1 = status to clear
                            	   199: #------------------------------------------------------------------------------
                            	   200: 
                            	   201: .macro macTCBClearStatusBit
                            	   202: 	macTCBHandleToPointer
                            	   203: 	xori %a1,%a1,-1
                            	   204: 	addi %a0,%a0,TCBStatus
                            	   205: 	amoandb %r0,%a1,[%a0]
                            	   206: 	xori %a1,%a1,-1
                            	   207: .endm
                            	   208: 
                            	   209: TCBClearStatusBit:
                            	   210: 	macTCBHandleToPointer
01:00000050 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000054 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000058 8A1004A0        	   211: 	xori %a1,%a1,-1
01:0000005C 44087885        	   212: 	addi %a0,%a0,TCBStatus
01:00000060 3B180081        	   213: 	amoandb %r0,%a1,[%a0]
01:00000064 8A1004A0        	   214: 	xori %a1,%a1,-1
01:00000068 1A000024        	   215: 	blr
                            	   216: 
                            	   217: #------------------------------------------------------------------------------
                            	   218: # Lock a semaphore.
                            	   219: # The id of the currently running task is used as the semaphore value. A task
                            	   220: # id is always one or greater. So, a value of zero for the semaphore means
                            	   221: # it is available. This function accepts a timeout argument which allows the
                            	   222: # loop attempting to set the semaphore to be aborted after the timeout.
                            	   223: # Semaphores outside of the kernel space are detected and are handled using
                            	   224: # the address space of the caller.
                            	   225: #
                            	   226: # Parameters:
                            	   227: #		a0 = number of retry attempts
                            	   228: #		a1 = semaphore variable address
                            	   229: #	Returns:
                            	   230: #		a0 = 1 if lock successful, 0 otherwise
                            	   231: #------------------------------------------------------------------------------
                            	   232: 
                            	   233: LockSemaphore:
01:0000006C 031008A0        	   234: 	cmpi %cr0,%a1,0xFFF80000		# if that its a kernel var space address
01:00000070 5801568145233100	   235: 	blt .0003										# got lock user-land semaphore
01:00000078 FFFFFFFF0000F8FF
01:00000080 1E020040        	   236: 	push %a2
01:00000084 E60000A0        	   237: 	load %a2,RunningID
                            	   238: .0002:
01:00000088 4408FEFF        	   239: 	addi. %a0,%a0,-1
01:0000008C 18004081        	   240: 	beq	%cr0,.0001
01:00000090 3B18C186        	   241: 	amoswap. %r0,%a2,[%a1]
01:00000094 D93E80E0        	   242: 	bne	%cr0,.0002
01:00000098 1F020040        	   243: 	pop %a2
01:0000009C 44000384        	   244: 	loadi. %a0,1
01:000000A0 1A000024        	   245: 	blr
                            	   246: .0001:
01:000000A4 1F020040        	   247: 	pop %a2
01:000000A8 44000184        	   248: 	loadi. %a0,0		# set %cr0
01:000000AC 1A000024        	   249: 	blr
                            	   250: .0003:
01:000000B0 1E020040        	   251: 	push %a2-%a3
01:000000B4 E60000A0        	   252: 	load %a2,RunningID
                            	   253: .0004:
01:000000B8 4408FEFF2800F8FF	   254: 	addi. %a0,%a0,-1
01:000000C0 98004081        	   255: 	beq	%cr0,.0005
01:000000C4 070108E0        	   256: 	csrrci %a3,M_SR,0x1C0000	# clear MPRV
01:000000C8 07000CE0        	   257: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:000000CC 33000058        	   258:   sync
01:000000D0 3C100604        	   259: 	cmpswap. %r0,%r0,%a2,[%a1]	# do the store to the proper address space
01:000000D4 072008E0        	   260: 	csrrw %r0,M_SR,%a3					# restore SR settings
01:000000D8 33000058        	   261:   sync
01:000000DC 193E80E0        	   262: 	bne	%cr0,.0004
01:000000E0 1F020040        	   263: 	pop %a2-%a3
01:000000E4 44000384        	   264: 	loadi. %a0,1
01:000000E8 1A000024        	   265: 	blr
                            	   266: .0005:
01:000000EC 1F020040        	   267: 	pop %a2-%a3
01:000000F0 44000184        	   268: 	loadi. %a0,0
01:000000F4 1A00002400001C00	   269: 	blr
01:000000FC 00001800
                            	   270: 
                            	   271: #------------------------------------------------------------------------------
                            	   272: # Lock a semaphore.
                            	   273: # The id of the currently running task is used as the semaphore value. A task
                            	   274: # id is always one or greater. So, a value of zero for the semaphore means
                            	   275: # it is available. This function accepts a timeout argument which allows the
                            	   276: # loop attempting to set the semaphore to be aborted after the timeout.
                            	   277: # Semaphores must be outside of the kernel space and are handled using
                            	   278: # the address space of the caller.
                            	   279: #
                            	   280: # Parameters:
                            	   281: #		a1 = number of retry attempts
                            	   282: #		a2 = semaphore variable address
                            	   283: #		a3 = key value to stuff (eg task id)
                            	   284: #	Returns:
                            	   285: #		a0 = E_Ok if lock successful,
                            	   286: #				 E_Busy if semaphore cannot be locked
                            	   287: #				 E_Arg if a bad address was passed
                            	   288: #------------------------------------------------------------------------------
                            	   289: 
                            	   290: FMTK_LockSemaphore:
                            	   291: 	macAdrCheck %a2
01:00000100 031A0080        	     1M 	cmpai %cr0,%a2,0						# NULL pointer?
01:00000104 431A00A0        	     2M 	cmpai %cr1,%a2,0x00800000		# too low
01:00000108 831A04A0        	     3M 	cmpai %cr2,%a2,0xC0000000		# too high
01:0000010C 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:00000110 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:00000114 F83F80E0        	     6M 	peq %cr0,.00017
01:00000118 44000280        	     7M 	loadi %a0,E_Arg
01:0000011C 1A000080        	     8M 	b OSExit
                            	     9M .00017:
                            	   292: .0004:
01:00000120 8410FEFF        	   293: 	addi. %a1,%a1,-1
01:00000124 F83F40E1        	   294: 	pne	%cr0,.0005
01:00000128 44001C80        	   295: 	loadi %a0,E_Busy
01:0000012C 1A000080        	   296: 	b OSExit
                            	   297: .0005:
01:00000130 470008E000008000	   298: 	csrrci %a0,M_SR,0x1C0000	# clear MPRV
01:00000138 000000C000001C00
01:00000140 070008E0        	   299: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00000144 33000058        	   300:   sync
01:00000148 3C180804        	   301: 	cmpswap. %r0,%r0,%a3,[%a2]	# do the store to the proper address space
01:0000014C 070808E0        	   302: 	csrrw %r0,M_SR,%a0					# restore SR settings
01:00000150 33000058        	   303:   sync
01:00000154 F93E80E0        	   304: 	peq	%cr0,.0001
01:00000158 44000080        	   305: 	loadi %a0,E_Ok
01:0000015C 1A000080        	   306: 	b OSExit
                            	   307: .0001:
01:00000160 1BE6FFFF        	   308: 	b .0004
                            	   309: 
                            	   310: #------------------------------------------------------------------------------
                            	   311: # Unlock a semaphore.
                            	   312: #
                            	   313: # Parameters:
                            	   314: #		a1 = semaphore variable address
                            	   315: #		a2 = key value
                            	   316: #	Returns:
                            	   317: #		a0 = E_Ok if unlock successful,
                            	   318: #				 E_NotOwner if semaphore cannot be unlocked
                            	   319: #------------------------------------------------------------------------------
                            	   320: 
                            	   321: FMTK_UnlockSemaphore:
                            	   322: 	macAdrCheck %a1
01:00000164 03120080        	     1M 	cmpai %cr0,%a1,0						# NULL pointer?
01:00000168 431204A0        	     2M 	cmpai %cr1,%a1,0x00800000		# too low
01:0000016C 831208A0        	     3M 	cmpai %cr2,%a1,0xC0000000		# too high
01:00000170 0B00200200001800	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:00000178 00008000000000C0
01:00000180 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:00000184 F83E80E0        	     6M 	peq %cr0,.00018
01:00000188 44000280        	     7M 	loadi %a0,E_Arg
01:0000018C 1A000080        	     8M 	b OSExit
                            	     9M .00018:
01:00000190 1E040040        	   323: 	push %a3
01:00000194 470008E0        	   324: 	csrrci %a0,M_SR,0x1C0000	# clear MPRV
01:00000198 07000CE0        	   325: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:0000019C 33000058        	   326:   sync
01:000001A0 3C190004        	   327: 	cmpswap. %a3,%a2,%r0,[%a1]	# do the store to the proper address space
01:000001A4 070808E0        	   328: 	csrrw %r0,M_SR,%a0					# restore SR settings
01:000001A8 33000058        	   329:   sync
01:000001AC 03200600        	   330:   cmp %cr0,%a3,%a2
01:000001B0 F93E40E1        	   331:   pne %cr0,.0005
01:000001B4 1F04004000001C00	   332:   pop %a3
01:000001BC 00001800
01:000001C0 44000080        	   333: 	loadi %a0,E_Ok
01:000001C4 1A000080        	   334: 	b OSExit
                            	   335: .0005:
01:000001C8 1F040040        	   336:   pop %a3
01:000001CC 44001880        	   337: 	loadi %a0,E_NotOwner
01:000001D0 1A000080        	   338: 	b OSExit
                            	   339: 
                            	   340: #------------------------------------------------------------------------------
                            	   341: # Lock the system semaphore.
                            	   342: #
                            	   343: # Parameters:
                            	   344: #		a0 = number of retry attempts
                            	   345: #	Returns:
                            	   346: #		a0 = 1 if lock successful, 0 otherwise
                            	   347: #------------------------------------------------------------------------------
                            	   348: 
                            	   349: LockSysSemaphore:
01:000001D4 1E000448        	   350: 	push %br1						# push br1
01:000001D8 1E010040        	   351: 	push %a1
01:000001DC A7000000        	   352: 	loada %a1,OSSEMA
01:000001E0 5AA0FFFF        	   353: 	bl LockSemaphore		# this will setup a0 and %cr0
01:000001E4 1F010040        	   354: 	pop %a1
01:000001E8 1F000448        	   355: 	pop %br1
01:000001EC 1A000024        	   356: 	blr
                            	   357: 
                            	   358: #------------------------------------------------------------------------------
                            	   359: # Lock the MMU semaphore.
                            	   360: #
                            	   361: # Parameters:
                            	   362: #		a0 = number of retry attempts
                            	   363: #	Returns:
                            	   364: #		a0 = 1 if lock successful, 0 otherwise
                            	   365: #------------------------------------------------------------------------------
                            	   366: 
                            	   367: LockMMUSemaphore:
01:000001F0 1E000448        	   368: 	push %br1						# push br1
01:000001F4 1E010040        	   369: 	push %a1
01:000001F8 A70000003F000000	   370: 	loada %a1,MMUSEMA
01:00000200 5A98FFFF        	   371: 	bl LockSemaphore
01:00000204 1F010040        	   372: 	pop %a1
01:00000208 1F000448        	   373: 	pop %br1
01:0000020C 1A000024        	   374: 	blr
                            	   375: 
                            	   376: #------------------------------------------------------------------------------
                            	   377: # Lock the ACB semaphore.
                            	   378: #
                            	   379: # Parameters:
                            	   380: #		a0 = number of retry attempts
                            	   381: #	Returns:
                            	   382: #		a0 = 1 if lock successful, 0 otherwise
                            	   383: #------------------------------------------------------------------------------
                            	   384: 
                            	   385: LockACBSemaphore:
01:00000210 1E000448        	   386: 	push %br1						# push br1
01:00000214 1E010040        	   387: 	push %a1
01:00000218 A7000000        	   388: 	loada %a1,ACBSEMA
01:0000021C 5B90FFFF        	   389: 	bl LockSemaphore
01:00000220 1F010040        	   390: 	pop %a1
01:00000224 1F000448        	   391: 	pop %br1
01:00000228 1A000024        	   392: 	blr
                            	   393: 
                            	   394: #------------------------------------------------------------------------------
                            	   395: # Lock the PMT semaphore.
                            	   396: #
                            	   397: # Parameters:
                            	   398: #		a0 = number of retry attempts
                            	   399: #	Returns:
                            	   400: #		a0 = 1 if lock successful, 0 otherwise
                            	   401: #------------------------------------------------------------------------------
                            	   402: 
                            	   403: LockPMTSemaphore:
01:0000022C 1E000448        	   404: 	push %br1						# push br1
01:00000230 1E010040        	   405: 	push %a1
01:00000234 A70000003F000000	   406: 	loada %a1,PMTSEMA
01:0000023C 3F000000
01:00000240 5A88FFFF        	   407: 	bl LockSemaphore
01:00000244 1F010040        	   408: 	pop %a1
01:00000248 1F000448        	   409: 	pop %br1
01:0000024C 1A000024        	   410: 	blr
                            	   411: 
                            	   412: #------------------------------------------------------------------------------
                            	   413: # Lock the PMT semaphore.
                            	   414: #
                            	   415: # Parameters:
                            	   416: #		a0 = number of retry attempts
                            	   417: #	Returns:
                            	   418: #		a0 = 1 if lock successful, 0 otherwise
                            	   419: #------------------------------------------------------------------------------
                            	   420: 
                            	   421: LockMSGSemaphore:
01:00000250 1E000448        	   422: 	push %br1						# push br1
01:00000254 1E010040        	   423: 	push %a1
01:00000258 A7000000        	   424: 	loada %a1,MSGSEMA
01:0000025C 5B80FFFF        	   425: 	bl LockSemaphore
01:00000260 1F010040        	   426: 	pop %a1
01:00000264 1F000448        	   427: 	pop %br1
01:00000268 1A000024        	   428: 	blr
                            	   429: 
                            	   430: #------------------------------------------------------------------------------
                            	   431: # macUnlock system semaphore.
                            	   432: #
                            	   433: # Parameters:
                            	   434: #		none
                            	   435: # Returns:
                            	   436: #		none
                            	   437: #------------------------------------------------------------------------------
                            	   438: 
                            	   439: .macro macUnlockSysSemaphore
                            	   440: 	store %r0,OSSEMA
                            	   441: .endm
                            	   442: 
                            	   443: .macro macUnlockMMUSemaphore
                            	   444: 	store %r0,MMUSEMA
                            	   445: .endm
                            	   446: 
                            	   447: .macro macUnlockACBSemaphore
                            	   448: 	store %r0,ACBSEMA
                            	   449: .endm
                            	   450: 
                            	   451: .macro macUnlockPMTSemaphore
                            	   452: 	store %r0,PMTSEMA
                            	   453: .endm
                            	   454: 
                            	   455: .macro macUnlockMSGSemaphore
                            	   456: 	store %r0,MSGSEMA
                            	   457: .endm
                            	   458: 
                            	   459: # 'C' callable functions
                            	   460: 
                            	   461: _UnlockSysSemaphore:
01:0000026C 2E000000        	   462: 	store %r0,OSSEMA
01:00000270 1A000024        	   463: 	blr
                            	   464: 
                            	   465: _UnlockMMUSemaphore:
01:00000274 2E0000003F000000	   466: 	store %r0,MMUSEMA
01:0000027C 3F000000
01:00000280 1A000024        	   467: 	blr
                            	   468: 
                            	   469: _UnlockACBSemaphore:
01:00000284 2E000000        	   470: 	store %r0,ACBSEMA
01:00000288 1A000024        	   471: 	blr
                            	   472: 
                            	   473: _UnlockPMTSemaphore:
01:0000028C 2E000000        	   474: 	store %r0,PMTSEMA
01:00000290 1A000024        	   475: 	blr
                            	   476: 
                            	   477: _UnlockMSGSemaphore:
01:00000294 2E000000        	   478: 	store %r0,MSGSEMA
01:00000298 1A000024        	   479: 	blr
                            	   480: 
                            	   481: #------------------------------------------------------------------------------
                            	   482: # Get the system tick (milliseconds).
                            	   483: #
                            	   484: # Trickery involved in guarenteeing that the tick was read without an
                            	   485: # intervening interrupt updating it.
                            	   486: #
                            	   487: # ToDo: make this a .macro?
                            	   488: #
                            	   489: # Parameters:
                            	   490: #		none
                            	   491: # Returns:
                            	   492: #		D,W = tick value
                            	   493: #------------------------------------------------------------------------------
                            	   494: 
                            	   495: .macro macIGetTick
                            	   496: 	load %a0,milliseconds
                            	   497: .endm
                            	   498: 
                            	   499: #------------------------------------------------------------------------------
                            	   500: # Heavy-weight environment call dispatcher.
                            	   501: #
                            	   502: # Process is to stack registers on the stack, call the function, then
                            	   503: # unstack the registers. Stacking the registers potentially allows some
                            	   504: # functions to be reentrant. It is also faster than context switching to the
                            	   505: # OS. The OS function is running in the context of the caller, except that
                            	   506: # it is running in a higher operating mode which means addresses are 
                            	   507: # untranslated. To get at storage in the current context the mprv flag in 
                            	   508: # the status register is used.
                            	   509: #
                            	   510: # Parameters:
                            	   511: #		a0 = operating system call number
                            	   512: #		a1 to %a6 = arguments for the system call (use depends on called function)
                            	   513: # Returns:
                            	   514: #		a0 = status, E_Ok for success, otherwise an error code
                            	   515: #------------------------------------------------------------------------------
                            	   516: 
                            	   517: EnvCallHeavy:
01:0000029C 5E400048        	   518: 	push %cr0					# push cr0
01:000002A0 030A0080        	   519: 	cmpai %cr0,%a0,NUM_OSFUNC	# check if we have a valid function number
01:000002A4 19058880        	   520: 	bgt %cr0,EnvCallBadFunc
01:000002A8 5F400048        	   521: 	pop %cr0
01:000002AC 070882E0        	   522: 	csrrw %r0,SCRATCH,%a0
01:000002B0 1E3FFE40        	   523: 	push %r2-%r15					# save registers
01:000002B4 DE7FFE40        	   524: 	push %r16-%r31
                            	   525: 	# save status reg, FP status reg
01:000002B8 47002880        	   526: 	csrrd %a0,FPSR
01:000002BC 9E000040        	   527: 	push %a0							# push a0
01:000002C0 470008E0        	   528: 	csrrd %a0,SR
01:000002C4 9E000040        	   529: 	push %a0
01:000002C8 DE010048        	   530: 	push %usp/%ssp/%hsp		# save SPs
01:000002CC DE7F0048        	   531: 	push %cr0-%lc					# save CRs,BRs and LC
01:000002D0 4FE01080        	   532: 	move %a0,%xh					# and XH
01:000002D4 9E000040        	   533: 	push %a0
01:000002D8 470082E0        	   534: 	csrrd %a0,SCRATCH					# get back a0
01:000002DC 42080480        	   535: 	slli %a0,%a0,2						# convert unit index into word index
01:000002E0 66080004        	   536: 	load. %a0,EnvCallHeavyTable[%a0]	# fetch vector
01:000002E4 98034081        	   537: 	beq %cr0,EnvCallHeavyBadFunc2		# nullptr?
01:000002E8 470082E0        	   538: 	csrrd %a0,SCRATCH
                            	   539: 	# call the environment function (eg written in C)
                            	   540: 	# we carefully did not modify any registers, so the arguments in registers
                            	   541: 	# should still be correct.
01:000002EC 53008002        	   542: 	blrl %br1
                            	   543:   # Stuff the error response return value into the right stack position so
                            	   544:   # they it is popped into the a0 register for return
                            	   545: 	# fall through to exit
                            	   546: 
                            	   547: #------------------------------------------------------------------------------
                            	   548: # Heavy-weight environment exit point.
                            	   549: # Pops all the registers off the stack that were saved by the call.
                            	   550: #
                            	   551: # Parameters:
                            	   552: #		none
                            	   553: # Returns:
                            	   554: #		a0 = error code (must have been stuffed into the stack)
                            	   555: #------------------------------------------------------------------------------
                            	   556: 
                            	   557: EnvExitHeavy:
01:000002F0 1F010040        	   558: 	pop %a1
01:000002F4 0F170480        	   559: 	move %xh,%a1
01:000002F8 DF7F0048        	   560: 	pop %cr0-%lc					# get CRs,BRs and LC
01:000002FC DF010048        	   561: 	pop %usp/%ssp/%hsp		# get SPs
                            	   562: 	# restore status reg and FP status reg
01:00000300 1F010040        	   563: 	pop %a1
01:00000304 071008E0        	   564: 	csrrw %r0,SR,%a1
01:00000308 1F010040        	   565: 	pop %a1
01:0000030C 07102880        	   566: 	csrrw %r0,FPSR,%a1
                            	   567: 	# restore GPRs
01:00000310 DF7FFE40        	   568: 	pop %r16-%r31
01:00000314 1F3FFE40        	   569: 	pop %r2-%r15
01:00000318 13000004        	   570: 	rfi
                            	   571: 
                            	   572: #------------------------------------------------------------------------------
                            	   573: # Medium-weight environment call dispatcher.
                            	   574: #
                            	   575: # Process is to stack registers on the stack, call the function, then
                            	   576: # unstack the registers. Stacking the registers potentially allows some
                            	   577: # functions to be reentrant. It is also faster than context switching to the
                            	   578: # OS. The OS function is running in the context of the caller, except that
                            	   579: # it is running in a higher operating mode which means addresses are 
                            	   580: # untranslated. To get at storage in the current context the mprv flag in 
                            	   581: # the status register is used.
                            	   582: #
                            	   583: # Parameters:
                            	   584: #		a0 = operating system call number
                            	   585: #		a1 to %a6 = arguments for the system call (use depends on called function)
                            	   586: # Returns:
                            	   587: #		a0 = status, E_Ok for success, otherwise an error code
                            	   588: #------------------------------------------------------------------------------
                            	   589: 
                            	   590: EnvCallMedium:
01:0000031C 5E400048        	   591: 	push %cr0					# push cr0
01:00000320 030A0080        	   592: 	cmpai %cr0,%a0,EnvCallMediumTableLimit	# check if we have a valid function number
01:00000324 19018880        	   593: 	bgt %cr0,EnvCallBadFunc
01:00000328 5F400048        	   594: 	pop %cr0
01:0000032C 070882E0        	   595: 	csrrw %r0,SCRATCH,%a0
01:00000330 1E3F0040        	   596: 	push %a1-%a7					# save registers
                            	   597: 	# save status reg
01:00000334 470008E0        	   598: 	csrrd %a0,SR
01:00000338 9E000040        	   599: 	push %a0
01:0000033C DE437E48        	   600: 	push %cr0-%cr4/%br1-%br6/%lc	# save CRs,BRs and LC
01:00000340 470082E0        	   601: 	csrrd %a0,SCRATCH					# get back a0
01:00000344 42080480        	   602: 	slli %a0,%a0,2						# convert unit index into word index
01:00000348 66080004        	   603: 	load. %a0,EnvCallMediumTable[%a0]	# fetch vector
01:0000034C 98004081        	   604: 	beq %cr0,EnvCallMediumBadFunc2		# nullptr?
01:00000350 470082E0        	   605: 	csrrd %a0,SCRATCH
                            	   606: 	# call the environment function (eg written in assembler)
                            	   607: 	# we carefully did not modify any registers, so the arguments in registers
                            	   608: 	# should still be correct.
01:00000354 1A000024        	   609: 	blr %br1
                            	   610:   # Stuff the error response return value into the right stack position so
                            	   611:   # they it is popped into the a0 register for return
                            	   612: 	# fall through to exit
                            	   613: 
                            	   614: #------------------------------------------------------------------------------
                            	   615: # Medium-weight environment exit point.
                            	   616: # Pops all the registers off the stack that were saved by the call.
                            	   617: #
                            	   618: # Parameters:
                            	   619: #		none
                            	   620: # Returns:
                            	   621: #		a0 = error code (must have been stuffed into the stack)
                            	   622: #------------------------------------------------------------------------------
                            	   623: 
                            	   624: EnvExitMedium:
01:00000358 DF437E48        	   625: 	pop %cr0-%cr4/%br1-%br6/%lc	# restore CRs,BRs and LC
                            	   626: 	# restore status reg and FP status reg
01:0000035C 9F000040        	   627: 	pop %a0
01:00000360 070808E0        	   628: 	csrrw %r0,SR,%a0
                            	   629: 	# restore GPRs
01:00000364 1F3F0040        	   630: 	pop %a1-%a7						# restore registers
01:00000368 13000004        	   631: 	rfi
                            	   632: 
                            	   633: #------------------------------------------------------------------------------
                            	   634: # Lightweight environment call entry point
                            	   635: # Same as EnvCallHeavy, but only saves nine registers.
                            	   636: #------------------------------------------------------------------------------
                            	   637: 	
                            	   638: EnvCallLight:
01:0000036C 5E400048        	   639: 	push %cr0					# push cr0
01:00000370 030A0080        	   640: 	cmpai %cr0,%a0,NUM_LWENVFUNC	# check if we have a valid function number
01:00000374 18008880        	   641: 	bgt %cr0,EnvCallLightBadFunc
01:00000378 5F400048        	   642: 	pop %cr0
01:0000037C 1E030040        	   643: 	push %a1-%a3							# save a1 to a3 registers
01:00000380 5E400E48        	   644: 	push %cr0-%cr1/%br1-%br3/%lc		# save CRs,BRs and LC
01:00000384 42080480        	   645: 	slli %a0,%a0,2						# convert unit index into word index
01:00000388 66080004        	   646: 	load. %a0,EnvCallLightTable[%a0]	# fetch vector
01:0000038C D83E40E1        	   647: 	beq %cr0,EnvCallLightBadFunc2		# nullptr?
                            	   648: 	# jump to the OS function
                            	   649: 	# we carefully modified only a0, so the arguments in registers
                            	   650: 	# should still be correct.
01:00000390 1A000024        	   651: 	blr %br1
                            	   652: 
                            	   653: #------------------------------------------------------------------------------
                            	   654: # Light-weight environment exit point.
                            	   655: # Pops all the registers off the stack that were saved by the call.
                            	   656: #
                            	   657: # Parameters:
                            	   658: #		none
                            	   659: # Returns:
                            	   660: #		a0 = error code (must have been stuffed into the stack)
                            	   661: #------------------------------------------------------------------------------
                            	   662: 
                            	   663: EnvExitLight:
01:00000394 5F400E48        	   664: 	pop %cr0-%cr1/%br1-%br3/%lc		# save CRs,BRs and LC
01:00000398 1F030040        	   665: 	pop %a1-%a3
01:0000039C 13000004        	   666: 	rfi
                            	   667: 	
                            	   668: #------------------------------------------------------------------------------
                            	   669: # Here a bad function call number was given as the argument.
                            	   670: # This snippet of code returns right away as registers have not been stacked
                            	   671: # yet.
                            	   672: #------------------------------------------------------------------------------
                            	   673: 
                            	   674: EnvCallBadFunc:
01:000003A0 5F400048        	   675: 	pop %cr0
01:000003A4 44000480        	   676:   loadi	%a0,E_Func
01:000003A8 1A000024        	   677:   blr
                            	   678: 
                            	   679: #------------------------------------------------------------------------------
                            	   680: # Here the OS function was not implemented yet (null pointer in dispatch
                            	   681: # table).
                            	   682: # Stuff the error response into the right stack positions so it is popped into
                            	   683: # the a0 register for return.
                            	   684: #------------------------------------------------------------------------------
                            	   685: 
                            	   686: EnvCallHeavyBadFunc2:
01:000003AC 44000480        	   687:   loadi	%a0,E_Func
01:000003B0 1ABAFFFF        	   688: 	b EnvExitHeavy
                            	   689: 
                            	   690: EnvCallMediumBadFunc2:
01:000003B4 44000480        	   691:   loadi	%a0,E_Func
01:000003B8 1AD2FFFF        	   692: 	b EnvExitMedium
                            	   693: 
                            	   694: EnvCallLightBadFunc2:
01:000003BC 44000480        	   695:   loadi	%a0,E_Func
01:000003C0 1BDEFFFF        	   696: 	b EnvExitLight
                            	   697: 
                            	   698: #------------------------------------------------------------------------------
                            	   699: # Some useful OS return points.
                            	   700: #------------------------------------------------------------------------------
                            	   701: 
                            	   702: # Exit OS and return an OKAY status
                            	   703: FMTK_RetOK:
01:000003C4 44000080        	   704: 	loadi %a0,E_Ok
01:000003C8 1A000080        	   705: 	b	OSExit
                            	   706: 
                            	   707: #------------------------------------------------------------------------------
                            	   708: # Got the AppID, now get the mid
                            	   709: #
                            	   710: # Parameters:
                            	   711: #		B = app id
                            	   712: #------------------------------------------------------------------------------
                            	   713: 
                            	   714: GetAppMid:
                            	   715: 	macACBHandleToPointer
01:000003CC 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:000003D0 42081C80        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:000003D4 66080200        	   716: 	load %a0,ACBMid[%a0]
01:000003D8 1A000024        	   717: 	blr
                            	   718: 
                            	   719: #OSCallTbl2:
                            	   720: #  .4byte    SchedulerIRQ
                            	   721: #  .4byte    IStartTask
                            	   722: #  .4byte    ISendMsg
                            	   723: #  .4byte    ISleep
                            	   724: 
                            	   725: EnvCallHeavyTable:
01:000003DC 00000490        	   726: 	.4byte	FMTK_Initialize					# 0
01:000003E0 00000E54        	   727: 	.4byte	FMTK_StartTask					# 1
01:000003E4 00000F2C        	   728: 	.4byte	FMTK_ExitTask
01:000003E8 00000F30        	   729: 	.4byte	FMTK_KillTask
                            	   730: #	.4byte		FMTK_SetTaskPriority
01:000003EC 00000000        	   731: 	.4byte  OSCallBadFunc
01:000003F0 00000000        	   732: 	.4byte	OSCallBadFunc						# 5
01:000003F4 00000000        	   733: 	.4byte	OSCallBadFunc
01:000003F8 00001684        	   734: 	.4byte		FMTK_FreeMbx
01:000003FC 00001914        	   735: 	.4byte		FMTK_PostMsg
01:00000400 00000000        	   736: 	.4byte    OSCallBadFunc
01:00000404 000017E8        	   737: 	.4byte		FMTK_SendMsg
01:00000408 00001A3C        	   738: 	.4byte		FMTK_WaitMsg						# 10
01:0000040C 00001C70        	   739: 	.4byte		FMTK_PeekMsg
                            	   740: #	.4byte		FMTK_StartApp           # 12
                            	   741: #	.4byte		FMTK_ExitApp            # 13
01:00000410 00000000        	   742: 	.4byte    OSCallBadFunc
01:00000414 00000000        	   743: 	.4byte    OSCallBadFunc
01:00000418 00000000        	   744: 	.4byte		OSCallBadFunc
                            	   745: #	.4byte		FMTK_TCBFinalizerExit   # 15
                            	   746: #	.4byte		FMTK_KillApp
                            	   747: #	.4byte		FMTK_RunAsOS            # 17
01:0000041C 00000000        	   748: 	.4byte    OSCallBadFunc
01:00000420 00000000        	   749: 	.4byte    OSCallBadFunc
01:00000424 00000000        	   750: 	.4byte    OSCallBadFunc
01:00000428 00000000        	   751: 	.4byte		OSCallBadFunc      			# 18
01:0000042C 00000000        	   752: 	.4byte		OSCallBadFunc          	# 19
                            	   753: #	.4byte		FMTK_HasIOFocus					# 20
                            	   754: #	.4byte		FMTK_SwitchIOFocus			# 21
                            	   755: #	.4byte		FMTK_ReleaseIOFocus			# 22
                            	   756: #	.4byte		FMTK_ForceReleaseIOFocus	# 23
                            	   757: #	.4byte		FMTK_RequestIOFocus			# 24
01:00000430 00000000        	   758: 	.4byte    OSCallBadFunc
01:00000434 00000000        	   759: 	.4byte    OSCallBadFunc
01:00000438 00000000        	   760: 	.4byte    OSCallBadFunc
01:0000043C 00000000        	   761: 	.4byte    OSCallBadFunc
01:00000440 00000000        	   762: 	.4byte    OSCallBadFunc
                            	   763: #	.4byte		FMTK_MapOSVars          # 25
                            	   764: #	.4byte		FMTK_IO									# 26
                            	   765: #	.4byte    FMTK_GetDCBField        # 27
                            	   766: #	.4byte    FMTK_SetDCBField        # 28
01:00000444 00000000        	   767: 	.4byte    OSCallBadFunc
01:00000448 00000000        	   768: 	.4byte    OSCallBadFunc
01:0000044C 00000000        	   769: 	.4byte    OSCallBadFunc
01:00000450 00000000        	   770: 	.4byte    OSCallBadFunc
01:00000454 00000000        	   771: 	.4byte    OSCallBadFunc      			 # 29
01:00000458 00000000        	   772: 	.4byte    OSCallBadFunc		      	 # 30
01:0000045C 00000000        	   773: 	.4byte    OSCallBadFunc
                            	   774: #	.4byte    GetPamBit               # 32
01:00000460 00000000        	   775: 	.4byte    OSCallBadFunc
                            	   776: #	.4byte    FetchMemoryWord         # 33
01:00000464 00000000        	   777: 	.4byte    OSCallBadFunc
                            	   778: #	.4byte    Monitor                 # 34
01:00000468 00000000        	   779: 	.4byte    OSCallBadFunc
01:0000046C 00000000        	   780: 	.4byte    OSCallBadFunc           # 35
01:00000470 00000000        	   781: 	.4byte    OSCallBadFunc           # 36
01:00000474 00000000        	   782: 	.4byte    OSCallBadFunc
01:00000478 00000000        	   783: 	.4byte    OSCallBadFunc
01:0000047C 00000000        	   784: 	.4byte    OSCallBadFunc
01:00000480 00000000        	   785: 	.4byte    OSCallBadFunc         	 # 40
01:00000484 00000000        	   786: 	.4byte    OSCallBadFunc           # 41
01:00000488 00000000        	   787: 	.4byte    OSCallBadFunc           # 42
01:0000048C 00000000        	   788: 	.4byte    OSCallBadFunc
01:00000490 000008B4        	   789: 	.4byte    FemtikiTimerISR         # 44
                            	   790: #	.4byte    FMTK_Reschedule         # 45
01:00000494 00000000        	   791: 	.4byte    OSCallBadFunc
01:00000498 00000000        	   792: 	.4byte    OSCallBadFunc      			# 46
01:0000049C 00000000        	   793: 	.4byte    OSCallBadFunc						# 47
01:000004A0 00000000        	   794: 	.4byte		OSCallBadFunc							 # 48
01:000004A4 00001290        	   795: 	.4byte		DumpTCBs								# 49
01:000004A8 00000000        	   796: 	.4byte		OSCallBadFunc						# 50
01:000004AC 00000000        	   797: 	.4byte		OSCallBadFunc						# 51
                            	   798: 
                            	   799: .set NUM_OSFUNC,52	#($-OSCallTbl) / 2
                            	   800: 
                            	   801: EnvCallMediumTable:
                            	   802: .set NUM_MWENVFUNC,0
                            	   803: 
                            	   804: EnvCallLightTable:
01:000004B0 000000DC        	   805: 	.4byte		FMTK_LockSemaphore			# 0
01:000004B4 00000134        	   806: 	.4byte		FMTK_UnlockSemaphore		# 1
01:000004B8 00000630        	   807: 	.4byte    FMTK_GetAppTaskId       # 2
01:000004BC 00000588        	   808: 	.4byte		FMTK_GetTaskAppId       # 3
01:000004C0 000005F8        	   809: 	.4byte    FMTK_SetTaskAppId       # 4
01:000004C4 00000530        	   810: 	.4byte    GetIRQFlag              # 5
01:000004C8 0000057C        	   811: 	.4byte    SetIRQFlag              # 6
01:000004CC 000004A4        	   812: 	.4byte		FMTK_GetCurrentTid			# 7
01:000004D0 000006B4        	   813: 	.4byte    FMTK_GetCurrentMid      # 8
01:000004D4 00000790        	   814: 	.4byte    FMTK_GetRunningTCBPointer	# 9
01:000004D8 000006A8        	   815: 	.4byte		FMTK_SetTaskId          # 10
01:000004DC 00000D14        	   816: 	.4byte	FMTK_Sleep								# 11
01:000004E0 0000116C        	   817: 	.4byte	FMTK_FreeTCB							# 12
01:000004E4 000015AC        	   818: 	.4byte	FMTK_AllocMbx							# 13
                            	   819: 
                            	   820: .set NUM_LWENVFUNC,14
                            	   821: 
                            	   822: #------------------------------------------------------------------------------
                            	   823: #------------------------------------------------------------------------------
                            	   824: 
                            	   825: FMTK_Initialize:
01:000004E8 5ACA0280        	   826:   bl FMTK_Init
01:000004EC 44000080        	   827:   loadi %a0,E_Ok
01:000004F0 1A000080        	   828:   b OSExit
                            	   829:  
                            	   830: #------------------------------------------------------------------------------
                            	   831: # Get the task id for the currently running task.
                            	   832: # Accesses a global (local to the CPU) variable.
                            	   833: #
                            	   834: # Parameters:
                            	   835: #		none
                            	   836: # Returns:
                            	   837: #		a0 = task id
                            	   838: #------------------------------------------------------------------------------
                            	   839: 
                            	   840: GetCurrentTid:
01:000004F4 660004A045233100	   841: 	load %a0,RunningID
01:000004FC 2800F8FF
01:00000500 1A000024        	   842: 	blr
                            	   843: 
                            	   844: #------------------------------------------------------------------------------
                            	   845: # Get the task id for the currently running task.
                            	   846: #
                            	   847: # Parameters:
                            	   848: #		a1 = place to put task id
                            	   849: # Returns:
                            	   850: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   851: #		task id at address given in %a1
                            	   852: #------------------------------------------------------------------------------
                            	   853: 
                            	   854: FMTK_GetCurrentTid:
                            	   855: 	macAdrCheck %a1
01:00000504 03120080        	     1M 	cmpai %cr0,%a1,0						# NULL pointer?
01:00000508 431200A0        	     2M 	cmpai %cr1,%a1,0x00800000		# too low
01:0000050C 831204A0        	     3M 	cmpai %cr2,%a1,0xC0000000		# too high
01:00000510 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:00000514 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:00000518 F93D80E0        	     6M 	peq %cr0,.000110
01:0000051C 44000280        	     7M 	loadi %a0,E_Arg
01:00000520 1A000080        	     8M 	b OSExit
                            	     9M .000110:
01:00000524 660008A0        	   856: 	load %a0,RunningID
                            	   857: 	macTCBPointerToHandle
01:00000528 42081482        	     1M 	srli %a0,%a0,LOG_TCBSZ
01:0000052C 4A080CA000008000	     2M 	xori %a0,%a0,CB_XOR
01:00000534 000000C02800F8FF
01:0000053C 45233100
                            	   858: 	macStorePM
01:00000540 1E020040        	     1M   push %a2
01:00000544 C70008E0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:00000548 07000CE0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:0000054C 33000058        	     4M   sync
01:00000550 6E100000        	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:00000554 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000558 33000058        	     7M   sync
01:0000055C 1F020040        	     8M   pop %a2
01:00000560 44000080        	   859: 	loadi %a0,E_Ok
01:00000564 1A76FFFF        	   860: 	b EnvExitLight
                            	   861: 
                            	   862: #------------------------------------------------------------------------------
                            	   863: # (not used - use mprv bit instead)
                            	   864: # Convert the virtual addresss to a physical one. Done by using the MMU's
                            	   865: # conversion facility. One gotcha is that other tasks must be locked out
                            	   866: # during the conversion.
                            	   867: #
                            	   868: # Parameters:
                            	   869: # 	a0 = virtual address
                            	   870: # Returns:
                            	   871: #		a0 = physical address
                            	   872: #------------------------------------------------------------------------------
                            	   873: 
                            	   874: # The virtual address is offset by the base register into the MMU mapping table
                            	   875: ConvertVirtualToPhysical:
01:00000568 1E000448        	   876: 	push %br1
01:0000056C 1E030040        	   877: 	push %a1/%a2
01:00000570 CF080080        	   878: 	move %a2,%a0
01:00000574 4400FEFF00001C00	   879: 	loadi %a0,-1
01:0000057C 00001800
01:00000580 84000080        	   880: 	loadi %a1,MMUSEMA
01:00000584 5BB6FEFF        	   881: 	bl LockSemaphore
01:00000588 EE0000A0        	   882: 	store %a2,MMUxVIRTADR
                            	   883: 	# poll the conversion complete bit, this should not take long
                            	   884: .0001:
01:0000058C 660004A4        	   885: 	load. %a0,MMUxPADRV
01:00000590 193C40E1        	   886: 	beq %cr0,.0001
01:00000594 660008A0        	   887: 	load %a0,MMUxPHYSADR
                            	   888: 	macUnlockMMUSemaphore
01:00000598 2E000600        	     1M 	store %r0,MMUSEMA
01:0000059C 1F030040        	   889: 	pop %a1/%a2
01:000005A0 1F000448        	   890: 	pop %br1
01:000005A4 1A000024        	   891: 	blr
                            	   892: 
                            	   893: #------------------------------------------------------------------------------
                            	   894: # Get the IRQ flag which a CPU local global variable.
                            	   895: #
                            	   896: # Parameters:
                            	   897: #		a1 = place to put flag
                            	   898: # Returns:
                            	   899: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   900: #		IRQ flag at address given in %a1
                            	   901: #------------------------------------------------------------------------------
                            	   902: 
                            	   903: GetIRQFlag:
                            	   904: 	macAdrCheck %a1
01:000005A8 03120080        	     1M 	cmpai %cr0,%a1,0						# NULL pointer?
01:000005AC 43120CA04000F4FF	     2M 	cmpai %cr1,%a1,0x00800000		# too low
01:000005B4 6000F4FF5000F4FF
01:000005BC 00008000
01:000005C0 831200A0        	     3M 	cmpai %cr2,%a1,0xC0000000		# too high
01:000005C4 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:000005C8 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:000005CC F93C80E0        	     6M 	peq %cr0,.000114
01:000005D0 44000280        	     7M 	loadi %a0,E_Arg
01:000005D4 1A000080        	     8M 	b OSExit
                            	     9M .000114:
01:000005D8 610004A0        	   905:   ldbz %a0,IRQFlag		# get the flag
                            	   906:   macStorePM
01:000005DC 1E020040        	     1M   push %a2
01:000005E0 C70008E0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:000005E4 07000CE0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:000005E8 33000058        	     4M   sync
01:000005EC 6E100000000000C0	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:000005F4 1200FCFF00001C00
01:000005FC 00001800
01:00000600 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000604 33000058        	     7M   sync
01:00000608 1F020040        	     8M   pop %a2
01:0000060C 44000080        	   907: 	loadi %a0,E_Ok
01:00000610 1B4AFFFF        	   908: 	b EnvExitLight
                            	   909: 
                            	   910: #------------------------------------------------------------------------------
                            	   911: # Set the IRQ flag which a CPU local global variable.
                            	   912: #
                            	   913: # Parameters:
                            	   914: #		%a1 = value for flag
                            	   915: # Returns:
                            	   916: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   917: #------------------------------------------------------------------------------
                            	   918: 
                            	   919: SetIRQFlag:
01:00000614 A80000A0        	   920:   stb %a1,IRQFlag
01:00000618 44000080        	   921:   loadi %a0,E_Ok
01:0000061C 1A48FFFF        	   922:   b EnvExitLight
                            	   923: 
                            	   924: #------------------------------------------------------------------------------
                            	   925: # Accessors
                            	   926: #------------------------------------------------------------------------------
                            	   927: 
                            	   928: #------------------------------------------------------------------------------
                            	   929: # Get the owning app id for the task.
                            	   930: #
                            	   931: # Parameters:
                            	   932: #	 	%a1 = task id
                            	   933: #		%a2 = place to store app id
                            	   934: # Returns:
                            	   935: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a2, E_Arg for bad
                            	   936: #        TCB number
                            	   937: #		app id stored at address pointed to by %a2
                            	   938: #------------------------------------------------------------------------------
                            	   939: 
                            	   940: FMTK_GetTaskAppId:
01:00000620 03120080        	   941:   cmpai %cr0,%a1,0
01:00000624 593E40E1        	   942:   beq %cr0,.0001
                            	   943:   macAdrCheck %a2
01:00000628 031A0080        	     1M 	cmpai %cr0,%a2,0						# NULL pointer?
01:0000062C 431A04A0        	     2M 	cmpai %cr1,%a2,0x00800000		# too low
01:00000630 831A08A01200FCFF	     3M 	cmpai %cr2,%a2,0xC0000000		# too high
01:00000638 00008000000000C0
01:00000640 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:00000644 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:00000648 F83B80E0        	     6M 	peq %cr0,.000116
01:0000064C 44000280        	     7M 	loadi %a0,E_Arg
01:00000650 1A000080        	     8M 	b OSExit
                            	     9M .000116:
01:00000654 660000A0        	   944: 	load %a0,RunningID
                            	   945: 	macTCBHandleToPointer
01:00000658 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:0000065C 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000660 66085806        	   946: 	load %a0,TCBappid[%a0]
                            	   947: 	macACBPointerToHandle
01:00000664 42081C82        	     1M 	srli %a0,%a0,LOG_ACBSZ
01:00000668 4A0804A0        	     2M 	xori %a0,%a0,CB_XOR
                            	   948: 	macStorePM
01:0000066C 1E020040        	     1M   push %a2
01:00000670 C70008E02800F8FF	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:00000678 4523310000001C00
01:00000680 070008E0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00000684 33000058        	     4M   sync
01:00000688 6E100000        	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:0000068C 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000690 33000058        	     7M   sync
01:00000694 1F020040        	     8M   pop %a2
01:00000698 44000080        	   949: 	loadi %a0,E_Ok
01:0000069C 1A28FFFF        	   950: 	b EnvExitLight
                            	   951: .0001:
01:000006A0 44000280        	   952: 	loadi %a0,E_Arg
01:000006A4 1A26FFFF        	   953: 	b EnvExitLight
                            	   954: 
                            	   955: #------------------------------------------------------------------------------
                            	   956: # Set the owning app id for the task.
                            	   957: #
                            	   958: # Parameters:
                            	   959: #		%a1 = task id
                            	   960: #		%a2 = App id
                            	   961: # Returns:
                            	   962: #		a0 = status, E_Ok or E_Arg for bad TCB number
                            	   963: #------------------------------------------------------------------------------
                            	   964: #
                            	   965: FMTK_SetTaskAppId:
01:000006A8 03120080        	   966:   cmpai %cr0,%a1,0
01:000006AC D93B40E1        	   967:   beq %cr0,.0001
01:000006B0 4F100080        	   968:   move %a0,%a1
                            	   969: 	macTCBHandleToPointer
01:000006B4 4A0804A000001800	     1M 	xori %a0,%a0,CB_XOR
01:000006BC 45233100
01:000006C0 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:000006C4 8F080080        	   970: 	move %a1,%a0
                            	   971: 	# compare to zero?
01:000006C8 4F180080        	   972: 	move %a0,%a2
                            	   973: 	macACBHandleToPointer
01:000006CC 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:000006D0 42081C80        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:000006D4 74105806        	   974: 	stptr %a0,TCBappid[%a1]
01:000006D8 44000080        	   975: 	loadi %a0,E_Ok
01:000006DC 1A18FFFF        	   976: 	b EnvExitLight
                            	   977: .0001:
01:000006E0 44000280        	   978: 	loadi %a0,E_Arg
01:000006E4 1A16FFFF        	   979: 	b EnvExitLight
                            	   980: 
                            	   981: #------------------------------------------------------------------------------
                            	   982: # Get the task associated with the app.
                            	   983: #
                            	   984: # Parameters
                            	   985: #		%a1 = app id
                            	   986: #		%a2 = address to store task id at
                            	   987: #------------------------------------------------------------------------------
                            	   988: 
                            	   989: FMTK_GetAppTaskId:
01:000006E8 03120080        	   990:   cmpai %cr0,%a1,0
01:000006EC 993D40E1        	   991:   beq %cr0,.0001
                            	   992:   macAdrCheck %a2
01:000006F0 031A0080        	     1M 	cmpai %cr0,%a2,0						# NULL pointer?
01:000006F4 431A04A045233100	     2M 	cmpai %cr1,%a2,0x00800000		# too low
01:000006FC 00008000
01:00000700 831A00A0        	     3M 	cmpai %cr2,%a2,0xC0000000		# too high
01:00000704 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:00000708 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:0000070C F93A80E0        	     6M 	peq %cr0,.000122
01:00000710 44000280        	     7M 	loadi %a0,E_Arg
01:00000714 1A000080        	     8M 	b OSExit
                            	     9M .000122:
01:00000718 4F100080        	   993: 	move %a0,%a1				# a0 = app id
                            	   994: 	macACBHandleToPointer
01:0000071C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000720 42081C80        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:00000724 66080400        	   995: 	load %a0,ACBTask[%a0]
                            	   996: 	macTCBPointerToHandle
01:00000728 42081482        	     1M 	srli %a0,%a0,LOG_TCBSZ
01:0000072C 4A0804A0        	     2M 	xori %a0,%a0,CB_XOR
01:00000730 66085806        	   997: 	load %a0,TCBappid[%a0]
01:00000734 8F180080000000C0	   998: 	move %a1,%a2
01:0000073C 45233100
                            	   999: 	macStorePM
01:00000740 1E020040        	     1M   push %a2
01:00000744 C70008E0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:00000748 07000CE0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:0000074C 33000058        	     4M   sync
01:00000750 6E100000        	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:00000754 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000758 33000058        	     7M   sync
01:0000075C 1F020040        	     8M   pop %a2
01:00000760 44000080        	  1000: 	loadi %a0,E_Ok
01:00000764 1AF6FEFF        	  1001: 	b EnvExitLight
                            	  1002: .0001:
01:00000768 44000280        	  1003: 	loadi %a0,E_Arg
01:0000076C 1AF4FEFF        	  1004: 	b EnvExitLight
                            	  1005: 
                            	  1006: #------------------------------------------------------------------------------
                            	  1007: # Set the task associated with the app.
                            	  1008: #
                            	  1009: # The following only really needed by startup code, otherwise the task id
                            	  1010: # is completely managed by the OS.
                            	  1011: #------------------------------------------------------------------------------
                            	  1012: 
                            	  1013: FMTK_SetTaskId:
                            	  1014:   # Should get the id and see if it s currently zero (unset).
                            	  1015:   # but this would be more code bloat.
01:00000770 B40008A000001C00	  1016:   stptr %a1,RunningID
01:00000778 000018002800F8FF
01:00000780 44000080        	  1017:   loadi %a0,E_Ok
01:00000784 1AEEFEFF        	  1018: 	b EnvExitLight
                            	  1019: 
                            	  1020: #------------------------------------------------------------------------------
                            	  1021: #------------------------------------------------------------------------------
                            	  1022: 
                            	  1023: FMTK_GetCurrentMid:
01:00000788 660000A0        	  1024: 	load %a0,RunningID
                            	  1025: 	macTCBHandleToPointer
01:0000078C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000790 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000794 66085806        	  1026: 	load %a0,TCBappid[%a0]
01:00000798 61089407        	  1027: 	ldbz %a0,ACBmid[%a0]
                            	  1028: 	macStorePM
01:0000079C 1E020040        	     1M   push %a2
01:000007A0 C70008E0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:000007A4 07000CE0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:000007A8 33000058        	     4M   sync
01:000007AC 6E1000002800F8FF	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:000007B4 4523310000001C00
01:000007BC 00001800
01:000007C0 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:000007C4 33000058        	     7M   sync
01:000007C8 1F020040        	     8M   pop %a2
01:000007CC 44000080        	  1029: 	loadi %a0,E_Ok
01:000007D0 1BDAFEFF        	  1030: 	b EnvExitLight
                            	  1031: .0001:
01:000007D4 44000280        	  1032: 	loadi %a0,E_Arg
01:000007D8 1BD8FEFF        	  1033: 	b EnvExitLight
                            	  1034: 
                            	  1035: #------------------------------------------------------------------------------
                            	  1036: # Parameters:
                            	  1037: #		%a1 = task id
                            	  1038: #		%a2 = address to put mid in
                            	  1039: #------------------------------------------------------------------------------
                            	  1040: 
                            	  1041: FMTK_GetMid:
01:000007DC 03100080        	  1042: 	cmpi %cr0,%a1,0
01:000007E0 D93B40E1        	  1043: 	beq %cr0,.0001
                            	  1044: 	macAdrCheck %a2
01:000007E4 031A0080        	     1M 	cmpai %cr0,%a2,0						# NULL pointer?
01:000007E8 431A00A0        	     2M 	cmpai %cr1,%a2,0x00800000		# too low
01:000007EC 831A04A0        	     3M 	cmpai %cr2,%a2,0xC0000000		# too high
01:000007F0 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:000007F4 0B00400E00008000	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:000007FC 000000C0
01:00000800 F83980E0        	     6M 	peq %cr0,.000128
01:00000804 44000280        	     7M 	loadi %a0,E_Arg
01:00000808 1A000080        	     8M 	b OSExit
                            	     9M .000128:
01:0000080C 4F100080        	  1045: 	move %a0,%a1
                            	  1046: 	macTCBHandleToPointer
01:00000810 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000814 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000818 66085806        	  1047: 	load %a0,TCBappid[%a0]
01:0000081C 61089407        	  1048: 	ldbz %a0,ACBmid[%a0]
                            	  1049: 	macStorePM
01:00000820 1E020040        	     1M   push %a2
01:00000824 C7000CE0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:00000828 070008E0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:0000082C 33000058        	     4M   sync
01:00000830 6E10000045233100	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:00000838 00001C0000001800
01:00000840 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000844 33000058        	     7M   sync
01:00000848 1F020040        	     8M   pop %a2
01:0000084C 44000080        	  1050: 	loadi %a0,E_Ok
01:00000850 1BBAFEFF        	  1051: 	b EnvExitLight
                            	  1052: .0001:
01:00000854 44000280        	  1053: 	loadi %a0,E_Arg
01:00000858 1BB8FEFF        	  1054: 	b EnvExitLight
                            	  1055: 	
                            	  1056: #------------------------------------------------------------------------------
                            	  1057: # Get a pointer to the TCB for the currently running task.
                            	  1058: #
                            	  1059: # Parameters:
                            	  1060: #		none
                            	  1061: # Returns:
                            	  1062: #		a0 = pointer to running TCB
                            	  1063: #------------------------------------------------------------------------------
                            	  1064: 
                            	  1065: .macro macGetRunningTCBPointer
                            	  1066: 	load %a0,RunningID
                            	  1067: 	macTCBHandleToPointer
                            	  1068: .endm
                            	  1069: 
                            	  1070: GetRunningTCBPointer:
01:0000085C 660000A0        	  1071: 	load %a0,RunningID
                            	  1072: 	macTCBHandleToPointer
01:00000860 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000864 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000868 1A000024        	  1073: 	blr
                            	  1074: 	
                            	  1075: GetRunningACBPointer:
01:0000086C 660000A0        	  1076: 	load %a0,RunningID
                            	  1077: 	macTCBHandleToPointer
01:00000870 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000874 420814802800F8FF	     2M 	slli %a0,%a0,LOG_TCBSZ
01:0000087C 45233100
01:00000880 66085806        	  1078: 	load %a0,TCBappid[%a0]
                            	  1079: 	macACBHandleToPointer
01:00000884 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000888 42081C80        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:0000088C 1A000024        	  1080: 	blr
                            	  1081: 
                            	  1082: #------------------------------------------------------------------------------
                            	  1083: # ToDo: Should check that app is capable of using TCB pointers
                            	  1084: #
                            	  1085: # Parameters:
                            	  1086: #		%a1 = address to put pointer in
                            	  1087: #------------------------------------------------------------------------------
                            	  1088: 
                            	  1089: FMTK_GetRunningTCBPointer:
                            	  1090: 	macAdrCheck %a1
01:00000890 03120080        	     1M 	cmpai %cr0,%a1,0						# NULL pointer?
01:00000894 431204A0        	     2M 	cmpai %cr1,%a1,0x00800000		# too low
01:00000898 831208A0        	     3M 	cmpai %cr2,%a1,0xC0000000		# too high
01:0000089C 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:000008A0 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:000008A4 F93880E0        	     6M 	peq %cr0,.000134
01:000008A8 44000280        	     7M 	loadi %a0,E_Arg
01:000008AC 1A000080        	     8M 	b OSExit
                            	     9M .000134:
                            	  1091: 	macGetRunningTCBPointer
01:000008B0 66000CA045233100	     1M 	load %a0,RunningID
01:000008B8 00008000000000C0
                            	     2M 	macTCBHandleToPointer
01:000008C0 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:000008C4 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
                            	  1092: 	macStorePtrPM
01:000008C8 1E020040        	     1M   push %a2
01:000008CC C7000CE0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:000008D0 070008E0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:000008D4 33000058        	     4M   sync
01:000008D8 74100000        	     5M 	stptr %a0,[%a1]						# do the store to the proper address space
01:000008DC 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:000008E0 33000058        	     7M   sync
01:000008E4 1F020040        	     8M   pop %a2
01:000008E8 44000080        	  1093: 	loadi %a0,E_Ok
01:000008EC 1A94FEFF        	  1094: 	b EnvExitLight
                            	  1095: 
                            	  1096: #------------------------------------------------------------------------------
                            	  1097: # Decrement the timeout. Only the timeout at the head of the list need be
                            	  1098: # decremented. If the timeout as reached zero (or lower) then insert the 
                            	  1099: # task into the ready queue. Then check the next item in the timeout list
                            	  1100: # to see if it is also zero (or lower).
                            	  1101: # There is a loop in this code. Usually it would short however unless there
                            	  1102: # are a lot of tasks timing out at the same time.
                            	  1103: #
                            	  1104: # Some experimentation has gone into doing this with hardware.
                            	  1105: #------------------------------------------------------------------------------
                            	  1106: 
                            	  1107: #				while (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	  1108: #					if (tcbs[TimeoutList].timeout<=0)
                            	  1109: #						InsertIntoReadyList(PopTimeoutList());
                            	  1110: #					else {
                            	  1111: #						tcbs[TimeoutList].timeout = tcbs[TimeoutList].timeout - missed_ticks - 1;
                            	  1112: #						missed_ticks = 0;
                            	  1113: #						break;
                            	  1114: #					}
                            	  1115: #				}
                            	  1116: 
                            	  1117: DecrementTimeout:
                            	  1118: .0003:
01:000008F0 66000CA445233100	  1119: 	load.	%a0,TimeoutList				# a0 = pointer to timeout list
01:000008F8 00001C0000001800
01:00000900 993840E1        	  1120: 	beq %cr0,.0001
01:00000904 A6083806        	  1121: 	load. %a1,TCBTimeout[%a0]
01:00000908 F83748E1        	  1122: 	pgt %cr0,.0002
01:0000090C 5A4A0280        	  1123: 	bl PopTimeoutList
01:00000910 5A200280        	  1124: 	bl InsertIntoReadyQueue
01:00000914 1AB4FFFF        	  1125: 	b .0003
                            	  1126: .0002:
01:00000918 8410FEFF        	  1127: 	subi %a1,%a1,1
01:0000091C 8A100000        	  1128: 	neg %a1,%a1									# we really wanted amosub here
01:00000920 3B10C080        	  1129: 	amoadd %r0,%a1,missed_ticks
01:00000924 8A100000        	  1130: 	neg %a1,%a1
01:00000928 AE083806        	  1131: 	store %a1,TCBTimeout[%a0]
                            	  1132: .0001:
01:0000092C 1A000024        	  1133: 	blr
                            	  1134: 
                            	  1135: #------------------------------------------------------------------------------
                            	  1136: # Helper routine for the timer ISR. Makes the code a little easier to read.
                            	  1137: #------------------------------------------------------------------------------
                            	  1138: 
                            	  1139: SchedulerIRQHelper:
01:00000930 CF4A1480        	  1140: 	move %br3,%br1
01:00000934 44002880        	  1141: 	loadi %a0,20
01:00000938 03080080        	  1142: 	cmpi %cr0,%a0,0
01:0000093C 583B40E1        	  1143: 	beq %cr0,.0003
01:00000940 660000A0        	  1144: 	load %a0,RunningID
                            	  1145: 	macTCBHandleToPointer
01:00000944 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000948 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
                            	  1146: 	# Compute %a5 = number of ticks running
01:0000094C A608D805        	  1147: 	load %a1,TCBEndTick[%a0]
01:00000950 E608C805        	  1148: 	load %a2,TCBStartTick[%a0]
01:00000954 8C190400        	  1149: 	sub %a5,%a1,%a2
01:00000958 4408E885        	  1150: 	addi %a0,%a0,TCBTicks
01:0000095C 3B38C080        	  1151: 	amoadd %r0,%a5,[%a0]	# calc total cumulative ticks running
01:00000960 440818FA        	  1152: 	addi %a0,%a0,-TCBTicks
                            	  1153: 
                            	  1154: 	# Check the task priority, special priority 63
01:00000964 A1080400        	  1155: 	ldbz %a1,TCBPriorty[%a0]
01:00000968 03127E80        	  1156: 	cmpai %cr0,%a1,63						# highest priority: refuse to task switch or even
01:0000096C D83986E0        	  1157: 	bge %cr0,.0003							# decrement timeout
01:00000970 84004080        	  1158: 	loadi %a1,TS_PREEMPT
01:00000974 440878852800F8FF	  1159: 	addi %a0,%a0,TCBStatus
01:0000097C 45233100
01:00000980 3B180082        	  1160: 	amoorb %r0,%a1,[%a0]
01:00000984 440888FA        	  1161: 	addi %a0,%a0,-TCBStatus
01:00000988 5B96FFFF        	  1162: 	bl DecrementTimeout
01:0000098C A1087A05        	  1163: 	ldbz %a1,TCBPriority[%a0]		# very high priority > 59, don't switch
01:00000990 03127880        	  1164: 	cmpai %cr0,%a1,60
01:00000994 F93746E1        	  1165: 	pge %cr0,.0002
01:00000998 03320680        	  1166: 	cmpai %cr0,%a5,3							# allow the task to run for 3 ticks
01:0000099C F93786E0        	  1167: 	plt %cr0,.0002
01:000009A0 5BF60080        	  1168: 	bl SelectTaskToRun
01:000009A4 6E0000A0        	  1169: 	store %a0,RunningID
                            	  1170: 	macTCBHandleToPointer
01:000009A8 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:000009AC 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
                            	  1171: .0002:
01:000009B0 84000081        	  1172: 	loadi %a1,TS_RUNNING
01:000009B4 440878852800F8FF	  1173: 	addi %a0,%a0,TCBStatus
01:000009BC 45233100
01:000009C0 3B180082        	  1174: 	amoorb %r0,%a1,[%a0]
01:000009C4 4F5A1480        	  1175: 	move %br1,%br3
01:000009C8 1A000024        	  1176: 	blr
                            	  1177: .0003:
01:000009CC 44000080        	  1178: 	loadi %a0,missed_ticks
01:000009D0 3B08C080        	  1179: 	amoadd %r0,1,[%a0]
01:000009D4 4F5A1480        	  1180: 	move %br1,%br3
01:000009D8 1A000024        	  1181: 	blr
                            	  1182: 
                            	  1183: #------------------------------------------------------------------------------
                            	  1184: # Femtiki Timer ISR
                            	  1185: #
                            	  1186: # The only thing manipulating the TCB ready list must be the timer IRQ. This
                            	  1187: # is to prevent deadlocks from ocurring. Since only the timer IRQ manipulates
                            	  1188: # the list, there is no need to protect it with a semaphore. However, with
                            	  1189: # the restriction that the ISR is the only list manipulator, it must then
                            	  1190: # provide services for updating the list to other OS functions.
                            	  1191: #
                            	  1192: # Side Effects:
                            	  1193: #		The context may be changed to another task.
                            	  1194: #		If an exception occurred in the task, the task is setup to return to
                            	  1195: #		the exception handler.
                            	  1196: # Parameters:
                            	  1197: #		none - it is a hardware ISR.
                            	  1198: # Returns:
                            	  1199: #		none - hardware ISR
                            	  1200: #------------------------------------------------------------------------------
                            	  1201: 
                            	  1202: FemtikiTimerISR:
01:000009DC 9E1F0040        	  1203: 	push %a0-%a6								# push a0 to %a6
01:000009E0 5E400048        	  1204: 	push %cr0
01:000009E4 1E007C48        	  1205: 	push %br1-%br6							# push %br1 to %br6
01:000009E8 660000A0        	  1206: 	load %a0,RunningID
                            	  1207: 	macTCBHandleToPointer
01:000009EC 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:000009F0 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:000009F4 87001A602800F8FF	  1208: 	csrrsi %a1,M_SEMA,InTimerISRFlag	# get InTimerISR flag
01:000009FC 45233100
01:00000A00 88100284        	  1209: 	andi. %a1,%a1,InTimerISRFlag
01:00000A04 593A80E0        	  1210: 	bne %cr0,.0004
01:00000A08 74000000        	  1211: 	stptr %a0,PrevRunningPointer			# Keep track of previous Running TCB
01:00000A0C 4F090080        	  1212: 	move %a4,%a0									
01:00000A10 8F080080        	  1213: 	move %a1,%a0
                            	  1214: 	macIGetTick
01:00000A14 66000000        	     1M 	load %a0,milliseconds
01:00000A18 6E10D805        	  1215: 	store %a0,TCBEndTick[%a1]
01:00000A1C 5B7EFFFF        	  1216: 	bl SchedulerIRQHelper
01:00000A20 660000A0        	  1217: 	load %a0,RunningID						# scheduling may have changed this value
                            	  1218: 	macTCBHandleToPointer
01:00000A24 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000A28 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000A2C 8F090080        	  1219: 	move %a5,%a0									# save a copy of the id
01:00000A30 4A090A00        	  1220: 	xor %a4,%a0,%a4								# %a4 = flag if running changed
01:00000A34 A108F9052800F8FF	  1221: 	ldbz. %a1,TCBException[%a0]
01:00000A3C 45233100
01:00000A40 F93780E0        	  1222: 	peq %cr0,.0001
                            	  1223: 	# Exception processing code
                            	  1224: 	# Causes a transfer to the exception handler
01:00000A44 AE088000        	  1225: 	store %a1,TCBxA0[%a0]					# save exception code in %a0
01:00000A48 2E08DA00        	  1226: 	storei 45,TCBxA1[%a0]					# store exception type in %a1
01:00000A4C 2E08F805        	  1227: 	store %r0,TCBException[%a0]		# set exception to zero
01:00000A50 A608B004        	  1228: 	load %a1,TCBxXH[%a0]					# move handler address to link register
01:00000A54 B4082000        	  1229: 	stptr %a1,TCBxBR1[%a0]
01:00000A58 B408A004        	  1230: 	stptr %a1,TCBxPC[%a0]					# move handler address to PC register
                            	  1231: .0001:
01:00000A5C 8F080080        	  1232: 	move %a1,%a0
                            	  1233: 	macIGetTick
01:00000A60 66000000        	     1M 	load %a0,milliseconds
01:00000A64 6E10C805        	  1234: 	store %a0,TCBStartTick[%a1]
                            	  1235: 	# Did we stay in the same task?
01:00000A68 03280080        	  1236: 	cmpi %cr0,%a4,0
01:00000A6C D93780E0        	  1237: 	bne %cr0,.0002
                            	  1238: 	# If in same task, just pop registers and return
01:00000A70 1F007C48        	  1239: 	pop %br1-%br6							# get back %br1 to %br6
01:00000A74 5F400048        	  1240: 	pop %cr0
01:00000A78 9F1F0040        	  1241: 	pop %a0-%a6								# get back a0 to %a6
                            	  1242: 	# We need the rfi to execute without an interrupt between the csrrc and rfi
01:00000A7C F800FE84        	  1243: 	atom 63,.0004
01:00000A80 07001A60        	  1244: 	csrrci %r0,M_SEMA,InTimerISRFlag
01:00000A84 13000004        	  1245: 	rfi
                            	  1246: 	# Return, but do not flag as ISR complete. We are returning to the ISR.
                            	  1247: .0004:
01:00000A88 44000280        	  1248: 	loadi %a0,1
01:00000A8C 3B08C080        	  1249: 	amoadd %r0,%a0,missed_ticks
01:00000A90 1F007C48        	  1250: 	pop %br1-%br6							# get back %br1 to %br6
01:00000A94 5F400048        	  1251: 	pop %cr0
01:00000A98 9F1F0040        	  1252: 	pop %a0-%a6								# get back a0 to %a6
01:00000A9C 13000004        	  1253: 	rfi
                            	  1254: 
                            	  1255: 	# Here a different task was selected, save and restore contexts
                            	  1256: 	# Going in:
                            	  1257: 	# 	%a4 = old task
                            	  1258: 	#		%a5 = new task
                            	  1259: .0002:
01:00000AA0 1F007C48        	  1260: 	pop %br1-%br6							# get back %br1 to %br6
01:00000AA4 5F400048        	  1261: 	pop %cr0
01:00000AA8 9F1F0040        	  1262: 	pop %a0-%a6								# get back a0 to %a6
                            	  1263: 
                            	  1264: #------------------------------------------------------------------------------
                            	  1265: # Context switch code	
                            	  1266: # Switches from PrevRunningPointer to RunningID
                            	  1267: #
                            	  1268: # One issue with the context switching code and the current system is that
                            	  1269: # the queue in the memory controller can overflow if there are a lot of
                            	  1270: # stores in rapid succession. The queue full status is passed to the CPU
                            	  1271: # and ends up in the extra bit CR7. Loads do not have this issue as they
                            	  1272: # wait for responses from the memory controller.
                            	  1273: #------------------------------------------------------------------------------
                            	  1274: 
                            	  1275: SwitchTask:
01:00000AAC 070882E0        	  1276: 	csrrw %r0,SCRATCH,%a0		# save a0 in scratch register
01:00000AB0 1E000448        	  1277: 	push %br1
01:00000AB4 660000003F000000	  1278: 	load %a0,PrevRunningPointer
01:00000ABC 3F000000
                            	  1279: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1280: 	# Store the destination context
                            	  1281: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01:00000AC0 AE089000        	  1282: 	store %a1,TCBxA1[%a0]		# save %a1 in TCB so we can use it
01:00000AC4 1F000448        	  1283: 	pop %br1								# restore link register
01:00000AC8 870082E0        	  1284: 	csrrd %a1,SCRATCH			# save original a0 in task control block
01:00000ACC AE088000        	  1285: 	store %a1,TCBxA0[%a0]
                            	  1286: 	# save condition registers
01:00000AD0 8F801080        	  1287: 	move %a1,%cr0
01:00000AD4 AE080800        	  1288: 	store %a1,TCBxCR0[%a0]
01:00000AD8 8F881080        	  1289: 	move %a1,%cr1
01:00000ADC AE080A00        	  1290: 	store %a1,TCBxCR1[%a0]
01:00000AE0 8F901080        	  1291: 	move %a1,%cr2
01:00000AE4 AE080C00        	  1292: 	store %a1,TCBxCR2[%a0]
01:00000AE8 8F981080        	  1293: 	move %a1,%cr3
01:00000AEC AE080E00        	  1294: 	store %a1,TCBxCR3[%a0]
01:00000AF0 8FA01080        	  1295: 	move %a1,%cr4
01:00000AF4 AE081000        	  1296: 	store %a1,TCBxCR4[%a0]
01:00000AF8 8FA81080        	  1297: 	move %a1,%cr5
01:00000AFC AE081200        	  1298: 	store %a1,TCBxCR5[%a0]
01:00000B00 8FB01080        	  1299: 	move %a1,%cr6
01:00000B04 AE081400        	  1300: 	store %a1,TCBxCR6[%a0]
01:00000B08 8FB81080        	  1301: 	move %a1,%cr7
01:00000B0C AE081600        	  1302: 	store %a1,TCBxCR7[%a0]
                            	  1303: 	# save branch registers
01:00000B10 8F481080        	  1304: 	move %a1,%br1
01:00000B14 AE082000        	  1305: 	store %a1,TCBxBR1[%a0]
01:00000B18 8F501080        	  1306: 	move %a1,%br2
01:00000B1C AE083000        	  1307: 	store %a1,TCBxBR2[%a0]
01:00000B20 8F581080        	  1308: 	move %a1,%br3
01:00000B24 AE084000        	  1309: 	store %a1,TCBxBR3[%a0]
01:00000B28 8F601080        	  1310: 	move %a1,%br4
01:00000B2C AE085000        	  1311: 	store %a1,TCBxBR4[%a0]
01:00000B30 8F681080        	  1312: 	move %a1,%br5
01:00000B34 AE086000        	  1313: 	store %a1,TCBxBR5[%a0]
01:00000B38 8F701080        	  1314: 	move %a1,%br6
01:00000B3C AE087000        	  1315: 	store %a1,TCBxBR6[%a0]
                            	  1316: 	# save loop counter
01:00000B40 8FC01080        	  1317: 	move %a1,%lc
01:00000B44 AE089002        	  1318: 	store %a1,TCBxLC[%a0]
                            	  1319: 	# exception handler address
01:00000B48 8FE01080        	  1320: 	move %a1,%xh
01:00000B4C AE08B004        	  1321: 	store %a1,TCBxXH[%a0]
                            	  1322: 	# save GPRs
01:00000B50 EE08A000        	  1323: 	store %a2,TCBxA2[%a0]
01:00000B54 2E09B000        	  1324: 	store %a3,TCBxA3[%a0]
01:00000B58 6E09C000        	  1325: 	store %a4,TCBxA4[%a0]
01:00000B5C AE09D000        	  1326: 	store %a5,TCBxA5[%a0]
01:00000B60 EE09E000        	  1327: 	store %a6,TCBxA6[%a0]
01:00000B64 2E0AF000        	  1328: 	store %a7,TCBxA7[%a0]
01:00000B68 6E0A0001        	  1329: 	store %t0,TCBxT0[%a0]
01:00000B6C AE0A1001        	  1330: 	store %t1,TCBxT1[%a0]
01:00000B70 EE0A2001        	  1331: 	store %t2,TCBxT2[%a0]
01:00000B74 2E0B3001        	  1332: 	store %t3,TCBxT3[%a0]
01:00000B78 6E0B4001        	  1333: 	store %t4,TCBxT4[%a0]
01:00000B7C AE0B5001        	  1334: 	store %t5,TCBxT5[%a0]
01:00000B80 EE0B6001        	  1335: 	store %t6,TCBxT6[%a0]
01:00000B84 2E0C7001        	  1336: 	store %t7,TCBxT7[%a0]
01:00000B88 6E0C8001        	  1337: 	store %t8,TCBxT8[%a0]
01:00000B8C AE0C9001        	  1338: 	store %t9,TCBxT9[%a0]
01:00000B90 EE0CA001        	  1339: 	store %s0,TCBxS0[%a0]
01:00000B94 2E0DB001        	  1340: 	store %s1,TCBxS1[%a0]
01:00000B98 6E0DC001        	  1341: 	store %s2,TCBxS2[%a0]
01:00000B9C AE0DD001        	  1342: 	store %s3,TCBxS3[%a0]
01:00000BA0 EE0DE001        	  1343: 	store %s4,TCBxS4[%a0]
01:00000BA4 2E0EF001        	  1344: 	store %s5,TCBxS5[%a0]
01:00000BA8 6E0E0002        	  1345: 	store %s6,TCBxS6[%a0]
01:00000BAC AE0E1002        	  1346: 	store %s7,TCBxS7[%a0]
01:00000BB0 EE0E2002        	  1347: 	store %s8,TCBxS8[%a0]
01:00000BB4 2E0F3002        	  1348: 	store %s9,TCBxS9[%a0]
01:00000BB8 6E0F4002        	  1349: 	store %gp,TCBxGP[%a0]
01:00000BBC AE0F5002        	  1350: 	store %fp,TCBxFP[%a0]
01:00000BC0 870008E0        	  1351: 	csrrd %a1,SR
01:00000BC4 AE083005        	  1352: 	store %a1,TCBxSR[%a0]
                            	  1353: 	# check to see if FPRs need to be saved
01:00000BC8 87002880        	  1354: 	csrrd %a1,FPSR
01:00000BCC AE084005        	  1355: 	store %a1,TCBxFPSR[%a0]
01:00000BD0 87002660        	  1356: 	csrrci %a1,XS,3
01:00000BD4 88100604        	  1357: 	and. %a1,%a1,3
01:00000BD8 03100680        	  1358: 	cmpi %cr0,%a1,3
01:00000BDC 193A80E0        	  1359: 	bne %cr0,.0002
01:00000BE0 3908A002        	  1360: 	stfd %f0,TCBxF0[%a0]
01:00000BE4 7908B002        	  1361: 	stfd %f1,TCBxF1[%a0]
01:00000BE8 B908C002        	  1362: 	stfd %f2,TCBxF2[%a0]
01:00000BEC F908D002        	  1363: 	stfd %f3,TCBxF3[%a0]
01:00000BF0 3909E002        	  1364: 	stfd %f4,TCBxF4[%a0]
01:00000BF4 7909F002        	  1365: 	stfd %f5,TCBxF5[%a0]
01:00000BF8 B9090003        	  1366: 	stfd %f6,TCBxF6[%a0]
01:00000BFC F9091003        	  1367: 	stfd %f7,TCBxF7[%a0]
01:00000C00 390A2003        	  1368: 	stfd %f8,TCBxF8[%a0]
01:00000C04 790A3003        	  1369: 	stfd %f9,TCBxF9[%a0]
01:00000C08 B90A4003        	  1370: 	stfd %f10,TCBxF10[%a0]
01:00000C0C F90A5003        	  1371: 	stfd %f11,TCBxF11[%a0]
01:00000C10 390B6003        	  1372: 	stfd %f12,TCBxF12[%a0]
01:00000C14 790B7003        	  1373: 	stfd %f13,TCBxF13[%a0]
01:00000C18 B90B8003        	  1374: 	stfd %f14,TCBxF14[%a0]
01:00000C1C F90B9003        	  1375: 	stfd %f15,TCBxF15[%a0]
01:00000C20 390CA003        	  1376: 	stfd %f16,TCBxF16[%a0]
01:00000C24 790CB003        	  1377: 	stfd %f17,TCBxF17[%a0]
01:00000C28 B90CC003        	  1378: 	stfd %f18,TCBxF18[%a0]
01:00000C2C F90CD003        	  1379: 	stfd %f19,TCBxF19[%a0]
01:00000C30 390DE003        	  1380: 	stfd %f20,TCBxF20[%a0]
01:00000C34 790DF003        	  1381: 	stfd %f21,TCBxF21[%a0]
01:00000C38 B90D0004        	  1382: 	stfd %f22,TCBxF22[%a0]
01:00000C3C F90D1004        	  1383: 	stfd %f23,TCBxF23[%a0]
01:00000C40 390E2004        	  1384: 	stfd %f24,TCBxF24[%a0]
01:00000C44 790E3004        	  1385: 	stfd %f25,TCBxF25[%a0]
01:00000C48 B90E4004        	  1386: 	stfd %f26,TCBxF26[%a0]
01:00000C4C F90E5004        	  1387: 	stfd %f27,TCBxF27[%a0]
01:00000C50 390F6004        	  1388: 	stfd %f28,TCBxF28[%a0]
01:00000C54 790F7004        	  1389: 	stfd %f29,TCBxF29[%a0]
01:00000C58 B90F8004        	  1390: 	stfd %f30,TCBxF30[%a0]
01:00000C5C F90F9004        	  1391: 	stfd %f31,TCBxF31[%a0]
                            	  1392: .0002:	
                            	  1393: 	# save stack pointers and branch registers
01:00000C60 8F001084        	  1394: 	movea %a1,%usp
01:00000C64 AE086002        	  1395: 	store %a1,TCBxUSP[%a0]
01:00000C68 8F081084        	  1396: 	movea %a1,%ssp
01:00000C6C AE087002        	  1397: 	store %a1,TCBxSSP[%a0]
01:00000C70 8F101084        	  1398: 	movea %a1,%hsp
01:00000C74 AE088002        	  1399: 	store %a1,TCBxHSP[%a0]
01:00000C78 870010E2        	  1400: 	csrrd %a1,EPC0
01:00000C7C AE08A004        	  1401: 	store %a1,TCBxPC[%a0]
01:00000C80 870000E1        	  1402: 	csrrd %a1,ESR0
01:00000C84 AE083005        	  1403: 	store %a1,TCBxSR[%a0]
                            	  1404: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1405: 	# Load the destination context
                            	  1406: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1407: 	# walk forwards loading registers
                            	  1408: 	macGetRunningTCBPointer
01:00000C88 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000C8C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000C90 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000C94 07080480        	  1409: 	csrrw %r0,TCBA,%a0			# update running TCB address
                            	  1410: 
                            	  1411: 	# load condition registers
01:00000C98 A6080800        	  1412: 	load %a1,TCBxCR0[%a0]
01:00000C9C 0F140480        	  1413: 	move %cr0,%a1
01:00000CA0 A6080A00        	  1414: 	load %a1,TCBxCR1[%a0]
01:00000CA4 4F140480        	  1415: 	move %cr1,%a1
01:00000CA8 A6080C00        	  1416: 	load %a1,TCBxCR2[%a0]
01:00000CAC 8F140480        	  1417: 	move %cr2,%a1
01:00000CB0 A6080E00        	  1418: 	load %a1,TCBxCR3[%a0]
01:00000CB4 CF1404802800F8FF	  1419: 	move %cr3,%a1
01:00000CBC 45233100
01:00000CC0 A6081000        	  1420: 	load %a1,TCBxCR4[%a0]
01:00000CC4 0F150480        	  1421: 	move %cr4,%a1
01:00000CC8 A6081200        	  1422: 	load %a1,TCBxCR5[%a0]
01:00000CCC 4F150480        	  1423: 	move %cr5,%a1
01:00000CD0 A6081400        	  1424: 	load %a1,TCBxCR6[%a0]
01:00000CD4 8F150480        	  1425: 	move %cr6,%a1
01:00000CD8 A6081600        	  1426: 	load %a1,TCBxCR7[%a0]
01:00000CDC CF150480        	  1427: 	move %cr7,%a1
                            	  1428: 	# load branch registers
01:00000CE0 A6082000        	  1429: 	load %a1,TCBxBR1[%a0]
01:00000CE4 4F120480        	  1430: 	move %br1,%a1
01:00000CE8 A6083000        	  1431: 	load %a1,TCBxBR2[%a0]
01:00000CEC 8F120480        	  1432: 	move %br2,%a1
01:00000CF0 A6084000        	  1433: 	load %a1,TCBxBR3[%a0]
01:00000CF4 CF120480        	  1434: 	move %br3,%a1
01:00000CF8 A6085000        	  1435: 	load %a1,TCBxBR4[%a0]
01:00000CFC 0F130480        	  1436: 	move %br4,%a1
01:00000D00 A6086000        	  1437: 	load %a1,TCBxBR5[%a0]
01:00000D04 4F130480        	  1438: 	move %br5,%a1
01:00000D08 A6087000        	  1439: 	load %a1,TCBxBR6[%a0]
01:00000D0C 8F130480        	  1440: 	move %br6,%a1
                            	  1441: 	# load loop counter
01:00000D10 A6089002        	  1442: 	load %a1,TCBxLC[%a0]
01:00000D14 0F160480        	  1443: 	move %lc,%a1
                            	  1444: 	# excaption handler address
01:00000D18 A608B004        	  1445: 	load %a1,TCBxXH[%a0]
01:00000D1C 0F170480        	  1446: 	move %xh,%a1
                            	  1447: 	# Load GPRs
01:00000D20 E608A000        	  1448: 	load %a2,TCBxA2[%a0]
01:00000D24 2609B000        	  1449: 	load %a3,TCBxA3[%a0]
01:00000D28 6609C000        	  1450: 	load %a4,TCBxA4[%a0]
01:00000D2C A609D000        	  1451: 	load %a5,TCBxA5[%a0]
01:00000D30 E609E000        	  1452: 	load %a6,TCBxA6[%a0]
01:00000D34 260AF000        	  1453: 	load %a7,TCBxA7[%a0]
01:00000D38 660A0001        	  1454: 	load %t0,TCBxT0[%a0]
01:00000D3C A60A1001        	  1455: 	load %t1,TCBxT1[%a0]
01:00000D40 E60A2001        	  1456: 	load %t2,TCBxT2[%a0]
01:00000D44 260B3001        	  1457: 	load %t3,TCBxT3[%a0]
01:00000D48 660B4001        	  1458: 	load %t4,TCBxT4[%a0]
01:00000D4C A60B5001        	  1459: 	load %t5,TCBxT5[%a0]
01:00000D50 E60B6001        	  1460: 	load %t6,TCBxT6[%a0]
01:00000D54 260C7001        	  1461: 	load %t7,TCBxT7[%a0]
01:00000D58 660C8001        	  1462: 	load %t8,TCBxT8[%a0]
01:00000D5C A60C9001        	  1463: 	load %t9,TCBxT9[%a0]
01:00000D60 E60CA001        	  1464: 	load %s0,TCBxS0[%a0]
01:00000D64 260DB001        	  1465: 	load %s1,TCBxS1[%a0]
01:00000D68 660DC001        	  1466: 	load %s2,TCBxS2[%a0]
01:00000D6C A60DD001        	  1467: 	load %s3,TCBxS3[%a0]
01:00000D70 E60DE001        	  1468: 	load %s4,TCBxS4[%a0]
01:00000D74 260EF001        	  1469: 	load %s5,TCBxS5[%a0]
01:00000D78 660E0002        	  1470: 	load %s6,TCBxS6[%a0]
01:00000D7C A60E1002        	  1471: 	load %s7,TCBxS7[%a0]
01:00000D80 E60E2002        	  1472: 	load %s8,TCBxS8[%a0]
01:00000D84 260F3002        	  1473: 	load %s9,TCBxS9[%a0]
01:00000D88 660F4002        	  1474: 	load %gp,TCBxGP[%a0]
01:00000D8C A60F5002        	  1475: 	load %fp,TCBxFP[%a0]
                            	  1476: 	# check to see if FPRs need to be saved
01:00000D90 A6084005        	  1477: 	load %a1,TCBxFPSR[%a0]
01:00000D94 07102880        	  1478: 	csrrw %r0,FPSR,%a1
01:00000D98 82100FE0        	  1479: 	ext. %a1,%a1,FPStateBegin,FPStateEnd
01:00000D9C D93940E1        	  1480: 	beq %cr0,.0003
01:00000DA0 3108A002        	  1481: 	ldfd %f0,TCBxF0[%a0]
01:00000DA4 7108B002        	  1482: 	ldfd %f1,TCBxF1[%a0]
01:00000DA8 B108C002        	  1483: 	ldfd %f2,TCBxF2[%a0]
01:00000DAC F108D002        	  1484: 	ldfd %f3,TCBxF3[%a0]
01:00000DB0 3109E002        	  1485: 	ldfd %f4,TCBxF4[%a0]
01:00000DB4 7109F002        	  1486: 	ldfd %f5,TCBxF5[%a0]
01:00000DB8 B1090003        	  1487: 	ldfd %f6,TCBxF6[%a0]
01:00000DBC F1091003        	  1488: 	ldfd %f7,TCBxF7[%a0]
01:00000DC0 310A2003        	  1489: 	ldfd %f8,TCBxF8[%a0]
01:00000DC4 710A3003        	  1490: 	ldfd %f9,TCBxF9[%a0]
01:00000DC8 B10A4003        	  1491: 	ldfd %f10,TCBxF10[%a0]
01:00000DCC F10A5003        	  1492: 	ldfd %f11,TCBxF11[%a0]
01:00000DD0 310B6003        	  1493: 	ldfd %f12,TCBxF12[%a0]
01:00000DD4 710B7003        	  1494: 	ldfd %f13,TCBxF13[%a0]
01:00000DD8 B10B8003        	  1495: 	ldfd %f14,TCBxF14[%a0]
01:00000DDC F10B9003        	  1496: 	ldfd %f15,TCBxF15[%a0]
01:00000DE0 310CA003        	  1497: 	ldfd %f16,TCBxF16[%a0]
01:00000DE4 710CB003        	  1498: 	ldfd %f17,TCBxF17[%a0]
01:00000DE8 B10CC003        	  1499: 	ldfd %f18,TCBxF18[%a0]
01:00000DEC F10CD003        	  1500: 	ldfd %f19,TCBxF19[%a0]
01:00000DF0 310DE003        	  1501: 	ldfd %f20,TCBxF20[%a0]
01:00000DF4 710DF003        	  1502: 	ldfd %f21,TCBxF21[%a0]
01:00000DF8 B10D0004        	  1503: 	ldfd %f22,TCBxF22[%a0]
01:00000DFC F10D1004        	  1504: 	ldfd %f23,TCBxF23[%a0]
01:00000E00 310E2004        	  1505: 	ldfd %f24,TCBxF24[%a0]
01:00000E04 710E3004        	  1506: 	ldfd %f25,TCBxF25[%a0]
01:00000E08 B10E4004        	  1507: 	ldfd %f26,TCBxF26[%a0]
01:00000E0C F10E5004        	  1508: 	ldfd %f27,TCBxF27[%a0]
01:00000E10 310F6004        	  1509: 	ldfd %f28,TCBxF28[%a0]
01:00000E14 710F7004        	  1510: 	ldfd %f29,TCBxF29[%a0]
01:00000E18 B10F8004        	  1511: 	ldfd %f30,TCBxF30[%a0]
01:00000E1C F10F9004        	  1512: 	ldfd %f31,TCBxF31[%a0]
                            	  1513: .0003:	
                            	  1514: 	# load stack pointers
01:00000E20 A6086002        	  1515: 	load %a1,TCBxUSP[%a0]
01:00000E24 0F100484        	  1516: 	movea %usp,%a1
01:00000E28 A6087002        	  1517: 	load %a1,TCBxSSP[%a0]
01:00000E2C 4F100484        	  1518: 	movea %ssp,%a1
01:00000E30 A6088002        	  1519: 	load %a1,TCBxHSP[%a0]
01:00000E34 8F100484        	  1520: 	movea %hsp,%a1
01:00000E38 A6083005        	  1521: 	load %a1,TCBxSR[%a0]
01:00000E3C 071000E1        	  1522: 	csrrw %r0,ESR0,%a1
01:00000E40 A608A004        	  1523: 	load %a1,TCBxPC[%a0]
01:00000E44 071010E2        	  1524: 	csrrw %r0,EPC0,%a1
01:00000E48 A6089000        	  1525: 	load %a1,TCBxA1[%a0]
01:00000E4C 66088000        	  1526: 	load %a0,TCBxA0[%a0]
01:00000E50 F800FE84        	  1527: 	atom 63,3
01:00000E54 07001A60        	  1528: 	csrrci %r0,M_SEMA,InTimerISRFlag
01:00000E58 13000004        	  1529: 	rfi
                            	  1530: 
                            	  1531: 
                            	  1532: #------------------------------------------------------------------------------
                            	  1533: # Put the current task to sleep.
                            	  1534: # If the timeout is zero or less then it is assumed the task is giving up it's
                            	  1535: # time slice, so the timer ISR is forced to run to switch contexts. The task is
                            	  1536: # not put to sleep, but placed back in priority queue.
                            	  1537: # If the timeout is positive then a SLEEP request is setup for the timer ISR
                            	  1538: # and the timer ISR forced to run.
                            	  1539: #
                            	  1540: #	Parameters
                            	  1541: #		%a1 = number of ticks
                            	  1542: #		%a2 = pointer to place to put return value in
                            	  1543: # Returns:
                            	  1544: #		a0 = E_Ok after the sleep interval.
                            	  1545: #------------------------------------------------------------------------------
                            	  1546: 
                            	  1547: FMTK_Sleep:
01:00000E5C 03100080        	  1548:   cmpi %cr0,%a1,0						# sleep for <=0?
01:00000E60 983848E1        	  1549:   ble %cr0,.0003						# giving up time slice?
                            	  1550:   macGetRunningTCBPointer
01:00000E64 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000E68 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000E6C 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000E70 AE08D006        	  1551:   store %a1,TCBTsCmdParm[%a0]	# setup sleep command request
01:00000E74 040106802800F8FF	  1552:   loadi %a3,TSC_SLEEP
01:00000E7C 45233100
01:00000E80 2809B006        	  1553:   stb %a3,TCBTsCmd[%a0]
01:00000E84 CD8DFEFF        	  1554: 	bli FemtikiTimerISR				# Force Timer IRQ processing
01:00000E88 03180080        	  1555:   cmpi %cr0,%a2,0						# we allow null here, maybe no return value needed
01:00000E8C D93640E1        	  1556:   beq %cr0,.0002
01:00000E90 6608C006        	  1557:   load %a0,TCBTsResp[%a0]		# response should have been updated by timer IRQ
01:00000E94 8F180080        	  1558:   move %a1,%a2
                            	  1559:   macStorePM
01:00000E98 1E020040        	     1M   push %a2
01:00000E9C C70008E0        	     2M 	csrrci %a2,M_SR,0x1C0000	# clear MPRV
01:00000EA0 07000CE0        	     3M 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00000EA4 33000058        	     4M   sync
01:00000EA8 6E100000        	     5M 	store %a0,[%a1]						# do the store to the proper address space
01:00000EAC 071808E0        	     6M 	csrrw %r0,M_SR,%a2				# restore SR settings
01:00000EB0 33000058        	     7M   sync
01:00000EB4 1F02004000001C00	     8M   pop %a2
01:00000EBC 00001800
                            	  1560: .0002:
01:00000EC0 44000080        	  1561:   loadi %a0,E_Ok
01:00000EC4 1A1EFDFF        	  1562: 	b EnvExitLight
                            	  1563: .0003:
01:00000EC8 CD7BFEFF        	  1564: 	bli FemtikiTimerISR			# Force Timer IRQ processing
01:00000ECC 44000080        	  1565:   loadi %a0,E_Ok
01:00000ED0 1B1AFDFF        	  1566: 	b EnvExitLight
                            	  1567: 
                            	  1568: # ----------------------------------------------------------------------------
                            	  1569: # Select a task to run. Relatively easy as task selection is handled by
                            	  1570: # hardware. All that needs to be done is to keep popping the hardware queue
                            	  1571: # until a valid running task is found.
                            	  1572: # This function also takes care of servicing requests from other OS code.
                            	  1573: #
                            	  1574: # Side Effects:
                            	  1575: #		The ready queue is popped
                            	  1576: #		The TCB list may be modified if a command is present
                            	  1577: # Modifies:
                            	  1578: #		none
                            	  1579: # Retuns:
                            	  1580: #		a0 = next task to run
                            	  1581: #; ----------------------------------------------------------------------------
                            	  1582: 
                            	  1583: SelectTaskToRun:
01:00000ED4 1E000448        	  1584: 	push %br1
01:00000ED8 1E030040        	  1585: 	push %a1-%a3				# push %a1,%a2,%a3
                            	  1586: 	# There should always be at least one task in the ready queue. It should
                            	  1587: 	# be guarenteed to be popped within 32 tries (the number of attempts for
                            	  1588: 	# all queues to be tested). The following limit is in case something is
                            	  1589: 	# broken.
                            	  1590: .0004:
01:00000EDC 44000081        	  1591: 	loadi %a0,128
                            	  1592: .0001:							#	keep popping tasks from the readyQ until a valid one
01:00000EE0 4408FEFF        	  1593: 	addi. %a0,%a0,-1		# is found. If none valid for a long time default to
01:00000EE4 D93A40E1        	  1594: 	beq	%cr0,.0002			# the OS task
01:00000EE8 A6000004        	  1595: 	load. %a1,RDYQ
01:00000EEC D93440E1        	  1596: 	beq %cr0,.0001
                            	  1597: 	# Here we got a valid task id. If the task is still supposed to be
                            	  1598: 	# running, push it back onto the ready queue. Otherwise go get the
                            	  1599: 	# next task.
01:00000EF0 4F100080        	  1600: 	move %a0,%a1
01:00000EF4 0F110080        	  1601: 	move %a3,%a1				# save this
                            	  1602: 	# Check for commands, if successful clear the command otherwise it will be
                            	  1603: 	# done more than once.
01:00000EF8 4408B086        	  1604: 	addi %a0,%a0,TCBTsCmd
01:00000EFC BB08C186        	  1605: 	amoswapb. %a1,%r0,[%a0]	# clear command
01:00000F00 440850F9        	  1606: 	addi %a0,%a0,-TCBTsCmd
01:00000F04 D93840E1        	  1607: 	beq %cr0,.0007
01:00000F08 03100480        	  1608: 	cmpi %cr0,%a1,TSC_FREETCB	# was the TCB "freed"	
01:00000F0C F93540E1        	  1609: 	pne %cr0,.0005						# should use a predicate here
01:00000F10 5B900080        	  1610: 	bl IFreeTCB
01:00000F14 1BC2FFFF        	  1611: 	b .0007
                            	  1612: .0005:
01:00000F18 03100280        	  1613: 	cmpi %cr0,%a1,TSC_ALLOCTCB
01:00000F1C F83640E1        	  1614: 	pne %cr0,.0003
01:00000F20 8F080080        	  1615: 	move %a1,%a0
01:00000F24 5A840080        	  1616: 	bl IAllocTCB
01:00000F28 F83540E1        	  1617: 	pne %cr0,.0006
01:00000F2C 2810B206        	  1618: 	stbi TSC_ALLOCTCB,TCBTsCmd[%a1]			# repeat command if not successful
                            	  1619: .0006:
01:00000F30 6E10C006        	  1620: 	store %a0,TCBTsResp[%a1]
01:00000F34 4F100080        	  1621: 	move %a0,%a1
01:00000F38 1ABAFFFF        	  1622: 	b .0007
                            	  1623: .0003:
01:00000F3C 03100680        	  1624: 	cmpi %cr0,%a1,TSC_SLEEP
01:00000F40 183780E0        	  1625: 	bne %cr0,.0007
01:00000F44 03100080        	  1626: 	cmpi %cr0,%a1,0
01:00000F48 F93688E0        	  1627: 	ple %cr0,.0008
01:00000F4C CF080080        	  1628: 	move %a2,%a0
01:00000F50 A608D006        	  1629: 	load %a1,TCBTsCmdParm[%a0]		# %a1 = timeout
01:00000F54 660000A0        	  1630: 	load %a0,RunningID						# a0 = running TID
                            	  1631: 	macTCBHandleToPointer
01:00000F58 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000F5C 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000F60 5B960080        	  1632: 	bl RemoveFromReadyQueue
01:00000F64 5A000080        	  1633: 	bl InsertIntoTimeoutList
01:00000F68 8F180080        	  1634: 	move %a1,%a2
                            	  1635: .0008:
01:00000F6C 44000280        	  1636: 	loadi %a0,1
01:00000F70 6E1004003F000000	  1637: 	store %a0,TCBRsResp[%a1]
01:00000F78 2800F8FF45233100
01:00000F80 4F100080        	  1638: 	move %a0,%a1 	
                            	  1639: .0007:
01:00000F84 A1087805        	  1640: 	ldbz %a1,TCBStatus[%a0]
01:00000F88 08100085        	  1641: 	andi. %r0,%a1,TS_RUNNING
01:00000F8C D82F80E0        	  1642: 	bne	%cr0,.0004
01:00000F90 4F200080        	  1643: 	move %a0,%a3									# we want the id here
01:00000F94 5B7E0080        	  1644: 	bl InsertIntoReadyQueue
01:00000F98 1F030040        	  1645: 	pop %a1-%a3
01:00000F9C 1F000448        	  1646: 	pop %br1
01:00000FA0 1A000024        	  1647: 	blr
                            	  1648: 	# Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	  1649: .0002:
01:00000FA4 44000280        	  1650: 	loadi %a0,1
01:00000FA8 5A7A0080        	  1651: 	bl InsertIntoReadyQueue
01:00000FAC 1F030040        	  1652: 	pop %a1-%a3
01:00000FB0 1F000448        	  1653: 	pop %br1
01:00000FB4 1A000024        	  1654: 	blr
                            	  1655: 
                            	  1656: #// ----------------------------------------------------------------------------
                            	  1657: #// Sleep for a number of clock ticks.
                            	  1658: #// ----------------------------------------------------------------------------
                            	  1659: #
                            	  1660: #int FMTK_Sleep(int timeout)
                            	  1661: #{
                            	  1662: #  hTCB ht;
                            	  1663: #  int tick1, tick2;
                            	  1664: #
                            	  1665: #	while (timeout > 0) {
                            	  1666: #		tick1 = GetTick();
                            	  1667: #    if (LockSysSemaphore(100000)) {
                            	  1668: #      ht = GetRunningTCB();
                            	  1669: #      RemoveFromReadyList(ht);
                            	  1670: #      InsertIntoTimeoutList(ht, timeout);
                            	  1671: #      macUnlockSysSemaphore();
                            	  1672: #			FMTK_Reschedule();
                            	  1673: #      break;
                            	  1674: #    }
                            	  1675: #		else {
                            	  1676: #			tick2 = GetTick();
                            	  1677: #			timeout -= (tick2-tick1);
                            	  1678: #		}
                            	  1679: #;	}
                            	  1680: #  return (E_Ok);
                            	  1681: #}
                            	  1682: 
                            	  1683: #------------------------------------------------------------------------------
                            	  1684: # Start a task.
                            	  1685: #
                            	  1686: # Side Effects:
                            	  1687: #		Triggers the timer ISR to get a TCB from the free list.
                            	  1688: #		The ACB semaphore is briefly locked.
                            	  1689: #
                            	  1690: # Parameters:
                            	  1691: #		%a1 = app id
                            	  1692: #		%a2 = priority
                            	  1693: #		%a3 = start address
                            	  1694: #		%a4 = start parameter
                            	  1695: #		%a5 = affinity
                            	  1696: #		%a6 = place to put task id
                            	  1697: # Returns:
                            	  1698: #		a0 = E_Ok, E_NoMoreTCBs or E_NoMem
                            	  1699: #		in [%a6] task id
                            	  1700: #------------------------------------------------------------------------------
                            	  1701: 
                            	  1702: FMTK_StartTask:
01:00000FB8 1E000448        	  1703: 	push %br1
01:00000FBC 660200A0        	  1704: 	load %t0,RunningID
                            	  1705: 	macGetRunningTCBPointer
01:00000FC0 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000FC4 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000FC8 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000FCC 0F0A0080        	  1706: 	move %a7,%a0
01:00000FD0 2840B206        	  1707: 	stbi TSC_ALLOCTCB,TCBTsCmd[%a7]	# request a TCB from the scheduler
01:00000FD4 CD39FEFF        	  1708: 	bli FemtikiTimerISR
01:00000FD8 6640C006        	  1709: 	load. %a0,TCBTsResp[%a7]
01:00000FDC 2E40C006        	  1710: 	store %r0,TCBTsResp[%a7]
01:00000FE0 8F0A0080        	  1711: 	move %t1,%a0								# %t1 = handle for new task
01:00000FE4 03080080        	  1712: 	cmpi %cr0,%a0,0
01:00000FE8 593940E1        	  1713: 	beq	%cr0,.0002
01:00000FEC B4085806        	  1714: 	stptr %a1,TCBappid[%a0]
01:00000FF0 E8087A05        	  1715: 	stb %a2,TCBPriority[%a0]
01:00000FF4 AA0928062800F8FF	  1716: 	stw %a5,TCBAffinity[%a0]		# todo check size
01:00000FFC 45233100
01:00001000 2E0830A7        	  1717: 	storei 16777216,TCBbrk[%a0]	# initialize the memory break virtual address
                            	  1718: .0005:
01:00001004 4400FEFF        	  1719: 	loadi %a0,-1
01:00001008 5A70FCFF        	  1720: 	bl LockACBSemaphore
01:0000100C 593440E1        	  1721: 		beq %cr0,.0005
01:00001010 4F100080        	  1722: 		move %a0,%a1
                            	  1723: 		macACBHandleToPointer
01:00001014 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00001018 42081C80        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:0000101C A6088007        	  1724: 		load %a1,ACBTaskList[%a0]
01:00001020 B440A006        	  1725: 		stptr %a1,TCBAcbNext[%a7]
01:00001024 740A8007        	  1726: 		stptr %t0,ACBTaskList[%a0]
                            	  1727: 	macUnlockACBSemaphore
01:00001028 2E000400        	     1M 	store %r0,ACBSEMA
01:0000102C 6E418000        	  1728: 	store %a4,TCBxA0[%a7]				# place start parameter in a0 register
01:00001030 440004803F000000	  1729: 	loadi %a0,MF_IncreaseStackSize
01:00001038 0000000145233100
01:00001040 7C000080        	  1730: 	ecall MF
01:00001044 03080080        	  1731: 	cmpi %cr0,%a0,0
01:00001048 D83640E1        	  1732: 	beq %cr0,.0003
01:0000104C 44080080        	  1733: 	addi %a0,%a0,PGSZ
                            	  1734: #	addd	#PGSZ
01:00001050 74400000        	  1735: 	stptr %a0,TCBxSP[%a7]
01:00001054 3441A004        	  1736: 	stptr %a3,TCBxPC[%a7]				# set start address
01:00001058 4F500080        	  1737: 	move %a0,%t1
01:0000105C 5B4C0080        	  1738: 	bl InsertIntoReadyQueue
01:00001060 03380080        	  1739: 	cmpi %cr0,%a6,0
01:00001064 F93580E0        	  1740:   peq %cr0,.0004						# we allow a null pointer here
01:00001068 470008E0        	  1741: 	csrrci %a0,M_SR,0x1C0000	# clear MPRV
01:0000106C 07000CE0        	  1742: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001070 33000058        	  1743:   sync
01:00001074 AE0A000000001C00	  1744: 	store %t1,[%a0]						# do the store to the proper address space
01:0000107C 00001800
01:00001080 070808E0        	  1745: 	csrrw %r0,M_SR,%a0				# restore SR settings
01:00001084 33000058        	  1746:   sync
                            	  1747: .0004:
01:00001088 1F000448        	  1748: 	pop %br1
01:0000108C 44000080        	  1749: 	loadi %a0,E_Ok
01:00001090 1A000024        	  1750: 	blr
                            	  1751: .0002:
01:00001094 1F000448        	  1752: 	pop %br1
01:00001098 44005A80        	  1753: 	loadi %a0,E_NoMoreTCBs	
01:0000109C 1A000024        	  1754: 	blr
                            	  1755: .0003:
01:000010A0 1F000448        	  1756: 	pop %br1
01:000010A4 44005C80        	  1757: 	loadi %a0,E_NoMem
01:000010A8 1A000024        	  1758: 	blr
                            	  1759: 
                            	  1760: #------------------------------------------------------------------------------
                            	  1761: #------------------------------------------------------------------------------
                            	  1762: 
                            	  1763: #------------------------------------------------------------------------------
                            	  1764: # Exit the current task. (remains to be done)
                            	  1765: #
                            	  1766: # Parameters:
                            	  1767: #		none
                            	  1768: # Modifies:
                            	  1769: #		%a1 = task id
                            	  1770: #------------------------------------------------------------------------------
                            	  1771: 
                            	  1772: FMTK_ExitTask:
01:000010AC 660000A0        	  1773: 	load %a0,RunningID
                            	  1774: 	# fall through to KillTask
                            	  1775: 	
                            	  1776: #------------------------------------------------------------------------------
                            	  1777: # Parameters:
                            	  1778: #		B = tid of task to kill
                            	  1779: #------------------------------------------------------------------------------
                            	  1780: 
                            	  1781: #------------------------------------------------------------------------------
                            	  1782: # ToDo: finish this routine
                            	  1783: #------------------------------------------------------------------------------
                            	  1784: 
                            	  1785: FMTK_KillTask:
01:000010B0 8F4A1480        	  1786: 	move %br2,%br1
                            	  1787: .0001:
01:000010B4 4400FEFF        	  1788: 	loadi %a0,-1
01:000010B8 5A36FCFF2800F8FF	  1789: 	bl LockSysSemaphore
01:000010C0 993340E1        	  1790: 	beq %cr0,.0001
                            	  1791: 	macGetRunningTCBPointer
01:000010C4 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:000010C8 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:000010CC 42081480        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:000010D0 4F100080        	  1792: 	move %a0,%a1
01:000010D4 5A3A0080        	  1793: 	bl RemoveFromReadyQueue
01:000010D8 5A400080        	  1794: 	bl RemoveFromTimeoutList
01:000010DC E308E006        	  1795: 	ldwz %a2,TCBhMailboxes[%a0]
01:000010E0 5A000080        	  1796: 	bl IFreeMBX
01:000010E4 E308E406        	  1797: 	ldwz %a2,TCBhMailboxes+2[%a0]
01:000010E8 5A000080        	  1798: 	bl IFreeMBX
01:000010EC E308E806        	  1799: 	ldwz %a2,TCBhMailboxes+4[%a0]
01:000010F0 5A000080        	  1800: 	bl IFreeMBX
01:000010F4 E308EC062800F8FF	  1801: 	ldwz %a2,TCBhMailboxes+6[%a0]
01:000010FC 45233100
01:00001100 5A000080        	  1802: 	bl IFreeMBX
                            	  1803: 	# Remove from list of tasks ACB has
01:00001104 66085806        	  1804: 	load %a0,TCBappid[%a0]
01:00001108 E6088007        	  1805: 	load %a2,ACBTaskList[%a0]
                            	  1806: 
                            	  1807: 	# Mark the TCB as free, it will be freed by SelectTaskToRun
                            	  1808: #	atom 63,"MMM"
                            	  1809: #	ldbz %a2,TCBStatus[]
                            	  1810: #	or %a2,%a2,TS_FREE
                            	  1811: #	stb %a2,TCBStatus[]
                            	  1812: 		
                            	  1813: #	cmpe	TCBxAccb,x
                            	  1814: #	beq		0002f
                            	  1815: #	tfr		e,b
                            	  1816: #	clra
                            	  1817: #	lbsr	macTCBHandleToPointer
                            	  1818: #	tfr		d,u
                            	  1819: #	ldf		TCBAcbNext,u
                            	  1820: #	cmpf	TCBxAccb,x
                            	  1821: #	beq		0003f
                            	  1822: 	
                            	  1823: 	
                            	  1824: #------------------------------------------------------------------------------
                            	  1825: # Link each message to the next in the free list.
                            	  1826: #------------------------------------------------------------------------------
                            	  1827: 
                            	  1828: InitFreeMessageList:
01:0000110C 440000A0        	  1829: 	loadi %a0,messages
01:00001110 740004A0        	  1830: 	stptr %a0,FreeMSG			# set start of free message list to first message
01:00001114 840000A0        	  1831: 	loadi %a1,messages	#+OBJ_SIZE
01:00001118 44083880        	  1832: 	addi %a0,%a0,MSG_SIZE
                            	  1833: .0003:
01:0000111C 74100400        	  1834: 	stptr %a0,MSG_LINK[%a1]	# update link
01:00001120 44083880        	  1835: 	addi %a0,%a0,MSG_SIZE
01:00001124 84103880        	  1836: 	addi %a1,%a1,MSG_SIZE		# increment to next message
01:00001128 031208A0        	  1837: 	cmpai %cr0,%a1,messages_end	# done all messages?
01:0000112C 193346E1        	  1838: 	blt %cr0,.0003
01:00001130 8410C8FF00405800	  1839: 	subi %a1,%a1,MSG_SIZE		# backup
01:00001138 CC00F8FF00406800
01:00001140 34100000        	  1840: 	stptr %r0,MSG_LINK[%a1]	# update last link to null
01:00001144 1A000024        	  1841: 	blr
                            	  1842: 
                            	  1843: #------------------------------------------------------------------------------
                            	  1844: # Link each mailbox to the next in the free list.
                            	  1845: #------------------------------------------------------------------------------
                            	  1846: 
                            	  1847: InitFreeMailboxList:
01:00001148 440000A0        	  1848: 	loadi %a0,mailboxes
01:0000114C 740004A0        	  1849: 	stptr %a0,FreeMBX			# set start of free mailbox list to first mailbox
01:00001150 840000A0        	  1850: 	loadi %a1,mailboxes	#+OBJ_SIZE
01:00001154 44080280        	  1851: 	addi %a0,%a0,1
                            	  1852: .0003:
01:00001158 6E100400        	  1853: 	store %a0,MBX_LINK[%a1]	# update link
01:0000115C 44085880        	  1854: 	addi %a0,%a0,MBX_SIZE
01:00001160 84105880        	  1855: 	addi %a1,%a1,MBX_SIZE		# increment to next mailbox
01:00001164 031208A0        	  1856: 	cmpai %cr0,%a1,mailboxes_end		# done all mailboxes?
01:00001168 D83246E1        	  1857: 	blt %cr0,.0003
01:0000116C 8410A8FF        	  1858: 	subi %a1,%a1,MBX_SIZE		# backup
01:00001170 3410060000406800	  1859: 	stptr %r0,MBX_LINK[%a1]	# update last link to null
01:00001178 D000F8FF00406E00
01:00001180 1A000024        	  1860: 	blr
                            	  1861: 
                            	  1862: #------------------------------------------------------------------------------
                            	  1863: # Link each TCB to the next in the free list.
                            	  1864: #------------------------------------------------------------------------------
                            	  1865: 
                            	  1866: InitFreeTCBList:
01:00001184 440000A0        	  1867: 	loadi %a0,tcbs
01:00001188 8F080080        	  1868: 	move %a1,%a0
01:0000118C 740004A0        	  1869: 	stptr	%a0,FreeTCB
01:00001190 1A9AFFFF        	  1870: 	b .0002
                            	  1871: .0001:
01:00001194 74100400        	  1872: 	stptr %a0,TBCNext[%a1]
01:00001198 84100088        	  1873: 	addi %a1,%a1,TCB_SIZE
                            	  1874: .0002:
01:0000119C 44100088        	  1875: 	addi %a0,%a1,TCB_SIZE
01:000011A0 03120480        	  1876: 	cmpai %cr0,%a1,tcb_ends		# end of TCB array?
01:000011A4 593246E1        	  1877: 	blt %cr0,.0001
01:000011A8 841000F8        	  1878: 	subi %a1,%a1,TCB_SIZE			# zero out the last link
01:000011AC 341004003F000000	  1879: 	stptr %r0,TBCNext[%a1]
01:000011B4 3F00000000401800
01:000011BC C800F8FF
01:000011C0 1A000024        	  1880: 	blr
                            	  1881: 
                            	  1882: #------------------------------------------------------------------------------
                            	  1883: # Initialize Femtiki
                            	  1884: #------------------------------------------------------------------------------
                            	  1885: 
                            	  1886: FMTK_Init:
01:000011C4 8F4A1480        	  1887: 	move %br2,%br1
                            	  1888: 	# Clear out variable area
01:000011C8 840000A0        	  1889: 	loadi %a1,FemtikiVars
                            	  1890: .0001:
01:000011CC 2E100000        	  1891: 	store %r0,[%a1]
01:000011D0 84100800        	  1892: 	add %a1,%a1,4
01:000011D4 03122800        	  1893: 	cmpa %cr0,%a1,FemtikiVars_end
01:000011D8 183246E1        	  1894: 	blt %cr0,.0001
01:000011DC 44000280        	  1895: 	loadi %a0,1
01:000011E0 6E0004A0        	  1896: 	store %a0,OSActive
01:000011E4 440008A0        	  1897: 	loadi %a0,acbs
                            	  1898: 	macACBPointerToHandle
01:000011E8 42081C82        	     1M 	srli %a0,%a0,LOG_ACBSZ
01:000011EC 4A080CA02000F8FF	     2M 	xori %a0,%a0,CB_XOR
01:000011F4 1001F8FF00401000
01:000011FC 45233100
01:00001200 6E0000A0        	  1899: 	store %a0,RunningAID
01:00001204 440004A0        	  1900: 	loadi %a0,tcbs
                            	  1901: 	macTCBPointerToHandle
01:00001208 42081482        	     1M 	srli %a0,%a0,LOG_TCBSZ
01:0000120C 4A0808A0        	     2M 	xori %a0,%a0,CB_XOR
01:00001210 6E000CA0        	  1902: 	store %a0,RunningID		# reset this
                            	  1903: 
                            	  1904: 	# Set stack bottoms for all the memory maps
01:00001214 84000080        	  1905: 	loadi %a1,0
01:00001218 44000880        	  1906: 	loadi %a0,MAXVPG
                            	  1907: .0003:
01:0000121C 6E1010A0        	  1908: 	store %a0,MidStackBottoms[%a1]
01:00001220 84100880        	  1909: 	addi %a1,%a1,4
01:00001224 03100081        	  1910: 	cmpi %cr0,%a1,32*4
01:00001228 983146E12400F8FF	  1911: 	blt %cr0,.0003
01:00001230 0040180045233100
01:00001238 2800F8FFAC00F8FF
                            	  1912: 
01:00001240 5A50FFFF        	  1913: 	bl InitFreeMessageList
01:00001244 5B5AFFFF        	  1914: 	bl InitFreeMailboxList
01:00001248 5A66FFFF        	  1915: 	bl InitFreeTCBList
                            	  1916: 
                            	  1917: 	# Set interrupt groups
                            	  1918: 	# there is only 1 CPU ATM
                            	  1919: 	
01:0000124C 44000480        	  1920: 	loadi %a0,2
01:00001250 840000A0        	  1921: 	loadi %a1,0xFEE20800
                            	  1922: .0002:
01:00001254 6E100000        	  1923: 	store %a0,[%a1]
01:00001258 2E100800        	  1924: 	store %r0,4[%a1]
01:0000125C 84101080        	  1925: 	addi %a1,%a1,8
01:00001260 031204A0        	  1926: 	cmpai %cr0,%a1,0xFEE21000
01:00001264 D83056E1        	  1927: 	blt .0002
                            	  1928: 	
                            	  1929: 	# Set timer IRQ vector
                            	  1930: 
01:00001268 44000480        	  1931: 	loadi %a0,FemtikiTimerISR
01:0000126C 6E0008A0        	  1932: 	store %a0,0xFECC0000
01:00001270 2E000CA00008E2FE	  1933: 	store %r0,0xFECC0004
01:00001278 0010E2FE0000CCFE
01:00001280 2E0000A0        	  1934: 	store %r0,0xFECC0008
01:00001284 44000480        	  1935: 	loadi %a0,2								# enable interrupts,vector,swstk=0,CPU group #0
01:00001288 2E0004A0        	  1936: 	store %r0,0xFECC000C
                            	  1937: 
01:0000128C 5A8AFFFF        	  1938: 	bl InitAppOne
01:00001290 5A9CFFFF        	  1939: 	bl InitTaskOne
                            	  1940: 
                            	  1941: 	# Map ACB into virtual address space at $600000
                            	  1942: #	ldd		#$094F00
                            	  1943: #	std		MMU+$600
                            	  1944: #	inca
                            	  1945: #	std		MMU+$602
01:00001294 1A000028        	  1946: 	blr %br2
                            	  1947: 
                            	  1948: #------------------------------------------------------------------------------
                            	  1949: #------------------------------------------------------------------------------
                            	  1950: 
                            	  1951: InitAppOne:
01:00001298 440008A0        	  1952: 	loadi %a0,acbs
01:0000129C 84000080        	  1953: 	loadi %a1,0
                            	  1954: .0001:
01:000012A0 2E080480        	  1955: 	store %r0,[%a0+%a1*]
01:000012A4 84100880        	  1956: 	addi %a1,%a1,4
01:000012A8 03100CA0        	  1957: 	cmpi	%cr0,%a1,ACB_SIZE
01:000012AC 983046E10800CCFE	  1958: 	blt %cr0,.0001
01:000012B4 0C00CCFE00401000
01:000012BC 00400000
01:000012C0 840000A0        	  1959: 	loadi %a1,('A' << 16) | ('C' << 8) | 'B'
01:000012C4 AE080000        	  1960: 	store %a1,ACBObject+OBJMagic[%a0]
01:000012C8 2E089407        	  1961: 	store %r0,ACBmid[%a0]			# system uses map #0
01:000012CC 2E08A4A6        	  1962: 	storei 0xFEC00000,ACBpVidMem[%a0]
01:000012D0 2808C206        	  1963: 	stbi	64,ACBVideoCols[%a0]
01:000012D4 2808C006        	  1964: 	stbi	32,ACBVideoRows[%a0]
01:000012D8 2808C606        	  1965: 	stb 	%r0,ACBCursorCol[%a0]
01:000012DC 2808C406        	  1966: 	stb		%r0,ACBCursorRow[%a0]
01:000012E0 2E08DC07        	  1967: 	storei	0xCE,ACBNormAttr[%a0]
01:000012E4 84000280        	  1968: 	loadi %a1,1
01:000012E8 A8089007        	  1969: 	stb		%a1,ACBHasFocus[%a0]
01:000012EC A8088007        	  1970: 	stb		%a1,ACBTaskList[%a0]
01:000012F0 1A000024        	  1971: 	blr
                            	  1972: 
                            	  1973: #------------------------------------------------------------------------------
                            	  1974: # When called, the context for the task has already been stored in the TCB.
                            	  1975: # Do not zero out the TCB!
                            	  1976: #------------------------------------------------------------------------------
                            	  1977: 
                            	  1978: InitTaskOne:
01:000012F4 8F4A148042434100	  1979: 	move %br2,%br1
01:000012FC 0000C0FE
01:00001300 440000A0        	  1980: 	loadi %a0,tcbs
01:00001304 840004A0        	  1981: 	loadi %a1,acbs						# appid 1 is system app
01:00001308 B4085806        	  1982: 	stptr %a1,TCBappid[%a0]
01:0000130C 28088A05        	  1983: 	stbi	1,TCBHasFocus[%a0]
01:00001310 8F080080        	  1984: 	move %a1,%a0
01:00001314 74104806        	  1985: 	stptr	%a0,TCBtid[%a1]
01:00001318 74100806        	  1986: 	stptr	%a0,TCBNext[%a1]
01:0000131C 74101806        	  1987: 	stptr	%a0,TCBPrev[%a1]
01:00001320 28107805        	  1988: 	stbi TS_RUNNING,TCBStatus[%a1]
01:00001324 28107E05        	  1989: 	stbi 31,TCBPriority[%a1]
01:00001328 5A9AFFFF        	  1990: 	bl InsertIntoReadyQueue
01:0000132C 1A000028        	  1991: 	blr %br2
                            	  1992: 
                            	  1993: 
                            	  1994: .include "tcba.qpa"

Source: "tcba.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: #------------------------------------------------------------------------------
                            	    38: # IAllocTCB is called from the timer ISR. It must preserve any registers used.
                            	    39: #------------------------------------------------------------------------------
                            	    40: 
                            	    41: IAllocTCB:
01:00001330 1E010040        	    42: 	push %a1-%a2
01:00001334 660008A400401800	    43: 	load. %a0,FreeTCB
01:0000133C 00401000
01:00001340 F83080E0        	    44: 	peq	%cr0,.0001
01:00001344 A6080806        	    45: 	load %a1,TCBNext[%a0]
01:00001348 B40000A0        	    46: 	stptr	%a1,FreeTCB
                            	    47: .0001:
01:0000134C 1F010040        	    48: 	pop %a1-%a2
01:00001350 1A000024        	    49: 	blr
                            	    50: 
                            	    51: # Not called from anywhere
                            	    52: 
                            	    53: FMTK_AllocTCB:
01:00001354 1A000024        	    54: 	blr %br1
                            	    55: 	
                            	    56: #------------------------------------------------------------------------------
                            	    57: # IFreeTCB is called from SelectTaskToRun (timer ISR)
                            	    58: #
                            	    59: # Parameters:
                            	    60: #		a0 = pointer to TCB to insert
                            	    61: #------------------------------------------------------------------------------
                            	    62: 
                            	    63: IFreeTCB:
01:00001358 1E010040        	    64: 	push %a1-%a2
01:0000135C A60000A0        	    65: 	load %a1,FreeTCB
01:00001360 B4080806        	    66: 	stptr %a1,TCBNext[%a0]
01:00001364 740000A0        	    67: 	stptr	%a0,FreeTCB
01:00001368 1F010040        	    68: 	pop %a1-%a2
01:0000136C 1A000024        	    69: 	blr
                            	    70: 
                            	    71: #------------------------------------------------------------------------------
                            	    72: # FreeTCB does not actually free the TCB, instead it flags it as needed to be
                            	    73: # freed, and the scheduler frees it. It was done this way to avoid the need
                            	    74: # to lock the list with a semaphore which would cause a deadlock.
                            	    75: #
                            	    76: # Parameters:
                            	    77: #		a0 = task id to insert
                            	    78: #------------------------------------------------------------------------------
                            	    79: 
                            	    80: FMTK_FreeTCB:
                            	    81: 	macTCBHandleToPointer
01:00001370 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00001374 42081480C800F8FF	     2M 	slli %a0,%a0,LOG_TCBSZ
01:0000137C 45233100
01:00001380 03080000        	    82: 	cmp %cr0,%a0,0
01:00001384 F93088E0        	    83: 	ple %cr0,.0001
01:00001388 2808B006        	    84: 	stbi TSC_FREE,TCBTsCmd[%a0]
01:0000138C 44000080        	    85: 	loadi %a0,E_Ok
01:00001390 1A000024        	    86: 	blr
                            	    87: .0001:
01:00001394 44000E80        	    88: 	loadi %a0,E_NotAlloc
01:00001398 1BE8FBFF        	    89: 	b EnvExitLight
                            	    90: 
                            	    91: #------------------------------------------------------------------------------
                            	    92: # Push task into ready queue. The ready queue is a hardware component on the
                            	    93: # bus.
                            	    94: #
                            	    95: # Stack Space:
                            	    96: #		1 words
                            	    97: # Modifies:
                            	    98: #		none
                            	    99: # Parameters:
                            	   100: #		a0 = pointer to TCB to insert
                            	   101: #------------------------------------------------------------------------------
                            	   102: 
                            	   103: InsertIntoReadyQueue:
01:0000139C 03080080        	   104: 	cmpi %cr0,%a0,0
01:000013A0 F83088E0        	   105: 	ple %cr0,.0001
01:000013A4 A1087A05        	   106: 	ldbz %a1,TCBPriority[%a0]
01:000013A8 44010081        	   107: 	loadi %a4,TS_RUNNING
01:000013AC 44087885        	   108: 	addi %a0,%a0,TCBStatus
01:000013B0 3B280082        	   109: 	amoorb %r0,%a4,[%a0]
01:000013B4 440888FA        	   110: 	addi %a0,%a0,-TCBStatus
01:000013B8 88107E80        	   111: 	andi %a1,%a1,63							# safety, 0 to 63 for priority
01:000013BC 82100480        	   112: 	slli %a1,%a1,2
01:000013C0 6E100000        	   113: 	store %a0,RDYQ[%a1]
                            	   114: .0001:
01:000013C4 1A000024        	   115: 	blr
                            	   116: 
                            	   117: #------------------------------------------------------------------------------
                            	   118: # Remove task from ready queue. Accomplished by clearing the ready / running
                            	   119: # status. The next time the queue is popped, the task will be discarded as
                            	   120: # a choice for running.
                            	   121: #
                            	   122: # Parameters:
                            	   123: #		a0 = pointer to TCB to remove
                            	   124: #------------------------------------------------------------------------------
                            	   125: 
                            	   126: RemoveFromReadyQueue:
01:000013C8 03080080        	   127: 	cmpi %cr0,%a0,0							# sanity check
01:000013CC F83080E0        	   128: 	peq %cr0,.0001
01:000013D0 8400FCFE        	   129: 	loadi %a1,~(TS_RUNNING|TS_READY)
01:000013D4 44087885        	   130: 	addi %a0,%a0,TCBStatus
01:000013D8 3B180081        	   131: 	amoandb %r0,%a1,[%a0]
01:000013DC 440888FA        	   132: 	addi %a0,%a0,-TCBStatus
                            	   133: .0001:
01:000013E0 1A000024        	   134: 	blr
                            	   135: 	
                            	   136: #------------------------------------------------------------------------------
                            	   137: # Remove a task from the timeout list.
                            	   138: # Called when a mailbox is freed and a task is waiting at the
                            	   139: # mailbox.
                            	   140: #
                            	   141: # Parameters:
                            	   142: #		a0 = pointer to TCB
                            	   143: # Modifies:
                            	   144: #		none
                            	   145: # Returns:
                            	   146: #		none
                            	   147: #------------------------------------------------------------------------------
                            	   148: 
                            	   149: RemoveFromTimeoutList:
01:000013E4 9E070040        	   150: 	push %a0-%a4
01:000013E8 A6000000        	   151: 	load %a1,TImeoutList
01:000013EC 030A0400        	   152: 	cmpa %cr0,%a0,%a1					# head of list?
01:000013F0 183140E1        	   153: 	beq	%cr0,.0001
01:000013F4 CF080080        	   154: 	move %a2,%a0							# %a2 points to arg
                            	   155: 	# We want
                            	   156: 	# arg->next->prev = arg->prev
                            	   157: 	# arg->prev->next = arg->next
01:000013F8 66180806        	   158: 	load %a0,TCBNext[%a2]
01:000013FC 8F080080        	   159: 	move %a1,%a0
01:00001400 66181806        	   160: 	load %a0,TCBPrev[%a2]
01:00001404 0F090080        	   161: 	move %a3,%a0
                            	   162: 	# Here:
                            	   163: 	# %a1 = arg->next
                            	   164: 	# %a3 = arg->prev
01:00001408 66191806        	   165: 	load %a4,TCBPrev[%a2]
01:0000140C 74211806        	   166: 	stptr %a4,TCBPrev[%a3]
01:00001410 66190806        	   167: 	load %a4,TCBNext[%a2]
01:00001414 74110806        	   168: 	stptr %a4,TCBNext[%a1]
01:00001418 1B82FFFF        	   169: 	b	.0002
                            	   170: 	# Removing from head of timeout list
                            	   171: .0001:
01:0000141C A6080806        	   172: 	load %a1,TCBNext[%a0]
01:00001420 B40000A0        	   173: 	stptr	%a1,TimeoutList		# set new head of list
01:00001424 CF080080        	   174: 	move %a2,%a0
01:00001428 4F100080        	   175: 	move %a0,%a1
01:0000142C 34081806        	   176: 	stptr	%r0,TCBPrev[%a0]		# next->prev = NULL
                            	   177: .0002:
01:00001430 34180806        	   178: 	stptr	%r0,TCBNext[%a2]		# arg->next = NULL
01:00001434 34181806        	   179: 	stptr %r0,TCBPrev[%a2]		# arg->prev = NULL
01:00001438 9F070040D400F8FF	   180: 	pop %a0-%a4
01:00001440 1A000024        	   181: 	blr
                            	   182: 	
                            	   183: #// ----------------------------------------------------------------------------
                            	   184: #// Pop the top entry from the timeout list.
                            	   185: #// ----------------------------------------------------------------------------
                            	   186: #
                            	   187: #hTCB PopTimeoutList()
                            	   188: #{
                            	   189: #    TCB *p;
                            	   190: #    hTCB h;
                            	   191: #
                            	   192: #    h = TimeoutList;
                            	   193: #    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   194: #        TimeoutList = tcbs[TimeoutList].next;
                            	   195: #        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   196: #            tcbs[TimeoutList].prev = h->prev;
                            	   197: #            h->prev->next = TimeoutList;
                            	   198: #        }
                            	   199: #    }
                            	   200: #    return h;
                            	   201: #}
                            	   202: #
                            	   203: # Returns:
                            	   204: #		B = task at top of list
                            	   205: #
                            	   206: 
                            	   207: PopTimeoutList:
01:00001444 9E030040        	   208: 	push %a0-%a3
01:00001448 660000A4        	   209: 	load. %a0,TimeoutList
01:0000144C 183140E1        	   210: 	beq	%cr0,.0001
01:00001450 A6080806        	   211: 	load. %a1,TCBNext[%a0]
01:00001454 E6081806        	   212: 	load %a2,TCBPrev[%a0]
01:00001458 B40000A0        	   213: 	stptr %a1,TimeoutList
01:0000145C F83080E0        	   214: 	peq	%cr0,.0001
01:00001460 0F090080        	   215: 	move %a3,%a0
01:00001464 4F100080        	   216: 	move %a0,%a1
01:00001468 F4081806        	   217: 	stptr %a2,TCBPrev[%a0]
01:0000146C 4F180080        	   218: 	move %a0,%a2
01:00001470 B4080806        	   219: 	stptr %a1,TCBNext[%a0]
01:00001474 34201806        	   220: 	stptr %r0,TCBPrev[%a3]
01:00001478 34200806D400F8FF	   221: 	stptr %r0,TCBNext[%a3]
                            	   222: .0001:
01:00001480 9F030040        	   223: 	pop %a0-%a3
01:00001484 1A000024        	   224: 	blr
                            	   225: 
                            	   226: # ----------------------------------------------------------------------------
                            	   227: # ----------------------------------------------------------------------------
                            	   228: 
                            	   229: DispTwoSpace:
01:00001488 1E000448        	   230: 	push %br1
01:0000148C 5B7CFFFF        	   231: 	bl DispSpace
01:00001490 1F000448        	   232: 	pop %br1
                            	   233: DispSpace:
01:00001494 44000080        	   234: 	loadi %a0,MF_OUTCH
01:00001498 84004080        	   235: 	loadi %a1,' '
01:0000149C 7C001680        	   236: 	ecall 11
01:000014A0 1A000024        	   237: 	blr
                            	   238: 
                            	   239: DumpTCBs:
01:000014A4 1E000448        	   240: 	push %br1
01:000014A8 44000080        	   241: 	loadi %a0,MF_CRLF
01:000014AC 7C001680        	   242: 	ecall 11
01:000014B0 440000A0        	   243: 	loadi %a0,tcbs
                            	   244: .0002:
01:000014B4 0F090080        	   245: 	move %a3,%a0
01:000014B8 A608480600401800	   246: 	load %a1,TCBtid[%a0]
01:000014C0 44000080        	   247: 	loadi %a0,MF_DisplayTetraAsHex
01:000014C4 7C001680        	   248: 	ecall 11
01:000014C8 5A6EFFFF        	   249: 	bl DispSpace
01:000014CC 44000080        	   250: 	loadi %a0,MF_DisplayByteAsHex
01:000014D0 E1207805        	   251: 	ldbz %a2,TCBStatus[%a3]
01:000014D4 7C001680        	   252: 	ecall 11
01:000014D8 5B66FFFF        	   253: 	bl DispTwoSpace
01:000014DC 44000080        	   254: 	loadi %a0,MF_CRLF
01:000014E0 7C001680        	   255: 	ecall 11
01:000014E4 66200806        	   256: 	load. %a0,TCBNext[%a3]
01:000014E8 D82D80E0        	   257: 	bne %cr0,.0002			# could use PRED here
                            	   258: .0001:
01:000014EC 1F000448        	   259: 	pop %br1
01:000014F0 1A000024        	   260: 	blr
                            	   261: 	
01:000014F4 5449442053746174	   262: .byte	"TID Stat"
                            	   263: 
                            	   264: 

Source: "Femtikia.qpa"
                            	  1995: .include "msga.qpa"

Source: "msga.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: #include "..\..\inc\config.qpa"
                            	    38: #include "..\..\inc\const.qpa"
                            	    39: #include "..\..\inc\types.qpa"
                            	    40: ##include "..\..\inc\io_equates.qpa"
                            	    41: #include ".\Femtiki_vars.qpa"
                            	    42: 
                            	    43: # ---------------------------------------------------------------
                            	    44: # ---------------------------------------------------------------
                            	    45: 
                            	    46: .macro macMBXPointerToHandle
                            	    47: 	xor %a0,%a0,0x12345678
                            	    48: .endm
                            	    49: 
                            	    50: .macro macMBXHandleToPointer
                            	    51: 	xor. %a0,%a0,0x12345678
                            	    52: .endm
                            	    53: 
                            	    54: # ---------------------------------------------------------------
                            	    55: #	Description:
                            	    56: #		Copy a message. Assumes guarded by messasge semaphore.
                            	    57: # Stack Space:
                            	    58: #		1 word
                            	    59: # Parameters:
                            	    60: #		%a0 = destination message
                            	    61: #		%a1 = source message
                            	    62: # ---------------------------------------------------------------
                            	    63: 
                            	    64: CopyMsg:
01:000014FC 1E020040        	    65: 	push %a2
01:00001500 E6101800        	    66: 	load %a2,MSGType[%a1]
01:00001504 EE081800        	    67: 	store %a2,MSGType[%a0]
01:00001508 E6100800        	    68: 	load %a2,MSGRetAdr[%a1]
01:0000150C EE080800        	    69: 	store %a2,MSGRetAdr[%a0]
01:00001510 E6101000        	    70: 	load %a2,MSGDestAdr[%a1]
01:00001514 EE081000        	    71: 	store %a2,MSGDestAdr[%a0]
01:00001518 2E08FE7F        	    72: 	storei -1,MSGLink[%a0]
01:0000151C E6102000        	    73: 	load %a2,MSGD1[%a1]
01:00001520 EE082000        	    74: 	store %a2,MSGD1[%a0]
01:00001524 E6102800        	    75: 	load %a2,MSGD2[%a1]
01:00001528 EE082800        	    76: 	store %a2,MSGD2[%a0]
01:0000152C E6103000        	    77: 	load %a2,MSGD3[%a1]
01:00001530 EE083000        	    78: 	store %a2,MSGD3[%a0]
01:00001534 1F020040        	    79: 	pop %a2
01:00001538 1A000024        	    80: 	blr
                            	    81: 
                            	    82: # ---------------------------------------------------------------
                            	    83: #	Description:
                            	    84: #		Freeup message and add back to free list. Assumes the message
                            	    85: # semaphore is guarding the operation.
                            	    86: #
                            	    87: # Stack Space:
                            	    88: #		1 word
                            	    89: # Parameters:
                            	    90: #		%a0 = pointer to message
                            	    91: # ---------------------------------------------------------------
                            	    92: 
                            	    93: FreeMsg:
01:0000153C 1E010040        	    94: 	push %a1
01:00001540 2E081800        	    95: 	storei MT_FREE,MSGType[%a0]
01:00001544 2E08FE7F        	    96: 	storei -1,MSGRetAdr[%a0]
01:00001548 2E08FE7F        	    97: 	storei -1,MSGDEstAdr[%a0]
01:0000154C A6000000        	    98: 	load %a1,freeMSG
01:00001550 AE080000        	    99: 	store %a1,MSGLink[%a0]
01:00001554 6E000000        	   100: 	store %a0,freeMSG
01:00001558 3B08C080        	   101: 	amoadd %r0,1,nMsgBlk
01:0000155C 1F010040        	   102: 	pop %a1
01:00001560 1A000024        	   103: 	blr
                            	   104: 
                            	   105: # ---------------------------------------------------------------
                            	   106: #	Description:
                            	   107: #		Queue a message at a mailbox.
                            	   108: #
                            	   109: #	Assumptions:
                            	   110: #		valid mailbox parameter.
                            	   111: #
                            	   112: #	Called from:
                            	   113: #		SendMsg
                            	   114: #		PostMsg
                            	   115: # Parameters:
                            	   116: #		%a0 = pointer to mailbox
                            	   117: #		%a1 = pointer to message
                            	   118: # ---------------------------------------------------------------
                            	   119: 
                            	   120: QueueMsg:
01:00001564 1E000448        	   121: 	push %br1
01:00001568 1E060040        	   122: 	push %a2-%a4
01:0000156C 44010080        	   123: 	loadi %a4,E_Ok
01:00001570 CF080080        	   124: 	move %a2,%a0
01:00001574 4400FEFF        	   125: 	loadi %a0,-1
01:00001578 5A22FBFF        	   126: 	bl LockMSGSemaphore
01:0000157C 983840E1        	   127: 	beq %cr0,.0001
01:00001580 C4183880        	   128: 	addi %a2,%a2,MBXMQCount
01:00001584 3B18C080        	   129: 	amoadd %r0,1,[%a2]
01:00001588 C418C8FF        	   130: 	addi %a2,%a2,-MBXMQCount
01:0000158C 66185000        	   131: 	load %a0,MBXMQStrategy[%a2]
01:00001590 03080080        	   132: 	cmpi %cr0,%a0,MQS_UNLIMITED
01:00001594 983640E1        	   133: 	beq %cr0,.0002
01:00001598 03080080        	   134: 	cmpi %cr0,%a0,MQS_NEWEST
01:0000159C 993180E0        	   135: 	bne %cr0,.0005
                            	   136: .0008:
01:000015A0 66183800        	   137: 	load %a0,MBXMQCount[%a2]
01:000015A4 26194000        	   138: 	load %a3,MBXMQSize[%a2]
01:000015A8 030A0800        	   139: 	cmpa %cr0,%a0,%a3
01:000015AC 993658E1        	   140: 	ble .0004
01:000015B0 66182800        	   141: 	load %a0,MBXMQHead[%a2]
01:000015B4 26090000        	   142: 	load %a3,MSGLink[%a0]
01:000015B8 5B5AFFFF        	   143: 	bl FreeMsg
01:000015BC C4183880        	   144: 	addi %a2,%a2,MBXMQCount
01:000015C0 3BF8C080        	   145: 	amoadd %r0,-1,[%a2]
01:000015C4 C418C8FF        	   146: 	addi %a2,%a2,-MBXMQCount
01:000015C8 2E192800        	   147: 	store %a3,MBXMQHead[%a2]
01:000015CC 66184804        	   148: 	load. %a0,MBXMQMissed[%a2]
01:000015D0 F82F46E1        	   149: 	pge %cr0,.0007
01:000015D4 C4184880        	   150: 	addi %a2,%a2,MBXMQMissed
01:000015D8 3B18C080        	   151: 	amoadd %r0,1,[%a2]
01:000015DC C418B8FF        	   152: 	addi %a2,%a2,-MBXMQMissed
                            	   153: .0007:
01:000015E0 44010A80        	   154: 	loadi %a4,E_QueFull
01:000015E4 1B68FFFF        	   155: 	b .0008
                            	   156: .0005:
01:000015E8 03080080        	   157: 	cmpi %cr0,%a0,MQS_OLDEST
01:000015EC 993480E0        	   158: 	bne %cr0,.0004
01:000015F0 66183800        	   159: 	load %a0,MBXMQCount[%a2]
01:000015F4 26194000        	   160: 	load %a3,MBXMQSize[%a2]
01:000015F8 030A0800        	   161: 	cmpa %cr0,%a0,%a3
01:000015FC F83098E0        	   162: 	ple .0009
01:00001600 4F100080        	   163: 	move %a0,%a1										# free up passed in message
01:00001604 5A48FFFF        	   164: 	bl FreeMsg
01:00001608 C4183880        	   165: 	addi %a2,%a2,MBXMQCount
01:0000160C 3BF8C080        	   166: 	amoadd %r0,-1,[%a2]
01:00001610 C418C8FF        	   167: 	addi %a2,%a2,-MBXMQCount
01:00001614 2E192800        	   168: 	store %a3,MBXMQHead[%a2]
01:00001618 66184804        	   169: 	load. %a0,MBXMQMissed[%a2]
                            	   170: .0009:
01:0000161C 66183800        	   171: 	load %a0,MBXMQCount[%a2]
01:00001620 26194000        	   172: 	load %a3,MBXMQSize[%a2]
01:00001624 030A0800        	   173: 	cmpa %cr0,%a0,%a3
01:00001628 993148E1        	   174: 	ble %cr0,.00010
01:0000162C 66182800        	   175: 	load %a0,MBXMQHead[%a2]
01:00001630 26193000        	   176: 	load %a3,MBXMQTail[%a2]
                            	   177: .00012:
01:00001634 03080800        	   178: 	cmp %cr0,%a0,%a3
01:00001638 F82F80E0        	   179: 	peq %cr0,.00011
01:0000163C 8F080080        	   180: 	move %a1,%a0										# msg = tmpmsg
01:00001640 6E080000        	   181: 	store %a0,MSGLink[%a0]
01:00001644 1A76FFFF        	   182: 	b .00012
                            	   183: .00011:
01:00001648 AE183000        	   184: 	store %a1,MBXMQTail[%a2]				# mbx->mq_tail = msg
01:0000164C 5A36FFFF        	   185: 	bl FreeMsg										# FreeMsg(tmpmsg)
01:00001650 66184804        	   186: 	load. %a0,MBXMQMissed[%a2]
01:00001654 F82F46E1        	   187: 	pge %cr0,.00013
01:00001658 C4184880        	   188: 	addi %a2,%a2,MBXMQMissed
01:0000165C 3B18C080        	   189: 	amoadd %r0,1,[%a2]
01:00001660 C418B8FF        	   190: 	addi %a2,%a2,-MBXMQMissed
                            	   191: .00013:
01:00001664 C4183880        	   192: 	addi %a2,%a2,MBXMQCount
01:00001668 3BF8C080        	   193: 	amoadd %r0,-1,[%a2]
01:0000166C C418C8FF        	   194: 	addi %a2,%a2,-MBXMQCount
01:00001670 44010A80        	   195: 	loadi %a4,E_QueFull
                            	   196: .00010:
01:00001674 03280A80        	   197: 	cmpi %cr0,%a4,E_QueFull
01:00001678 983040E1        	   198: 	beq %cr0,.00014
                            	   199: .0002:
01:0000167C 66183004        	   200: 	load. %a0,MBXMQTail[%a2]
01:00001680 F92F86E0        	   201: 	plt %cr0,.0003
01:00001684 46083880        	   202: 	mulai %a0,%a0,MSG_SIZE						# x bytes per message
01:00001688 270900A0        	   203: 	loada %a3,messages[%a0]
01:0000168C AE200000        	   204: 	store %a1,MSGLink[%a3]					# 	message[mbx->mq_tail].link = msg
01:00001690 1A7CFFFF        	   205: 	b .0004												# else
                            	   206: .0003:
01:00001694 AE182800        	   207: 	store %a1,MBXMQHead[%a2]				#		mbx->mq_head = msg
                            	   208: .0004:
01:00001698 AE183000        	   209: 	store %a1,MBXMQTail[%a2]				# mbx->mq_tail = msg
01:0000169C 2E10FE7F        	   210: 	storei -1,MSGLink[%a1]					# msg->link = -1
                            	   211: .00014:
                            	   212: 	macUnlockMSGSemaphore
01:000016A0 2E000200        	     1M 	store %r0,MSGSEMA
                            	   213: .0001:
01:000016A4 4F280080        	   214: 	move %a0,%a4
01:000016A8 1F060040        	   215: 	pop %a2-%a4
01:000016AC 1F000448        	   216: 	pop %br1
01:000016B0 1A000024        	   217: 	blr	
                            	   218: 
                            	   219: # ---------------------------------------------------------------
                            	   220: #	Description:
                            	   221: #		Dequeues a message from a mailbox.
                            	   222: #
                            	   223: #	Assumptions:
                            	   224: #		Mailbox parameter is valid.
                            	   225: #		System semaphore is locked already.
                            	   226: #
                            	   227: #	Called from:
                            	   228: #		FreeMbx - (locks mailbox)
                            	   229: #		WaitMsg	-	"
                            	   230: #		CheckMsg-	"
                            	   231: # Parameters:
                            	   232: #		%a0 = pointer to mailbox
                            	   233: # ---------------------------------------------------------------
                            	   234: 
                            	   235: DequeueMsg:
01:000016B4 1E010040        	   236: 	push %a1-%a2
01:000016B8 8F08008000405800	   237: 	move %a1,%a0
01:000016C0 44000080        	   238: 	loadi %a0,0
01:000016C4 E6103804        	   239: 	load. %a2,MBXMQCount[%a1]
01:000016C8 983040E1        	   240: 	beq %cr0,.0001
01:000016CC 84103880        	   241: 	addi %a1,%a1,MBXMQCount
01:000016D0 3BF8C080        	   242: 	amoadd %r0,-1,[%a1]
01:000016D4 8410C8FF        	   243: 	addi %a1,%a1,-MBXMQCount
01:000016D8 66102804        	   244: 	load. %a0,MBXMQHead[%a1]
01:000016DC F92F86E0        	   245: 	plt %cr0,.0001
01:000016E0 E6080004        	   246: 	load. %a2,MSGLink[%a0]
01:000016E4 EE102800        	   247: 	store %a2,MBXMQHead[%a1]
01:000016E8 F92F46E1        	   248: 	pge %cr0,.0002
01:000016EC 2E10FE7F        	   249: 	storei -1,MBXMQTail[%a1]
                            	   250: .0002:
01:000016F0 6E080000        	   251: 	store %a0,MSGLink[%a0]
                            	   252: .0001:
01:000016F4 1F010040        	   253: 	pop %a1-%a2
01:000016F8 1A000024        	   254: 	blr
                            	   255: 
                            	   256: # ---------------------------------------------------------------
                            	   257: #	Description:
                            	   258: #		Dequeues a task from a mailbox. The task will also
                            	   259: #	be removed from the timeout list (if it's present there),
                            	   260: #	and	the timeout list will be adjusted accordingly.
                            	   261: #
                            	   262: #	Assumptions:
                            	   263: #		Mailbox parameter is valid.
                            	   264: # Parameters:
                            	   265: #		%a0 = pointer to mailbox
                            	   266: # Returns:
                            	   267: #		%a0 = error code
                            	   268: #		%a1 = task
                            	   269: # ---------------------------------------------------------------
                            	   270: 
                            	   271: DequeTaskFromMbx:
01:000016FC 03080080        	   272: 	cmpi %cr0,%a0,0			# mbx null?
01:00001700 193540E1        	   273: 	beq %cr0,.0001
01:00001704 1E060040        	   274: 	push %a2-%a4				# save %a2,%a3,%a4
01:00001708 CF080080        	   275: 	move %a2,%a0
01:0000170C 4400FEFF        	   276: 	loadi %a0,-1
01:00001710 5ABCFAFF        	   277: 	bl LockMSGSemaphore
01:00001714 183440E1        	   278: 	beq %cr0,.0006
01:00001718 66181000        	   279: 	load %a0,MBXTQHead[%a2]
01:0000171C 0310FEFF        	   280: 	cmpi %cr0,%a1,-1
01:00001720 183080E0        	   281: 	bne %cr0,.0002
                            	   282: 	macUnlockMSGSemaphore
01:00001724 2E000000        	     1M 	store %r0,MSGSEMA
01:00001728 84000080        	   283: 	loadi %a1,0
01:0000172C 44000080        	   284: 	loadi %a0,E_NoTask
01:00001730 1F060040        	   285: 	pop %a2-%a4
01:00001734 1F000448        	   286: 	pop %br1
01:00001738 1A000024        	   287: 	blr
                            	   288: .0002:
01:0000173C C4182080        	   289: 	addi %a2,%a2,MBXTQCount
01:00001740 3BF8C080        	   290: 	amoadd %r0,-1,[%a2]
01:00001744 C418E0FF        	   291: 	addi %a2,%a2,-MBXTQCount
01:00001748 26191000        	   292: 	load %a3,MBXTQHead[%a2]
01:0000174C 8F200080        	   293: 	move %a1,%a3
01:00001750 66210004        	   294: 	load. %a4,TCBMBQNext[%a3]
01:00001754 6E191000        	   295: 	store %a4,MBXTQHead[%a2]
01:00001758 F82F88E0        	   296: 	ple %cr0,.0003
01:0000175C EE270000        	   297: 	store -1,TCBMBQPrev[%a3]
01:00001760 1B7AFFFF        	   298: 	b .0004
                            	   299: .0003:
01:00001764 2E18FE7F        	   300: 	storei -1,MBXTQTail[%a2]
                            	   301: .0004:
                            	   302: 	macUnlockMSGSemaphore
01:00001768 2E000000        	     1M 	store %r0,MSGSEMA
01:0000176C 03200000        	   303: 	cmp %cr0,%a3,0
01:00001770 993040E1        	   304: 	beq %cr0,.0005
01:00001774 66217805        	   305: 	load %a4,TCBStatus[%a3]
01:00001778 08800A04        	   306: 	and. %r0,TS_TIMEOUT,%a4
01:0000177C F82F80E0        	   307: 	peq %cr0,.0007
01:00001780 4F200080        	   308: 	move %a0,%a3
01:00001784 5B94FEFF        	   309: 	bl RemoveFromTimeoutList
                            	   310: .0007:
01:00001788 2E20FE7F        	   311: 	storei -1,TCBMBQNext[%a3]
01:0000178C 2E20FE7F        	   312: 	storei -1,TCBMBQPrev[%a3]
01:00001790 2E20FE7F        	   313: 	storei -1,TCBhWaitMbx[%a3]	# no longer waiting at mailbox
01:00001794 04217885        	   314: 	addi %a3,%a3,TCBStatus
01:00001798 3BB80081        	   315: 	amoandb %r0,~TS_WAITMSG,[%a3]
01:0000179C 042188FA        	   316: 	addi %a3,%a3,-TCBStatus
                            	   317: .0005:
01:000017A0 44000080        	   318: 	loadi %a0,E_Ok
01:000017A4 1F060040        	   319: 	pop %a2-%a4
01:000017A8 1F000448        	   320: 	pop %br1
01:000017AC 1A000024        	   321: 	blr
                            	   322: 	# Here the semaphore could not be locked
                            	   323: .0006:
01:000017B0 44000080        	   324: 	loadi %a0,E_Busyed
01:000017B4 1F060040        	   325: 	pop %a2-%a4
01:000017B8 1F000448        	   326: 	pop %br1
01:000017BC 1A000024        	   327: 	blr
                            	   328: 	# Here there was a problem with an argument
                            	   329: .0001:
01:000017C0 44000280        	   330: 	loadi %a0,E_Arg
01:000017C4 1A000024        	   331:   blr
                            	   332: 
                            	   333: # ---------------------------------------------------------------
                            	   334: #	Description:
                            	   335: #		Allocate a mailbox. The default queue strategy is to
                            	   336: #	queue the eight most recent messages.
                            	   337: #
                            	   338: # Parameters:
                            	   339: #		%a1 = pointer to place to store mailbox handle
                            	   340: # ---------------------------------------------------------------
                            	   341: 
                            	   342: FMTK_AllocMbx:
                            	   343: 	macAdrCheck %a1
01:000017C8 03120080        	     1M 	cmpai %cr0,%a1,0						# NULL pointer?
01:000017CC 431200A0        	     2M 	cmpai %cr1,%a1,0x00800000		# too low
01:000017D0 831204A0        	     3M 	cmpai %cr2,%a1,0xC0000000		# too high
01:000017D4 0B002002        	     4M 	cror %cr0?eq,%cr0?eq,%cr1?lt
01:000017D8 0B00400E        	     5M 	crorc %cr0?eq,%cr0?eq,%cr2?le
01:000017DC F82F80E0        	     6M 	peq %cr0,.000164
01:000017E0 44000280        	     7M 	loadi %a0,E_Arg
01:000017E4 1A000080        	     8M 	b OSExit
                            	     9M .000164:
01:000017E8 1E000448        	   344: 	push %br1
01:000017EC 1E040040        	   345: 	push %a3
01:000017F0 4400FEFF        	   346: 	loadi %a0,-1
01:000017F4 5B82FAFF00008000	   347: 	bl LockMSGSemaphore
01:000017FC 000000C0
01:00001800 993340E1        	   348: 	beq %cr0,.0002
01:00001804 66000004        	   349: 	load. %a0,freeMBX
01:00001808 F82F80E0        	   350: 	peq %cr0,.0003
01:0000180C 0308FEFF        	   351: 	cmpi %cr0,%a0,-1
01:00001810 992F80E0        	   352: 	bne %cr0,.0004
                            	   353: .0003:
                            	   354: 	macUnlockMSGSemaphore
01:00001814 2E000000        	     1M 	store %r0,MSGSEMA
01:00001818 44005080        	   355: 	loadi %a0,E_NoMoreMbx
01:0000181C 1F040040        	   356: 	pop %a3
01:00001820 1F000448        	   357: 	pop %br1
01:00001824 1AC6FAFF        	   358: 	b EnvExitLight
                            	   359: .0004:
01:00001828 E6080800        	   360: 	load %a2,MBXLink[%a0]
01:0000182C EE000000        	   361: 	store %a2,freeMBX
01:00001830 040100A0        	   362: 	loadi %a3,nMailbox
01:00001834 3BF8C080        	   363: 	amoadd %r0,-1,[%a3]
                            	   364: 	macUnlockMSGSemaphore
01:00001838 2E000200C000F8FF	     1M 	store %r0,MSGSEMA
01:00001840 CF080080        	   365: 	move %a2,%a0
                            	   366: 	macMBXPointerToHandle
01:00001844 4A083000        	     1M 	xor %a0,%a0,0x12345678
01:00001848 070008E0        	   367:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:0000184C 33000058        	   368:   sync
01:00001850 6E100000        	   369: 	store %a0,[%a1]						# do the store to the proper address space
01:00001854 070008E0        	   370:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001858 33000058        	   371:   sync
01:0000185C 8F180080        	   372: 	move %a1,%a2
01:00001860 5A000080        	   373: 	bl GetAppHandle
01:00001864 68100200        	   374: 	stb %a0,MBXOwner[%a1]
01:00001868 2E10FE7F        	   375: 	storei -1,MBXTQHead[%a1]
01:0000186C 2E10FE7F        	   376: 	storei -1,MBXTQTail[%a1]
01:00001870 2E10FE7F        	   377: 	storei -1,MBXMQHead[%a1]
01:00001874 2E10FE7F        	   378: 	storei -1,MBXMQTail[%a1]
01:00001878 2E10200000000800	   379: 	store %r0,MBXTQCount[%a1]
01:00001880 2E103800        	   380: 	store %r0,MBXMQCount[%a1]
01:00001884 2E104800        	   381: 	store %r0,MBXMQMissed[%a1]
01:00001888 2E105000        	   382: 	storei 8,MBXMQSize[%a1]
01:0000188C 2E105000        	   383: 	storei MQS_NEWEST,MBXMQStrategy[%a1]
01:00001890 44000080        	   384: 	loadi %a0,E_Ok
01:00001894 1F040040        	   385: 	pop %a3
01:00001898 1F000448        	   386: 	pop %br1
01:0000189C 1AA8FAFF        	   387: 	b EnvExitLight
                            	   388: .0002:
01:000018A0 44001C80        	   389: 	loadi %a0,E_Busy
01:000018A4 1F040040        	   390: 	pop %a3
01:000018A8 1F000448        	   391: 	pop %br1
01:000018AC 1AA4FAFF        	   392: 	b EnvExitLight
                            	   393: 
                            	   394: # ---------------------------------------------------------------
                            	   395: #	Description:
                            	   396: #		Free up a mailbox. When the mailbox is freed any queued
                            	   397: #	messages must be freed. Any queued threads must also be
                            	   398: #	dequeued. 
                            	   399: #
                            	   400: # Parameters:
                            	   401: #		a1 = handle of mailbox
                            	   402: # ---------------------------------------------------------------
                            	   403: 
                            	   404: FMTK_FreeMbx:
01:000018B0 4F100080        	   405: 	move %a0,%a1
                            	   406: 	macMBXHandleToPointer
01:000018B4 4A083104        	     1M 	xor. %a0,%a0,0x12345678
01:000018B8 193540E1        	   407: 	beq %cr0,.0001
01:000018BC 1E000448        	   408: 	push %br1
01:000018C0 1E010040        	   409: 	push %a1-%a2						# save %a1,%a2
01:000018C4 8F080080        	   410: 	move %a1,%a0
01:000018C8 4400FEFF        	   411: 	loadi %a0,-1
01:000018CC 5B4CFAFF        	   412: 	bl LockMSGSemaphore
01:000018D0 D93340E1        	   413: 	beq %cr0,.0002
01:000018D4 5A000080        	   414: 	bl GetAppHandle
01:000018D8 E1100100        	   415: 	ldbz. %a2,MBXOwner[%a1]
01:000018DC 992F40E1        	   416: 	beq %cr0,.0003
01:000018E0 03080600        	   417: 	cmp %cr0,%a0,%a2
01:000018E4 592F40E1        	   418: 	beq %cr0,.0003
                            	   419: 	macUnlockMSGSemaphore
01:000018E8 2E000000        	     1M 	store %r0,MSGSEMA
01:000018EC 44001880        	   420: 	loadi %a0,E_NotOwner
01:000018F0 1F010040        	   421: 	pop %a1-%a2
01:000018F4 1F000448        	   422: 	pop %br1
01:000018F8 1A000024        	   423: 	blr
                            	   424: 	# Free up any queued messages
                            	   425: .0003:
01:000018FC 4F100080        	   426: 	move %a0,%a1
01:00001900 5BE6FEFF        	   427: 	bl DequeueMsg
01:00001904 03080080        	   428: 	cmpi %cr0,%a0,0
01:00001908 F82F80E0        	   429: 	peq %cr0,.0004
01:0000190C 5A86FEFF        	   430: 	bl FreeMsg
01:00001910 1A70FFFF        	   431: 	b .0003
                            	   432: .0004:
01:00001914 4F100080        	   433: 	move %a0,%a1
01:00001918 CF100080        	   434: 	move %a2,%a1
01:0000191C 5BF0FEFF        	   435: 	bl DequeTaskFromMbx
01:00001920 4F100080        	   436: 	move %a0,%a1
01:00001924 8F180080        	   437: 	move %a1,%a2
01:00001928 D92F40E1        	   438: 	beq %cr0,.0005
01:0000192C 2E085007        	   439: 	storei MT_NONE,TCBMsg+MSGType[%a0]
01:00001930 44087885        	   440: 	addi %a0,%a0,TCBStatus
01:00001934 3B880181        	   441: 	amoandb. %r0,TS_TIMEOUT,[%a0]
01:00001938 440888FA        	   442: 	addi %a0,%a0,-TCBStatus
01:0000193C F92E80E0        	   443: 	peq %cr0,.0006
01:00001940 5A26FEFF        	   444: 	bl RemoveFromTimeoutList
                            	   445: .0006:
01:00001944 5B12FEFF        	   446: 	bl InsertIntoReadyQueue
01:00001948 8F180080        	   447: 	move %a1,%a2
01:0000194C 1B66FFFF        	   448: 	b .0004
                            	   449: .0005:
01:00001950 66000000        	   450: 	load %a0,freeMBX
01:00001954 6E100800        	   451: 	store %a0,MBXLink[%a1]
01:00001958 AE000000        	   452: 	store %a1,freeMBX
01:0000195C 440000A0        	   453: 	loadi %a0,nMailbox
01:00001960 3B08C080        	   454: 	amoadd %r0,1,[%a0]
                            	   455: 	macUnlockMSGSemaphore
01:00001964 2E000200        	     1M 	store %r0,MSGSEMA
01:00001968 44000080        	   456: 	loadi %a0,E_Ok
01:0000196C 1F010040        	   457: 	pop %a1-%a2
01:00001970 1F000448        	   458: 	pop %br1
01:00001974 1A000024        	   459: 	blr
                            	   460: .0002:
01:00001978 44001C80C000F8FF	   461: 	loadi %a0,E_Busy
01:00001980 1F010040        	   462: 	pop %a1-%a2
01:00001984 1F000448        	   463: 	pop %br1
01:00001988 1A000024        	   464: 	blr
                            	   465: .0001:
01:0000198C 44000280        	   466: 	loadi %a0,E_Arg
01:00001990 1A000024        	   467: 	blr
                            	   468: 	
                            	   469: # ---------------------------------------------------------------
                            	   470: #	Description:
                            	   471: #		Set the mailbox message queueing strategy.
                            	   472: # ---------------------------------------------------------------
                            	   473: 
                            	   474: SetMbxMsgQueStrategy:
01:00001994 03080080        	   475: 	cmpi %cr0,%a0,0
01:00001998 583240E1        	   476: 	beq %cr0,.0001
01:0000199C 03120480        	   477: 	cmpai %cr0,%a1,2
01:000019A0 183288E0        	   478: 	bgt %cr0,.0001
01:000019A4 1E000448        	   479: 	push %br1
01:000019A8 1E040040        	   480: 	push %a3-%a4						# save %a3,%a4
01:000019AC 0F090080        	   481: 	move %a3,%a0
01:000019B0 4400FEFF        	   482: 	loadi %a0,-1
01:000019B4 5B12FAFF        	   483: 	bl LockMSGSemaphore
01:000019B8 D83040E1        	   484: 	beq %cr0,.0002
                            	   485: 	# Check if this app owns the mailbox
01:000019BC 5A000080        	   486: 	bl GetAppHandle
01:000019C0 992F40E1        	   487: 	beq %cr0,.0003
01:000019C4 61210000        	   488: 	ldbz %a4,MBXOwner[%a3]
01:000019C8 03080800        	   489: 	cmp %cr0,%a0,%a3
01:000019CC 582F40E1        	   490: 	beq %cr0,.0003
                            	   491: 	macUnlockMSGSemaphore
01:000019D0 2E000000        	     1M 	store %r0,MSGSEMA
01:000019D4 44001880        	   492: 	loadi %a0,E_NotOwner
01:000019D8 1F040040        	   493: 	pop %a3-%a4
01:000019DC 1F000448        	   494: 	pop %br1
01:000019E0 1A000024        	   495: 	blr
                            	   496: .0003:
01:000019E4 AE205000        	   497: 	store %a1,MBXMQStrategy[%a3]
01:000019E8 EE204000        	   498: 	store %a2,MBXMQSize[%a3]
                            	   499: 	macUnlockMSGSemaphore
01:000019EC 2E000000        	     1M 	store %r0,MSGSEMA
01:000019F0 44000080        	   500: 	loadi %a0,E_Ok
01:000019F4 1F040040        	   501: 	pop %a3-%a4
01:000019F8 1F000448        	   502: 	pop %br1
01:000019FC 1A000024        	   503: 	blr
                            	   504: .0002:
01:00001A00 44001C80        	   505: 	loadi %a0,E_Busy
01:00001A04 1F040040        	   506: 	pop %a3-%a4
01:00001A08 1F000448        	   507: 	pop %br1
01:00001A0C 1A000024        	   508: 	blr
                            	   509: .0001:
01:00001A10 44000280        	   510: 	loadi %a0,E_Arg
01:00001A14 1A000024        	   511: 	blr
                            	   512: 
                            	   513: # ---------------------------------------------------------------
                            	   514: #	Description:
                            	   515: #		Send a message.
                            	   516: # Parameters:
                            	   517: #		%a1 = handle of mailbox
                            	   518: #		%a2 = message data #1
                            	   519: #		%a3 = message data #2
                            	   520: #		%a4 = message data #3
                            	   521: # ---------------------------------------------------------------
                            	   522: 
                            	   523: FMTK_SendMsg:
01:00001A18 4F100080        	   524: 	move %a0,%a1
                            	   525: 	macMBXHandleToPointer
01:00001A1C 4A083104        	     1M 	xor. %a0,%a0,0x12345678
01:00001A20 03080080        	   526: 	cmpi %cr0,%a0,0
01:00001A24 583740E1        	   527: 	beq %cr0,.0001
01:00001A28 1E000448        	   528: 	push %br1
01:00001A2C 1E300040        	   529: 	push %a5-%a7						# Save %a5,%a6,%a7
01:00001A30 04020080        	   530: 	loadi %a7,0							# thrd = null
01:00001A34 8F090080        	   531: 	move %a5,%a0
01:00001A38 4400FEFF        	   532: 	loadi %a0,-1
01:00001A3C 5BF0F9FF        	   533: 	bl LockMSGSemaphore
01:00001A40 D93240E1        	   534: 	beq %cr0,.0002
01:00001A44 66300004        	   535: 	load. %a0,MBXOwner[%a5]
01:00001A48 982F86E0        	   536: 	bge %cr0,.0003
01:00001A4C 03080080        	   537: 	cmpi %cr0,%a0,NR_ACB
01:00001A50 582F48E1        	   538: 	ble %cr0,.0003
                            	   539: 	macUnlockMSGSemaphore
01:00001A54 2E000000        	     1M 	store %r0,MSGSEMA
01:00001A58 44000E80        	   540: 	loadi %a0,E_NotAlloc
01:00001A5C 1F300040        	   541: 	pop %a5-%a7
01:00001A60 1F000448        	   542: 	pop %br1
01:00001A64 1A000024        	   543: 	blr
                            	   544: .0003:
01:00001A68 66000004        	   545: 	load. %a0,freeMSG
01:00001A6C F92E80E0        	   546: 	peq %cr0,.0005
01:00001A70 0308FEFF        	   547: 	cmpi %cr0,%a0,-1
01:00001A74 F82F40E1        	   548: 	pne %cr0,.0004
                            	   549: .0005:
                            	   550: 	macUnlockMSGSemaphore
01:00001A78 2E0000003F000000	     1M 	store %r0,MSGSEMA
01:00001A80 44005280        	   551: 	loadi %a0,E_NoMoreMsgBlks
01:00001A84 1F300040        	   552: 	pop %a5-%a7
01:00001A88 1F000448        	   553: 	pop %br1
01:00001A8C 1A000024        	   554: 	blr
                            	   555: .0004:
01:00001A90 CF090080        	   556: 	move %a6,%a0
01:00001A94 66380000        	   557: 	load %a0,MSGLink[%a6]
01:00001A98 6E000000        	   558: 	store %a0,freeMSG
01:00001A9C 44000080        	   559: 	loadi %a0,nMsgBlk
01:00001AA0 3BF8C080        	   560: 	amoadd %r0,-1,[%a0]
01:00001AA4 5A000080        	   561: 	bl GetAppHandle
01:00001AA8 68380800        	   562: 	stb %a0,MSGRetAdr[%a6]
01:00001AAC AE391000        	   563: 	store %a5,MSGDestAdr[%a6]
01:00001AB0 2E381800        	   564: 	storei MBT_DATA,MSGType[%a6]
01:00001AB4 EE382000        	   565: 	store %a2,MSGD1[%a6]
01:00001AB8 2E392800        	   566: 	store %a3,MSGD2[%a6]
01:00001ABC 6E393000        	   567: 	store %a4,MSGD3[%a6]
01:00001AC0 4F380080        	   568: 	move %a0,%a6
01:00001AC4 5B86FEFF        	   569: 	bl DequeTaskFromMbx
01:00001AC8 0F120080        	   570: 	move %a7,%a1					# %a7 = pointer to dequeued task
                            	   571: 	macUnlockMSGSemaphore
01:00001ACC 2E000000        	     1M 	store %r0,MSGSEMA
                            	   572: .0002:
01:00001AD0 03400080        	   573: 	cmpi %cr0,%a7,0
01:00001AD4 F82F40E1        	   574: 	pne %cr0,.0006
01:00001AD8 4F300080        	   575: 	move %a0,%a5					# %a0 = pointer to mailbox
01:00001ADC 8F380080        	   576: 	move %a1,%a6					# %a1 = pointer to message
01:00001AE0 5B1AFEFF        	   577: 	bl QueueMsg
01:00001AE4 1F300040        	   578: 	pop %a5-%a7
01:00001AE8 1F000448        	   579: 	pop %br1
01:00001AEC 1A000024        	   580: 	blr
                            	   581: .0006:
01:00001AF0 4400FEFF        	   582: 	loadi %a0,-1
01:00001AF4 5BC2F9FF        	   583: 	bl LockMSGSemaphore
01:00001AF8 193040E1        	   584: 	beq %cr0,.0008
01:00001AFC 67403807        	   585: 	loada %a0,TCBMsg[%a7]
01:00001B00 8F380080        	   586: 	move %a1,%a6
01:00001B04 5AF8FDFF        	   587: 	bl CopyMsg
01:00001B08 5B06FEFF        	   588: 	bl FreeMsg
01:00001B0C 66407805        	   589: 	load %a0,TCBStatus[%a7]
01:00001B10 08082004        	   590: 	and. %r0,%a0,TS_TIMEOUT
01:00001B14 F82E80E0        	   591: 	peq %cr0,.0007
01:00001B18 4F400080        	   592: 	move %a0,%a7
01:00001B1C 5BAEFDFF        	   593: 	bl RemoveFromTimeoutList
                            	   594: .0007:
01:00001B20 4F400080        	   595: 	move %a0,%a7
01:00001B24 5B9AFDFF        	   596: 	bl InsertIntoReadyQueue
                            	   597: 	macUnlockMSGSemaphore
01:00001B28 2E000000        	     1M 	store %r0,MSGSEMA
                            	   598: 	# The ready queue changed, maybe a different task is higher priority,
                            	   599: 	# invoke scheduling
01:00001B2C CD63FBFF        	   600: 	bli FemtikiTimerISR
                            	   601: .0008:
01:00001B30 44000080        	   602: 	loadi %a0,E_Ok
01:00001B34 1F300040        	   603: 	pop %a5-%a7
01:00001B38 1F000448        	   604: 	pop %br1
01:00001B3C 1A000024        	   605: 	blr
                            	   606: .0001:
01:00001B40 44000280        	   607: 	loadi %a0,E_Arg
01:00001B44 1A000024        	   608: 	blr
                            	   609: 	
                            	   610: 
                            	   611: # ---------------------------------------------------------------
                            	   612: #	Description:
                            	   613: #		PostMsg() is meant to be called in order to send a
                            	   614: #	message without causing the thread to switch. This is
                            	   615: #	useful in some cases. For example interrupts that don't
                            	   616: #	require a low latency. Normally SendMsg() will be called,
                            	   617: #	even from an ISR to allow the OS to prioritize events.
                            	   618: # ---------------------------------------------------------------
                            	   619: 
                            	   620: FMTK_PostMsg:
01:00001B48 4F100080        	   621: 	move %a0,%a1
                            	   622: 	macMBXHandleToPointer
01:00001B4C 4A083104        	     1M 	xor. %a0,%a0,0x12345678
01:00001B50 03080080        	   623: 	cmpi %cr0,%a0,0
01:00001B54 183740E1        	   624: 	beq %cr0,.0001
01:00001B58 1E000448        	   625: 	push %br1
01:00001B5C 1E300040        	   626: 	push %a5-%a7						# Save %a5,%a6,%a7
01:00001B60 04020080        	   627: 	loadi %a7,0							# thrd = null
01:00001B64 8F090080        	   628: 	move %a5,%a0
01:00001B68 4400FEFF        	   629: 	loadi %a0,-1
01:00001B6C 5BA4F9FF        	   630: 	bl LockMSGSemaphore
01:00001B70 D83240E1        	   631: 	beq %cr0,.0002
01:00001B74 663000043F000000	   632: 	load. %a0,MBXOwner[%a5]
01:00001B7C 3F000000
01:00001B80 192F86E0        	   633: 	bge %cr0,.0003
01:00001B84 03080080        	   634: 	cmpi %cr0,%a0,NR_ACB
01:00001B88 D92E48E1        	   635: 	ble %cr0,.0003
                            	   636: 	macUnlockMSGSemaphore
01:00001B8C 2E000000        	     1M 	store %r0,MSGSEMA
01:00001B90 44000E80        	   637: 	loadi %a0,E_NotAlloc
01:00001B94 1F300040        	   638: 	pop %a5-%a7
01:00001B98 1F000448        	   639: 	pop %br1
01:00001B9C 1A000024        	   640: 	blr
                            	   641: .0003:
01:00001BA0 66000004        	   642: 	load. %a0,freeMSG
01:00001BA4 F82E80E0        	   643: 	peq %cr0,.0005
01:00001BA8 0308FEFF        	   644: 	cmpi %cr0,%a0,-1
01:00001BAC D92E80E0        	   645: 	bne %cr0,.0004
                            	   646: .0005:
                            	   647: 	macUnlockMSGSemaphore
01:00001BB0 2E000000        	     1M 	store %r0,MSGSEMA
01:00001BB4 44005280        	   648: 	loadi %a0,E_NoMoreMsgBlks
01:00001BB8 1F300040        	   649: 	pop %a5-%a7
01:00001BBC 1F000448        	   650: 	pop %br1
01:00001BC0 1A000024        	   651: 	blr
                            	   652: .0004:
01:00001BC4 CF090080        	   653: 	move %a6,%a0
01:00001BC8 66380000        	   654: 	load %a0,MSGLink[%a6]
01:00001BCC 6E000000        	   655: 	store %a0,freeMSG
01:00001BD0 44000080        	   656: 	loadi %a0,nMsgBlk
01:00001BD4 3BF8C080        	   657: 	amoadd %r0,-1,[%a0]
01:00001BD8 5A000080        	   658: 	bl GetAppHandle
01:00001BDC 68380800        	   659: 	stb %a0,MSGRetAdr[%a6]
01:00001BE0 AE391000        	   660: 	store %a5,MSGDestAdr[%a6]
01:00001BE4 2E381800        	   661: 	storei MBT_DATA,MSGType[%a6]
01:00001BE8 EE382000        	   662: 	store %a2,MSGD1[%a6]
01:00001BEC 2E392800        	   663: 	store %a3,MSGD2[%a6]
01:00001BF0 6E393000        	   664: 	store %a4,MSGD3[%a6]
01:00001BF4 4F380080        	   665: 	move %a0,%a6
01:00001BF8 5A3AFEFF        	   666: 	bl DequeTaskFromMbx
01:00001BFC 0F120080        	   667: 	move %a7,%a1					# %a7 = pointer to dequeued task
                            	   668: 	macUnlockMSGSemaphore
01:00001C00 2E000000        	     1M 	store %r0,MSGSEMA
                            	   669: .0002:
01:00001C04 03400080        	   670: 	cmpi %cr0,%a7,0
01:00001C08 F82F40E1        	   671: 	pne %cr0,.0006
01:00001C0C 4F300080        	   672: 	move %a0,%a5					# %a0 = pointer to mailbox
01:00001C10 8F380080        	   673: 	move %a1,%a6					# %a1 = pointer to message
01:00001C14 5ACEFDFF        	   674: 	bl QueueMsg
01:00001C18 1F300040        	   675: 	pop %a5-%a7
01:00001C1C 1F000448        	   676: 	pop %br1
01:00001C20 1A000024        	   677: 	blr
                            	   678: .0006:
01:00001C24 4400FEFF        	   679: 	loadi %a0,-1
01:00001C28 5A76F9FF        	   680: 	bl LockMSGSemaphore
01:00001C2C D82F40E1        	   681: 	beq %cr0,.0008
01:00001C30 67403807        	   682: 	loada %a0,TCBMsg[%a7]
01:00001C34 8F380080        	   683: 	move %a1,%a6
01:00001C38 5BAAFDFF        	   684: 	bl CopyMsg
01:00001C3C 5ABAFDFF        	   685: 	bl FreeMsg
01:00001C40 66407805        	   686: 	load %a0,TCBStatus[%a7]
01:00001C44 08082004        	   687: 	and. %r0,%a0,TS_TIMEOUT
01:00001C48 F82E80E0        	   688: 	peq %cr0,.0007
01:00001C4C 4F400080        	   689: 	move %a0,%a7
01:00001C50 5A62FDFF        	   690: 	bl RemoveFromTimeoutList
                            	   691: .0007:
01:00001C54 4F400080        	   692: 	move %a0,%a7
01:00001C58 5A4EFDFF        	   693: 	bl InsertIntoReadyQueue
                            	   694: 	macUnlockMSGSemaphore
01:00001C5C 2E000000        	     1M 	store %r0,MSGSEMA
                            	   695: .0008:
01:00001C60 44000080        	   696: 	loadi %a0,E_Ok
01:00001C64 1F300040        	   697: 	pop %a5-%a7
01:00001C68 1F000448        	   698: 	pop %br1
01:00001C6C 1A000024        	   699: 	blr
                            	   700: .0001:
01:00001C70 44000280        	   701: 	loadi %a0,E_Arg
01:00001C74 1A000024        	   702: 	blr
                            	   703: 
                            	   704: # ---------------------------------------------------------------
                            	   705: #	Description:
                            	   706: #		Wait for message. If timelimit is zero then the thread
                            	   707: #	will wait indefinately for a message.
                            	   708: #
                            	   709: # Parameters:
                            	   710: #		%a1 = mailbox handle
                            	   711: #		%a2 = pointer to place to store D1
                            	   712: #		%a3 = pointer to place to store D2
                            	   713: #		%a4 = pointer to place to store D3
                            	   714: #		%a5 = time limit
                            	   715: # ---------------------------------------------------------------
                            	   716: 
                            	   717: FMTK_WaitMsg:
01:00001C78 4F100080        	   718: 	move %a0,%a1
                            	   719: 	macMBXHandleToPointer
01:00001C7C 4A083104        	     1M 	xor. %a0,%a0,0x12345678
01:00001C80 03080080        	   720: 	cmpi %cr0,%a0,0
01:00001C84 193F40E1        	   721: 	beq %cr0,.0001
01:00001C88 1E000448        	   722: 	push %br1
01:00001C8C 1E200E40        	   723: 	push %a6-%t2						# Save %a6,%a7,%t0,%t1
01:00001C90 04020080        	   724: 	loadi %a7,0							# thrd = null
01:00001C94 CF090080        	   725: 	move %a6,%a0							# %a6 = pointer to mailbox
01:00001C98 4400FEFF        	   726: 	loadi %a0,-1
01:00001C9C 5B58F9FF        	   727: 	bl LockMSGSemaphore
01:00001CA0 D82F40E1        	   728: 	beq %cr0,.0002
01:00001CA4 66380004        	   729: 	load. %a0,MBXOwner[%a6]
01:00001CA8 192F86E0        	   730: 	bge %cr0,.0003
01:00001CAC 03080080        	   731: 	cmpi %cr0,%a0,NR_ACB
01:00001CB0 D92E48E1        	   732: 	ble %cr0,.0003
                            	   733: 	macUnlockMSGSemaphore
01:00001CB4 2E0000003F000000	     1M 	store %r0,MSGSEMA
01:00001CBC 3F000000
01:00001CC0 44000E80        	   734: 	loadi %a0,E_NotAlloc
01:00001CC4 1F200640        	   735: 	pop %a6-%t1
01:00001CC8 1F000448        	   736: 	pop %br1
01:00001CCC 1A000024        	   737: 	blr
                            	   738: .0003:
01:00001CD0 4F380080        	   739: 	move %a0,%a6
01:00001CD4 5AF2FDFF        	   740: 	bl DequeueMsg
                            	   741: 	macUnlockMSGSemaphore
01:00001CD8 2E000000        	     1M 	store %r0,MSGSEMA
                            	   742: .0002:
01:00001CDC 03080080        	   743: 	cmpi %cr0,%a0,0
01:00001CE0 D83240E1        	   744: 	beq %cr0,.0004
01:00001CE4 03180080        	   745: 	cmpi %cr0,%a2,0
01:00001CE8 F92E80E0        	   746: 	peq %cr0,.0005
01:00001CEC 660A2000        	   747: 	load %t0,MSGD1[%a0]
01:00001CF0 C70208E0        	   748: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001CF4 07000CE000001C00	   749: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001CFC 00001800
01:00001D00 33000058        	   750:   sync
01:00001D04 6E1A0000        	   751: 	store %t0,[%a2]						# do the store to the proper address space
01:00001D08 075808E0        	   752: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001D0C 33000058        	   753:   sync
                            	   754: .0005:
01:00001D10 03200080        	   755: 	cmpi %cr0,%a3,0
01:00001D14 F92E80E0        	   756: 	peq %cr0,.0006
01:00001D18 660A2800        	   757: 	load %t0,MSGD2[%a0]
01:00001D1C C70208E0        	   758: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001D20 07000CE0        	   759: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001D24 33000058        	   760:   sync
01:00001D28 6E220000        	   761: 	store %t0,[%a3]						# do the store to the proper address space
01:00001D2C 075808E0        	   762: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001D30 33000058        	   763:   sync
                            	   764: .0006:
01:00001D34 0328000000001C00	   765: 	cmp %cr0,%a4,0
01:00001D3C 00001800
01:00001D40 592E40E1        	   766: 	beq %cr0,.0007
01:00001D44 660A3000        	   767: 	load %t0,MSGD3[%a0]
01:00001D48 C70208E0        	   768: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001D4C 07000CE0        	   769: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001D50 33000058        	   770:   sync
01:00001D54 6E2A0000        	   771: 	store %t0,[%a4]						# do the store to the proper address space
01:00001D58 075808E0        	   772: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001D5C 33000058        	   773:   sync
                            	   774: .0007:
01:00001D60 4F0A0080        	   775: 	move %t0,%a0
01:00001D64 4400FEFF        	   776: 	loadi %a0,-1
01:00001D68 5A26F9FF        	   777: 	bl LockMSGSemaphore
01:00001D6C D92D40E1        	   778: 	beq %cr0,.0008
01:00001D70 4F480080        	   779: 	move %a0,%t0
01:00001D74 5A6CFDFF00001C00	   780: 	bl FreeMsg
01:00001D7C 00001800
                            	   781: 	macUnlockMSGSemaphore
01:00001D80 2E000000        	     1M 	store %r0,MSGSEMA
                            	   782: .0008:
01:00001D84 44000080        	   783: 	loadi %a0,E_Ok
01:00001D88 1F200E40        	   784: 	pop %a6-%t2
01:00001D8C 1F000448        	   785: 	pop %br1
01:00001D90 1A000024        	   786: 	blr
                            	   787: 	# Here there was no messag available
                            	   788: .0004:
01:00001D94 5A000080        	   789: 	bl GetRunningTCBPtr
01:00001D98 5A000080        	   790: 	bl RemoveFromReadyList
01:00001D9C 840A7885        	   791: 	addi %t1,%a0,TCBStatus
01:00001DA0 3B500082        	   792: 	amoorb %r0,TS_WAITMSG,[%t1]
01:00001DA4 B4080000        	   793: 	stptr %a1,TCBhWaitMbx[%a0]
01:00001DA8 8402FEFF        	   794: 	loadi %t1,-1
01:00001DAC 740A0000        	   795: 	stptr %t0,TCBMBQNext[%a0]
01:00001DB0 4F0A0080        	   796: 	move %t0,%a0								# %t0 = thread
01:00001DB4 4400FEFF        	   797: 	loadi %a0,-1
01:00001DB8 5A12F9FF        	   798: 	bl LockMSGSemaphore
01:00001DBC 03100080        	   799: 		cmpi %cr0,%a1,0
01:00001DC0 F82D80E0        	   800: 		peq %cr0,.0009
01:00001DC4 0310FEFF        	   801: 		cmpi %cr0,%a1,-1
01:00001DC8 F92D40E1        	   802: 		pne %cr0,.0010
                            	   803: .0009:
01:00001DCC B44A0000        	   804: 		stptr %t1,TCBMBXPrev[%t0]
01:00001DD0 74121000        	   805: 		stptr %t0,MBXTQHead[%a1]
01:00001DD4 74121800        	   806: 		stptr %t0,MBXTQTail[%a1]
01:00001DD8 AE122000        	   807: 		store %t1,MBXTQCount[%a1]
01:00001DDC 1A70FFFF        	   808: 		b .0011
                            	   809: .0010:
01:00001DE0 26121800        	   810: 		load %a7,MBXTQTail[%a1]
01:00001DE4 344A0000        	   811: 		stptr %a7,TCBMBXPrev[%t0]
01:00001DE8 74420000        	   812: 		stptr %t0,TCBMBQNext[%a7]
01:00001DEC 74121800        	   813: 		stptr %t0,MBXTQTail[%a1]
01:00001DF0 84122080        	   814: 		addi %t1,%a1,MBXTQCount
01:00001DF4 3B58C080        	   815: 		amoadd %r0,1,[%t1]
                            	   816: .0011:
                            	   817: 	macUnlockMSGSemaphore
01:00001DF8 2E0000003F000000	     1M 	store %r0,MSGSEMA
01:00001E00 03300080        	   818: 	cmpi %cr0,%a5,0							# is there a time limit specified?
01:00001E04 992E48E1        	   819: 	ble %cr0,.0012
01:00001E08 4F480080        	   820: 	move %a0,%t0
01:00001E0C 8F300080        	   821: 	move %a1,%a5
01:00001E10 5A000080        	   822: 	bl InsertIntoTimeoutList
                            	   823: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   824:   # Reschedule will cause control to pass to another thread. This thread is
                            	   825:   # waiting.
01:00001E14 CDA9FAFF        	   826: 	bli FemtikiTimerISR
                            	   827: 	# Control will return here as a result of a SendMsg or a timeout expiring
                            	   828: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01:00001E18 5A000080        	   829: 	bl GetRunningTCBPtr
01:00001E1C 660A5007        	   830: 	load %t0,TCBMsg+MSGType[%a0]
01:00001E20 03480080        	   831: 	cmpi %cr0,%t0,MT_NONE
01:00001E24 F92D40E1        	   832: 	pne %cr0,.0012
01:00001E28 44001080        	   833: 	loadi %a0,E_NoMsg
01:00001E2C 1F200E40        	   834: 	pop %a6-%t2
01:00001E30 1F000448        	   835: 	pop %br1
01:00001E34 1A000024        	   836: 	blr
                            	   837: .0012:
01:00001E38 66083807        	   838: 	load %a0,TCBMsg[%a0]
01:00001E3C 2E081800        	   839: 	storei MT_NONE,MSGType[%a0]
01:00001E40 8402FEFF        	   840: 	loadi %t1,-1
01:00001E44 B40A1000        	   841: 	stptr %t1,MSGDestAdr[%a0]
01:00001E48 B40A0800        	   842: 	stptr %t1,MSGRetAdr[%a0]
01:00001E4C 03180080        	   843: 	cmpi %cr0,%a2,0
01:00001E50 F82E80E0        	   844: 	peq %cr0,.0013
01:00001E54 660A2000        	   845: 	load %t0,MSGD1[%a0]
01:00001E58 C70208E0        	   846: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001E5C 07000CE0        	   847: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001E60 33000058        	   848:   sync
01:00001E64 6E1A0000        	   849: 	store %t0,[%a2]						# do the store to the proper address space
01:00001E68 075808E0        	   850: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001E6C 33000058        	   851:   sync
                            	   852: .0013:
01:00001E70 03200000        	   853: 	cmp %cr0,%a3,0
01:00001E74 F82E80E000001C00	   854: 	peq %cr0,.0014
01:00001E7C 00001800
01:00001E80 660A2800        	   855: 	load %t0,MSGD2[%a0]
01:00001E84 C70208E0        	   856: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001E88 07000CE0        	   857: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001E8C 33000058        	   858:   sync
01:00001E90 6E220000        	   859: 	store %t0,[%a3]						# do the store to the proper address space
01:00001E94 075808E0        	   860: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001E98 33000058        	   861:   sync
                            	   862: .0014:
01:00001E9C 03280080        	   863: 	cmpi %cr0,%a4,0
01:00001EA0 F82D80E0        	   864: 	peq %cr0,.0015
01:00001EA4 660A3000        	   865: 	load %t0,MSGD3[%a0]
01:00001EA8 C70208E0        	   866: 	csrrci %t2,M_SR,0x1C0000	# clear MPRV
01:00001EAC 07000CE0        	   867: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001EB0 33000058        	   868:   sync
01:00001EB4 6E2A000000001C00	   869: 	store %t0,[%a4]						# do the store to the proper address space
01:00001EBC 00001800
01:00001EC0 075808E0        	   870: 	csrrw %r0,M_SR,%t2				# restore SR settings
01:00001EC4 33000058        	   871:   sync
                            	   872: .0015:
01:00001EC8 44000080        	   873: 	loadi %a0,E_Ok
01:00001ECC 1F200640        	   874: 	pop %a6-%t1
01:00001ED0 1F000448        	   875: 	pop %br1
01:00001ED4 1A000024        	   876: 	blr
                            	   877: 	# Bad arg return
                            	   878: .0001:
01:00001ED8 44000280        	   879: 	loadi %a0,E_Arg
01:00001EDC 1A000024        	   880: 	blr
                            	   881: 
                            	   882: # ----------------------------------------------------------------------------
                            	   883: # PeekMsg()
                            	   884: #     Look for a message in the queue but don't remove it from the queue.
                            	   885: #     This is a convenince wrapper for CheckMsg().
                            	   886: # Parameters:
                            	   887: #		%a1 = mailbox handle
                            	   888: #		%a2 = pointer to place to store D1
                            	   889: #		%a3 = pointer to place to store D2
                            	   890: #		%a4 = pointer to place to store D3
                            	   891: # ----------------------------------------------------------------------------
                            	   892: 
                            	   893: FMTK_PeekMsg:
01:00001EE0 84010080        	   894: 	loadi %a5,0
                            	   895: 	# Fall through
                            	   896: 
                            	   897: # ---------------------------------------------------------------
                            	   898: #	Description:
                            	   899: #		Check for message at mailbox. If no message is
                            	   900: #	available return immediately to the caller (CheckMsg() is
                            	   901: #	non blocking). Optionally removes the message from the
                            	   902: #	mailbox.
                            	   903: #
                            	   904: # Parameters:
                            	   905: #		%a1 = mailbox handle
                            	   906: #		%a2 = pointer to place to store D1
                            	   907: #		%a3 = pointer to place to store D2
                            	   908: #		%a4 = pointer to place to store D3
                            	   909: #		%a5 = 1 = remove from queue
                            	   910: # ---------------------------------------------------------------
                            	   911: 
                            	   912: FMTK_CheckMsg:
01:00001EE4 4F100080        	   913: 	move %a0,%a1
                            	   914: 	macMBXHandleToPointer
01:00001EE8 4A083104        	     1M 	xor. %a0,%a0,0x12345678
01:00001EEC 03080080        	   915: 	cmpi %cr0,%a0,0
01:00001EF0 193540E1        	   916: 	beq %cr0,.0001
01:00001EF4 1E000448        	   917: 	push %br1
01:00001EF8 1E200640        	   918: 	push %a6-%t1						# Save %a6,%a7,%t0
01:00001EFC CF090080        	   919: 	move %a6,%a0							# %a6 = pointer to mailbox
01:00001F00 04020080        	   920: 	loadi %a7,0
01:00001F04 4400FEFF        	   921: 	loadi %a0,-1
01:00001F08 5ABEF8FF        	   922: 	bl LockMSGSemaphore
01:00001F0C 992E40E1        	   923: 	beq %cr0,.0002
01:00001F10 66380004        	   924: 	load. %a0,MBXOwner[%a6]
01:00001F14 982D86E0        	   925: 	bge %cr0,.0003
01:00001F18 03080080        	   926: 	cmpi %cr0,%a0,NR_ACB
01:00001F1C 582D48E1        	   927: 	ble %cr0,.0003
                            	   928: 	macUnlockMSGSemaphore
01:00001F20 2E000000        	     1M 	store %r0,MSGSEMA
01:00001F24 44000E80        	   929: 	loadi %a0,E_NotAlloc
01:00001F28 1F200640        	   930: 	pop %a6-%t1
01:00001F2C 1F000448        	   931: 	pop %br1
01:00001F30 1A000024        	   932: 	blr
                            	   933: .0003:
01:00001F34 03300280        	   934: 	cmpi %cr0,%a5,1
01:00001F38 F82D40E1        	   935: 	pne %cr0,.0004
01:00001F3C 4F380080        	   936: 	move %a0,%a6
01:00001F40 5B56FDFF        	   937: 	bl DequeueMsg
01:00001F44 1A66FFFF        	   938: 	b .0005
                            	   939: .0004:
01:00001F48 263A2800        	   940: 	load %a7,MBXMQHead[%a6]
                            	   941: .0005:
                            	   942: 	macUnlockMSGSemaphore
01:00001F4C 2E000000        	     1M 	store %r0,MSGSEMA
                            	   943: .0002:
01:00001F50 03400080        	   944: 	cmpi %cr0,%a7,0
01:00001F54 F92D40E1        	   945: 	pne %cr0,.0006
01:00001F58 44001080        	   946: 	loadi %a0,E_NoMsg
01:00001F5C 1F200640        	   947: 	pop %a6-%t1
01:00001F60 1F000448        	   948: 	pop %br1
01:00001F64 1A000024        	   949: 	blr
                            	   950: .0006:
01:00001F68 03180080        	   951: 	cmpi %cr0,%a2,0
01:00001F6C F82D80E0        	   952: 	peq %cr0,.0013
01:00001F70 66422000        	   953: 	load %t0,MSGD1[%a7]
01:00001F74 870208E0        	   954: 	csrrci %t1,M_SR,0x1C0000	# clear MPRV
01:00001F78 07000CE000001C00	   955: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001F80 33000058        	   956:   sync
01:00001F84 6E1A0000        	   957: 	store %t0,[%a2]						# do the store to the proper address space
01:00001F88 075008E0        	   958: 	csrrw %r0,M_SR,%t1				# restore SR settings
01:00001F8C 33000058        	   959:   sync
                            	   960: .0013:
01:00001F90 03200080        	   961: 	cmpi %cr0,%a3,0
01:00001F94 F92D80E0        	   962: 	peq %cr0,.0014
01:00001F98 66422800        	   963: 	load %t0,MSGD2[%a7]
01:00001F9C 870208E0        	   964: 	csrrci %t1,M_SR,0x1C0000	# clear MPRV
01:00001FA0 07000CE0        	   965: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001FA4 33000058        	   966:   sync
01:00001FA8 6E220000        	   967: 	store %t0,[%a3]						# do the store to the proper address space
01:00001FAC 075008E0        	   968: 	csrrw %r0,M_SR,%t1				# restore SR settings
01:00001FB0 33000058        	   969:   sync
                            	   970: .0014:
01:00001FB4 0328008000001C00	   971: 	cmpi %cr0,%a4,0
01:00001FBC 00001800
01:00001FC0 F92D80E0        	   972: 	peq %cr0,.0015
01:00001FC4 66423000        	   973: 	load %t0,MSGD3[%a7]
01:00001FC8 870208E0        	   974: 	csrrci %t1,M_SR,0x1C0000	# clear MPRV
01:00001FCC 07000CE0        	   975: 	csrrsi %r0,M_SR,0x180000	# select mode from om on stack
01:00001FD0 33000058        	   976:   sync
01:00001FD4 6E2A0000        	   977: 	store %t0,[%a4]						# do the store to the proper address space
01:00001FD8 075008E0        	   978: 	csrrw %r0,M_SR,%t1				# restore SR settings
01:00001FDC 33000058        	   979:   sync
                            	   980: .0015:
01:00001FE0 03300280        	   981: 	cmpi %cr0,%a5,1						# remove msg from que?
01:00001FE4 182D80E0        	   982: 	bne %cr0,.0016
01:00001FE8 4400FEFF        	   983: 	loadi %a0,-1
01:00001FEC 5B84F8FF        	   984: 	bl LockMSGSemaphore
01:00001FF0 992C40E1        	   985: 	beq %cr0,.0016
01:00001FF4 4F40008000001C00	   986: 	move %a0,%a7
01:00001FFC 00001800
01:00002000 5BC8FCFF        	   987: 	bl FreeMsg
                            	   988: 	macUnlockMSGSemaphore
01:00002004 2E000000        	     1M 	store %r0,MSGSEMA
                            	   989: .0016:
01:00002008 44000080        	   990: 	loadi %a0,E_Ok
01:0000200C 1F200240        	   991: 	pop %a6-%t0
01:00002010 1F000448        	   992: 	pop %br1
01:00002014 1A000024        	   993: 	blr
                            	   994: 	# Bad arg return
                            	   995: .0001:
01:00002018 44000280        	   996: 	loadi %a0,E_Arg
01:0000201C 1A000024        	   997: 	blr
                            	   998: 

Source: "Femtikia.qpa"
                            	  1996: .include "../mem_support.qpa"

Source: "..\mem_support.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .set MMU_PFA,0xFFF40000
                            	    38: .set MMU_PTBR,0xFFF40028
                            	    39: .set MMU_VADR,0xFFF40040
                            	    40: .set MMU_PADR,0xFFF40050
                            	    41: .set MMU_PADRV,0xFFF40060
                            	    42: 
                            	    43: # ------------------------------------------------------------------------------
                            	    44: # Clear a page of memory
                            	    45: #
                            	    46: # Parameters:
                            	    47: #		%a0 = pointer to page
                            	    48: # Returns:
                            	    49: #		none
                            	    50: # ------------------------------------------------------------------------------
                            	    51: 
                            	    52: _ClearPage:
01:00002020 1E010040        	    53: 	push %a1-%a2
01:00002024 8F080080        	    54: 	move %a1,%a0
01:00002028 C4080080        	    55: 	addi %a2,%a0,PGSIZE
                            	    56: .0001:
01:0000202C 2E100000        	    57: 	store %r0,[%a1]
01:00002030 84100880        	    58: 	addi %a1,%a1,4
01:00002034 03120600        	    59: 	cmpa %cr0,%a1,%a2
01:00002038 982B56E1        	    60: 	blt .0001
01:0000203C 1F010040        	    61: 	pop %a1-%a2
01:00002040 1A000024        	    62: 	blr
                            	    63: 
                            	    64: # ------------------------------------------------------------------------------
                            	    65: # Search for a memory page that is not used yet. Mark it as in use and return
                            	    66: # the address. The search proceeds 32-bits at a time.
                            	    67: #
                            	    68: # Parameters:
                            	    69: #		none
                            	    70: # Returns:
                            	    71: #		a0 = address of page (zero if no page available)
                            	    72: #		cr0.eq set if no page found, zero otherwise
                            	    73: # ------------------------------------------------------------------------------
                            	    74: 
                            	    75: _FindFreePage:
01:00002044 1E070040        	    76: 	push %a1-%a4		# save %a1 to %a4
01:00002048 440000A0        	    77: 	loadi %a0,_PAM
01:0000204C 84000080        	    78: 	loadi %a1,0
                            	    79: 	# search the PAM 32-bits at a time for a free page
                            	    80: .0002:
01:00002050 E6080000        	    81: 	load %a2,[%a0]		# get alloc status
01:00002054 00190018        	    82: 	cntlo %a3,%a2			# find the first zero
01:00002058 03200000        	    83: 	cmp %cr0,%a3,32		# 32 1's mean all pages in group allocated
01:0000205C F82C40E1        	    84: 	pne %cr0,.0001
01:00002060 44080880        	    85: 	addi %a0,%a0,4			# move to next group
01:00002064 030A04A0        	    86: 	cmpai %cr0,%a0,_PAMend	# end of table?
01:00002068 192B46E1        	    87: 	blt %cr0,.0002
01:0000206C 44000184        	    88: 	loadi. %a0,0			# return zero if no pages available
01:00002070 1F070040        	    89: 	pop %a1-%a4
01:00002074 1A00002400200000	    90: 	blr
01:0000207C 00400000
                            	    91: 	# Here there was a page available
                            	    92: .0001:
01:00002080 0C213E00        	    93: 	subf %a3,%a3,31		# %a3 was 1 to 31
01:00002084 42090800        	    94: 	sll %a4,1,%a3
01:00002088 C9180A00        	    95: 	or %a2,%a2,%a4			# set bit
01:0000208C EE080000        	    96: 	store %a2,[%a0]		# update PAM, mark page used
01:00002090 4C000200        	    97: 	sub %a0,%a0,_PAM	# %a0 = tetra index into PAM
01:00002094 42080A80        	    98: 	slli %a0,%a0,5			# 32 bits per entry
01:00002098 44080800        	    99: 	add %a0,%a0,%a3		# add in bit number, %a0 = page number
01:0000209C 42080880        	   100: 	slli %a0,%a0,4			# size of PMT entry
01:000020A0 44080080        	   101: 	addi %a0,%a0,_PMT
01:000020A4 2B080A00        	   102: 	stwi 1,4[%a0]			# set share count to 1
01:000020A8 2B080E00        	   103: 	stwi 7,[%a0]			# set acr = user, rwx
01:000020AC 44080080        	   104: 	subi %a0,%a0,_PMT
01:000020B0 42081484        	   105: 	slli. %a0,%a0,LOG_PGSZ-4		# convert to address
01:000020B4 1F070040        	   106: 	pop %a1-%a4
01:000020B8 1A000024        	   107: 	blr
                            	   108: 
                            	   109: 
                            	   110: # ------------------------------------------------------------------------------
                            	   111: # Gets the address for the page table entry given the virtual address. Walks
                            	   112: # the page table. Currently assumes a two-level page table.
                            	   113: #
                            	   114: # Side Effects:
                            	   115: # 	Calling this routine may cause a page fault if the address cannot be
                            	   116: #	translated.
                            	   117: #
                            	   118: # Parameters:
                            	   119: #		a0 = virtual address to translate
                            	   120: # Returns:
                            	   121: #		a0 = physical address
                            	   122: # ------------------------------------------------------------------------------
                            	   123: 
                            	   124: _GetPageTableEntryAddress:
01:000020BC 1E1F0040        	   125: 	push %a1-%a6
                            	   126: .0001:
01:000020C0 84011080        	   127: 	loadi %a5,8					# maximum numober of levels of page tables (limits looping)
01:000020C4 A60000A0        	   128: 	load %a1,MMU_PTBR		# %a1 = address of page table
01:000020C8 C2083482        	   129: 	srli %a2,%a0,26				# %a2 = index into root page table
01:000020CC E7110600        	   130: 	loada %a6,[%a1+%a2*4]	# %a6 = PTE address
01:000020D0 26390004        	   131: 	load. %a3,[%a6]				# Get the PTE
01:000020D4 182E88E0        	   132: 	bgt %cr0,.0002				# check valid bit (bit 31)
                            	   133: .0003:
01:000020D8 8431FEFF        	   134: 	addi. %a5,%a5,-1
01:000020DC 192F48E1        	   135: 	ble %cr0,.0005
01:000020E0 42213A82        	   136: 	srli %a4,%a3,29				# Extra PTE type bits
01:000020E4 48290680        	   137: 	andi %a4,%a4,3
01:000020E8 03280480        	   138: 	cmpi %cr0,%a4,2
01:000020EC D92C80E0        	   139: 	bne %cr0,.0004
                            	   140: 	# Type 2 PTE = PTP
01:000020F0 482104A0        	   141: 	andi %a4,%a3,0x1FFFFFFF	# Extract PPN
01:000020F4 42291C802800F4FF	   142: 	slli %a4,%a4,LOG_PGSZ		# Turn into an address
01:000020FC FFFFFF1F
01:00002100 C2081C82        	   143: 	srli %a2,%a0,14					# extract vadr bits 14 to 25
01:00002104 C818FE9F        	   144: 	andi %a2,%a2,0xFFF				# convert to index into page
01:00002108 C2180480        	   145: 	slli %a2,%a2,2						# convert index to page offset
01:0000210C C9180A00        	   146: 	or %a2,%a2,%a4						# %a2 = pointer to entry now
01:00002110 26190000        	   147: 	load %a3,[%a2]					# Load the PTE
01:00002114 CF190080        	   148: 	move %a6,%a2						# %a6 = PTE address
01:00002118 1B4CFFFF        	   149: 	b .0003
                            	   150: 	# Type 1 PTE
                            	   151: .0004:
01:0000211C 4F380080        	   152: 	move %a0,%a6
01:00002120 1F1F0040        	   153: 	pop %a1-%a6
01:00002124 1A000024        	   154: 	blr
                            	   155: 	# invalid PTE? Assign a page.
                            	   156: .0002:
01:00002128 4400FEFF        	   157: 	loadi %a0,-1
01:0000212C 5A2EF8FF        	   158: 	bl LockPMTSemaphore
01:00002130 5A24FFFF        	   159: 	bl _FindFreePage
                            	   160: 	macUnlockPMTSemaphore
01:00002134 2E0000003F000000	     1M 	store %r0,PMTSEMA
01:0000213C 3F000000
01:00002140 03080080        	   161: 	cmpi %cr0,%a0,0				# if page could not be allocated, return NULL pointer
01:00002144 F92B80E0        	   162: 	peq %cr0,.0005
01:00002148 5B14FFFF        	   163: 	bl _ClearPage
                            	   164: 	# set the PTP to point to the page
01:0000214C 42081C82        	   165: 	srli %a0,%a0,LOG_PGSZ
01:00002150 090900A0        	   166: 	ori %a3,%a0,0xC0000000	# set valid bit, and type 2 page
01:00002154 2E390000        	   167: 	store %a3,[%a6]				# update the page table
01:00002158 1B36FFFF        	   168: 	b .0001
                            	   169: .0005:
01:0000215C 44000080        	   170: 	loadi %a0,0
01:00002160 1F1F0040        	   171: 	pop %a1-%a6
01:00002164 1A000024        	   172: 	blr
                            	   173: 
                            	   174: # ------------------------------------------------------------------------------
                            	   175: # Page fault handler. Triggered when there is no translation for a virtual
                            	   176: # address. Allocates a page of memory an puts an entry in the page table for it.
                            	   177: # If the PTP was invalid, then a page is allocated for the page table it points
                            	   178: # to and the PTP entry updated in the page table.
                            	   179: #
                            	   180: # Side Effects:
                            	   181: #		Page table is updated.
                            	   182: # Modifies:
                            	   183: #		none
                            	   184: # Parameters:
                            	   185: #		none - it is an ISR
                            	   186: # Returns:
                            	   187: #		none - it is an ISR
                            	   188: # ------------------------------------------------------------------------------
                            	   189: 
                            	   190: _PageFaultHandlerISR:	
01:00002168 1E000448        	   191: 	push %br1
01:0000216C 9E3F0240        	   192: 	push %a0-%t0				# push %a0 to a7, t0
                            	   193: 	# search the PMT for a free page
01:00002170 4400FEFF        	   194: 	loadi %a0,-1
01:00002174 5A1CF8FF        	   195: 	bl LockPMTSemaphore
01:00002178 5A12FFFF000000C0	   196: 	bl _FindFreePage
01:00002180 F82B40E1        	   197: 	pne %cr0,.0001
                            	   198: 	# Here there are no more free pages
                            	   199: 	macUnlockPMTSemaphore
01:00002184 2E000000        	     1M 	store %r0,PMTSEMA
                            	   200: 	# Here a free page was found
                            	   201: .0001:
                            	   202: 	macUnlockPMTSemaphore
01:00002188 2E000000        	     1M 	store %r0,PMTSEMA
01:0000218C 5A04FFFF        	   203: 	bl _ClearPage
                            	   204: 	# Should add the base address of the memory from the region table
01:00002190 84011080        	   205: 	loadi %a5,8					# maximum numober of levels of page tables (limits looping)
01:00002194 A60000A0        	   206: 	load %a1,MMU_PTBR		# %a1 = address of page table
01:00002198 660204A0        	   207: 	load %t0,MMU_PFA			# t0 = fault address (virtual address)
01:0000219C C2483482        	   208: 	srli %a2,%t0,26				# %a2 = index into root page table
01:000021A0 E7110600        	   209: 	loada %a6,[%a1+%a2*4]	# %a6 = PTE address
01:000021A4 26390004        	   210: 	load. %a3,[%a6]				# Get the PTE
01:000021A8 582D88E0        	   211: 	bgt %cr0,.0002				# check valid bit (bit 31)
                            	   212: .0003:
01:000021AC 42213A82        	   213: 	srli %a4,%a3,29				# Extra PTE type bits
01:000021B0 48290680        	   214: 	andi %a4,%a4,3
01:000021B4 032804802800F4FF	   215: 	cmpi %cr0,%a4,2
01:000021BC 0000F4FF
01:000021C0 982C80E0        	   216: 	bne %cr0,.0002
                            	   217: .0004:
01:000021C4 482100A0        	   218: 	andi %a4,%a3,0x1FFFFFFF	# Extract PPN
01:000021C8 42291C80        	   219: 	slli %a4,%a4,LOG_PGSZ		# Turn into an address
01:000021CC C2481C82        	   220: 	srli %a2,%t0,14					# extract vadr bits 14 to 25
01:000021D0 C818FE9F        	   221: 	andi %a2,%a2,0xFFF				# convert to index into page
01:000021D4 C2180480        	   222: 	slli %a2,%a2,2						# convert index to page offset
01:000021D8 C9190A00        	   223: 	or %a6,%a2,%a4						# %a6 = pointer to entry now
                            	   224: 	# set the PTE to point to the page
01:000021DC 42081C82        	   225: 	srli %a0,%a0,LOG_PGSZ
01:000021E0 4808FEBF        	   226: 	andi %a0,%a0,0x1FFF		# Keep only low order bits of page number
01:000021E4 490804A0        	   227: 	ori %a0,%a0,0x8000E000	# set valid bit, and type 0 page, user, rwx=7
01:000021E8 6E380000        	   228: 	store %a0,[%a6]				# update the page table
01:000021EC 9F3F0240        	   229: 	pop %a0-%t0
01:000021F0 1F000448        	   230: 	pop %br1
01:000021F4 13000004FFFFFF1F	   231: 	rfi
01:000021FC 00E00080
                            	   232: 	# Here the PTP was invalid, so allocate a new page table and set PTP
                            	   233: .0002:
01:00002200 4400FEFF        	   234: 	loadi %a0,-1
01:00002204 5AF8F7FF        	   235: 	bl LockPMTSemaphore
01:00002208 5AEEFEFF        	   236: 	bl _FindFreePage
                            	   237: 	macUnlockPMTSemaphore
01:0000220C 2E000000        	     1M 	store %r0,PMTSEMA
01:00002210 03080000        	   238: 	cmp %cr0,%a0,0
01:00002214 F82B80E0        	   239: 	peq %cr0,.0005
01:00002218 5BE0FEFF        	   240: 	bl _ClearPage
                            	   241: 	# set the PTP to point to the page
01:0000221C 42081C00        	   242: 	srl %a0,%a0,LOG_PGSZ
01:00002220 09090000        	   243: 	or %a3,%a0,0xC0000000	# set valid bit, and type 2 page
01:00002224 2E390000        	   244: 	store %a3,[%a6]				# update the page table
01:00002228 1B3CFFFF        	   245: 	b .0004
                            	   246: 	# Here there was no memory available
                            	   247: .0005:
01:0000222C 9F3F0240        	   248: 	pop %a0-%t0
01:00002230 1F000448        	   249: 	pop %br1
01:00002234 130000043F000000	   250: 	rfi
01:0000223C 3F000000
                            	   251: 

Source: "Femtikia.qpa"
                            	  1997: 
                            	  1998: 


Symbols by name:
ACBCursorCol                     S:00000363
ACBCursorRow                     S:00000362
ACBHandleToPointer              01:00000010
ACBHasFocus                      S:000003C8
ACBMid                          external
ACBNormAttr                      S:00000368
ACBObject                        S:00000000
ACBSEMA                         00:00000000
ACBTask                         external
ACBTaskList                      S:000003C0
ACBVideoCols                     S:00000361
ACBVideoRows                     S:00000360
ACB_SIZE                         S:00004000
ACBmid                           S:000003CA
ACBpVidMem                       S:00000350
CB_XOR                           S:00312345
ConvertVirtualToPhysical        01:000004F8
CopyMsg                         01:000012E4
DecrementTimeout                01:000007E4
DequeTaskFromMbx                01:000014E0
DequeueMsg                      01:0000149C
DispSpace                       01:00001280
DispTwoSpace                    01:00001274
DumpTCBs                        01:00001290
EPC0                             S:00003108
ESR0                             S:00003080
E_Arg                            S:00000001
E_Busy                           S:0000000E
E_Busyed                        external
E_Func                           S:00000002
E_NoMem                          S:0000002E
E_NoMoreMbx                      S:00000028
E_NoMoreMsgBlks                  S:00000029
E_NoMoreTCBs                     S:0000002D
E_NoMsg                          S:00000008
E_NoTask                        external
E_NotAlloc                       S:00000007
E_NotOwner                       S:0000000C
E_Ok                             S:00000000
E_QueFull                        S:00000005
EnvCallBadFunc                  01:00000348
EnvCallHeavy                    01:00000244
EnvCallHeavyBadFunc2            01:00000354
EnvCallHeavyTable               01:00000384
EnvCallLight                    01:00000314
EnvCallLightBadFunc             external
EnvCallLightBadFunc2            01:00000364
EnvCallLightTable               01:00000458
EnvCallMedium                   01:000002C4
EnvCallMediumBadFunc2           01:0000035C
EnvCallMediumTable              01:00000458
EnvCallMediumTableLimit         external
EnvExitHeavy                    01:00000298
EnvExitLight                    01:0000033C
EnvExitMedium                   01:00000300
FMTK_AllocMbx                   01:000015AC
FMTK_AllocTCB                   01:00001150
FMTK_CheckMsg                   01:00001C74
FMTK_ExitTask                   01:00000F2C
FMTK_FreeMbx                    01:00001684
FMTK_FreeTCB                    01:0000116C
FMTK_GetAppTaskId               01:00000630
FMTK_GetCurrentMid              01:000006B4
FMTK_GetCurrentTid              01:000004A4
FMTK_GetMid                     01:000006F8
FMTK_GetRunningTCBPointer       01:00000790
FMTK_GetTaskAppId               01:00000588
FMTK_Init                       01:00001010
FMTK_Initialize                 01:00000490
FMTK_KillTask                   01:00000F30
FMTK_LockSemaphore              01:000000DC
FMTK_PeekMsg                    01:00001C70
FMTK_PostMsg                    01:00001914
FMTK_RetOK                      01:0000036C
FMTK_SendMsg                    01:000017E8
FMTK_SetTaskAppId               01:000005F8
FMTK_SetTaskId                  01:000006A8
FMTK_Sleep                      01:00000D14
FMTK_StartTask                  01:00000E54
FMTK_UnlockSemaphore            01:00000134
FMTK_WaitMsg                    01:00001A3C
FPSR                             S:00000014
FPStateBegin                     S:00000003
FPStateEnd                       S:00000004
FemtikiTimerISR                 01:000008B4
FemtikiVars                      S:FFF80020
FemtikiVars_end                  S:FFF80114
FreeMBX                          S:FFF800D0
FreeMSG                          S:FFF800CC
FreeMsg                         01:00001324
FreeTCB                          S:FFF800C8
GetAppHandle                    external
GetAppMid                       01:00000374
GetCurrentTid                   01:0000049C
GetIRQFlag                      01:00000530
GetRunningACBPointer            01:00000774
GetRunningTCBPointer            01:00000764
GetRunningTCBPtr                external
IAllocTCB                       01:00001134
IFreeMBX                        external
IFreeTCB                        01:00001154
IRQFlag                          S:FFFC0012
InTimerISRFlag                   S:00000001
InitAppOne                      01:000010B4
InitFreeMailboxList             01:00000FB0
InitFreeMessageList             01:00000F80
InitFreeTCBList                 01:00000FE0
InitTaskOne                     01:00001100
InsertIntoReadyQueue            01:00001190
InsertIntoTimeoutList           external
LOG_ACBSZ                        S:0000000E
LOG_PGSZ                         S:0000000E
LOG_TCBSZ                        S:0000000A
LockACBSemaphore                01:000001C8
LockMMUSemaphore                01:000001AC
LockMSGSemaphore                01:00000200
LockPMTSemaphore                01:000001E4
LockSemaphore                   01:00000060
LockSysSemaphore                01:00000190
MAXVPG                          external
MBT_DATA                        external
MBXLink                          S:00000004
MBXMQCount                       S:0000001C
MBXMQHead                        S:00000014
MBXMQMissed                      S:00000024
MBXMQSize                        S:00000020
MBXMQStrategy                    S:00000028
MBXMQTail                        S:00000018
MBXOwner                        external
MBXTQCount                       S:00000010
MBXTQHead                        S:00000008
MBXTQTail                        S:0000000C
MBX_LINK                        external
MBX_SIZE                         S:0000002C
MF                              external
MF_CRLF                         external
MF_DisplayByteAsHex             external
MF_DisplayTetraAsHex            external
MF_IncreaseStackSize            external
MF_OUTCH                        external
MMUSEMA                         00:00000000
MMU_PFA                          S:FFF40000
MMU_PTBR                         S:FFF40028
MMUxPADRV                        S:FFF40060
MMUxPHYSADR                      S:FFF40050
MMUxVIRTADR                      S:FFF40040
MQS_NEWEST                      external
MQS_OLDEST                      external
MQS_UNLIMITED                   external
MSGD1                            S:00000010
MSGD2                            S:00000014
MSGD3                            S:00000018
MSGDEstAdr                      external
MSGDestAdr                       S:00000008
MSGLink                          S:00000000
MSGRetAdr                        S:00000004
MSGSEMA                         00:00000000
MSGType                          S:0000000C
MSG_LINK                        external
MSG_SIZE                         S:0000001C
MT_FREE                         external
MT_NONE                         external
M_SEMA                           S:0000300C
M_SR                             S:00003004
MidStackBottoms                  S:FFF800AC
NR_ACB                          external
NUM_LWENVFUNC                    S:0000000E
NUM_OSFUNC                       S:00000034
OBJMagic                         S:00000000
OSActive                         S:FFF80110
OSCallBadFunc                   external
OSExit                          external
OSSEMA                          00:00000000
PGSIZE                          external
PGSZ                            external
PMTSEMA                         00:00000000
PopTimeoutList                  01:00001234
PrevRunningPointer              external
QueueMsg                        01:0000134C
RDYQ                            external
RemoveFromReadyList             external
RemoveFromReadyQueue            01:000011BC
RemoveFromTimeoutList           01:000011D8
RunningAID                       S:FFF80024
RunningID                        S:FFF80028
SCRATCH                          S:00003041
SR                               S:00003004
SchedulerIRQHelper              01:00000818
SelectTaskToRun                 01:00000D7C
SetIRQFlag                      01:0000057C
SetMbxMsgQueStrategy            01:00001764
SwitchTask                      01:00000974
TBCNext                         external
TCBA                            external
TCBAcbNext                       S:00000350
TCBAffinity                      S:00000314
TCBClearStatusBit               01:00000044
TCBEndTick                       S:000002EC
TCBException                     S:000002FC
TCBHandleToPointer              01:00000000
TCBHasFocus                      S:000002C4
TCBMBQNext                      external
TCBMBQPrev                      external
TCBMBXPrev                      external
TCBMsg                           S:0000039C
TCBNext                          S:00000304
TCBPointerToHandle              01:00000020
TCBPrev                          S:0000030C
TCBPriority                      S:000002BD
TCBPriorty                      external
TCBRsResp                       external
TCBSEMA                         00:00000000
TCBSetStatusBit                 01:00000030
TCBStartTick                     S:000002E4
TCBStatus                        S:000002BC
TCBTicks                         S:000002F4
TCBTimeout                       S:0000031C
TCBTsCmd                         S:00000358
TCBTsCmdParm                     S:00000368
TCBTsResp                        S:00000360
TCB_SIZE                         S:00000400
TCBappid                         S:0000032C
TCBbrk                           S:00000398
TCBhMailboxes                    S:00000370
TCBhWaitMbx                     external
TCBtid                           S:00000324
TCBxA0                           S:00000040
TCBxA1                           S:00000048
TCBxA2                           S:00000050
TCBxA3                           S:00000058
TCBxA4                           S:00000060
TCBxA5                           S:00000068
TCBxA6                           S:00000070
TCBxA7                           S:00000078
TCBxBR1                          S:00000010
TCBxBR2                          S:00000018
TCBxBR3                          S:00000020
TCBxBR4                          S:00000028
TCBxBR5                          S:00000030
TCBxBR6                          S:00000038
TCBxCR0                          S:00000004
TCBxCR1                          S:00000005
TCBxCR2                          S:00000006
TCBxCR3                          S:00000007
TCBxCR4                          S:00000008
TCBxCR5                          S:00000009
TCBxCR6                          S:0000000A
TCBxCR7                          S:0000000B
TCBxF0                           S:00000150
TCBxF1                           S:00000158
TCBxF10                          S:000001A0
TCBxF11                          S:000001A8
TCBxF12                          S:000001B0
TCBxF13                          S:000001B8
TCBxF14                          S:000001C0
TCBxF15                          S:000001C8
TCBxF16                          S:000001D0
TCBxF17                          S:000001D8
TCBxF18                          S:000001E0
TCBxF19                          S:000001E8
TCBxF2                           S:00000160
TCBxF20                          S:000001F0
TCBxF21                          S:000001F8
TCBxF22                          S:00000200
TCBxF23                          S:00000208
TCBxF24                          S:00000210
TCBxF25                          S:00000218
TCBxF26                          S:00000220
TCBxF27                          S:00000228
TCBxF28                          S:00000230
TCBxF29                          S:00000238
TCBxF3                           S:00000168
TCBxF30                          S:00000240
TCBxF31                          S:00000248
TCBxF4                           S:00000170
TCBxF5                           S:00000178
TCBxF6                           S:00000180
TCBxF7                           S:00000188
TCBxF8                           S:00000190
TCBxF9                           S:00000198
TCBxFP                           S:00000128
TCBxFPSR                         S:000002A0
TCBxGP                           S:00000120
TCBxHSP                          S:00000140
TCBxLC                           S:00000148
TCBxPC                           S:00000250
TCBxS0                           S:000000D0
TCBxS1                           S:000000D8
TCBxS2                           S:000000E0
TCBxS3                           S:000000E8
TCBxS4                           S:000000F0
TCBxS5                           S:000000F8
TCBxS6                           S:00000100
TCBxS7                           S:00000108
TCBxS8                           S:00000110
TCBxS9                           S:00000118
TCBxSP                          external
TCBxSR                           S:00000298
TCBxSSP                          S:00000138
TCBxT0                           S:00000080
TCBxT1                           S:00000088
TCBxT2                           S:00000090
TCBxT3                           S:00000098
TCBxT4                           S:000000A0
TCBxT5                           S:000000A8
TCBxT6                           S:000000B0
TCBxT7                           S:000000B8
TCBxT8                           S:000000C0
TCBxT9                           S:000000C8
TCBxUSP                          S:00000130
TCBxXH                           S:00000258
TImeoutList                     external
TSC_ALLOCTCB                     S:00000001
TSC_FREE                        external
TSC_FREETCB                      S:00000002
TSC_SLEEP                        S:00000003
TS_PREEMPT                       S:00000020
TS_READY                         S:00000001
TS_RUNNING                       S:00000080
TS_TIMEOUT                       S:00000010
TS_WAITMSG                       S:00000008
TimeoutList                      S:FFF800D4
XS                               S:00003010
_ClearPage                      01:00001D9C
_FindFreePage                   01:00001DC0
_GetPageTableEntryAddress       01:00001E30
_PAM                             S:00002000
_PAMend                          S:00004000
_PMT                            external
_PageFaultHandlerISR            01:00001ECC
_UnlockACBSemaphore             01:0000022C
_UnlockMMUSemaphore             01:00000224
_UnlockMSGSemaphore             01:0000023C
_UnlockPMTSemaphore             01:00000234
_UnlockSysSemaphore             01:0000021C
acbs                             S:00104000
freeMBX                         external
freeMSG                         external
mailboxes                        S:00684000
mailboxes_end                    S:006E4000
messages                         S:00584000
messages_end                     S:00684000
milliseconds                    external
missed_ticks                    00:00000000
nMailbox                         S:FFF800C0
nMsgBlk                         external
tcb_ends                        external
tcbs                             S:00184000

Symbols by value:
FFF40000 MMU_PFA
FFF40028 MMU_PTBR
FFF40040 MMUxVIRTADR
FFF40050 MMUxPHYSADR
FFF40060 MMUxPADRV
FFF80020 FemtikiVars
FFF80024 RunningAID
FFF80028 RunningID
FFF800AC MidStackBottoms
FFF800C0 nMailbox
FFF800C8 FreeTCB
FFF800CC FreeMSG
FFF800D0 FreeMBX
FFF800D4 TimeoutList
FFF80110 OSActive
FFF80114 FemtikiVars_end
FFFC0012 IRQFlag
00000000 MMUSEMA
00000000 TCBSEMA
00000000 E_Ok
00000000 TCBHandleToPointer
00000000 missed_ticks
00000000 PMTSEMA
00000000 OSSEMA
00000000 ACBSEMA
00000000 OBJMagic
00000000 ACBObject
00000000 MSGSEMA
00000000 MSGLink
00000001 E_Arg
00000001 InTimerISRFlag
00000001 TS_READY
00000001 TSC_ALLOCTCB
00000002 TSC_FREETCB
00000002 E_Func
00000003 TSC_SLEEP
00000003 FPStateBegin
00000004 FPStateEnd
00000004 TCBxCR0
00000004 MBXLink
00000004 MSGRetAdr
00000005 TCBxCR1
00000005 E_QueFull
00000006 TCBxCR2
00000007 TCBxCR3
00000007 E_NotAlloc
00000008 TS_WAITMSG
00000008 TCBxCR4
00000008 MBXTQHead
00000008 E_NoMsg
00000008 MSGDestAdr
00000009 TCBxCR5
0000000A TCBxCR6
0000000A LOG_TCBSZ
0000000B TCBxCR7
0000000C MBXTQTail
0000000C MSGType
0000000C E_NotOwner
0000000E NUM_LWENVFUNC
0000000E LOG_ACBSZ
0000000E E_Busy
0000000E LOG_PGSZ
00000010 ACBHandleToPointer
00000010 TS_TIMEOUT
00000010 MBXTQCount
00000010 TCBxBR1
00000010 MSGD1
00000014 MBXMQHead
00000014 MSGD2
00000014 FPSR
00000018 TCBxBR2
00000018 MBXMQTail
00000018 MSGD3
0000001C MBXMQCount
0000001C MSG_SIZE
00000020 TCBPointerToHandle
00000020 MBXMQSize
00000020 TS_PREEMPT
00000020 TCBxBR3
00000024 MBXMQMissed
00000028 E_NoMoreMbx
00000028 TCBxBR4
00000028 MBXMQStrategy
00000029 E_NoMoreMsgBlks
0000002C MBX_SIZE
0000002D E_NoMoreTCBs
0000002E E_NoMem
00000030 TCBSetStatusBit
00000030 TCBxBR5
00000034 NUM_OSFUNC
00000038 TCBxBR6
00000040 TCBxA0
00000044 TCBClearStatusBit
00000048 TCBxA1
00000050 TCBxA2
00000058 TCBxA3
00000060 TCBxA4
00000060 LockSemaphore
00000068 TCBxA5
00000070 TCBxA6
00000078 TCBxA7
00000080 TS_RUNNING
00000080 TCBxT0
00000088 TCBxT1
00000090 TCBxT2
00000098 TCBxT3
000000A0 TCBxT4
000000A8 TCBxT5
000000B0 TCBxT6
000000B8 TCBxT7
000000C0 TCBxT8
000000C8 TCBxT9
000000D0 TCBxS0
000000D8 TCBxS1
000000DC FMTK_LockSemaphore
000000E0 TCBxS2
000000E8 TCBxS3
000000F0 TCBxS4
000000F8 TCBxS5
00000100 TCBxS6
00000108 TCBxS7
00000110 TCBxS8
00000118 TCBxS9
00000120 TCBxGP
00000128 TCBxFP
00000130 TCBxUSP
00000134 FMTK_UnlockSemaphore
00000138 TCBxSSP
00000140 TCBxHSP
00000148 TCBxLC
00000150 TCBxF0
00000158 TCBxF1
00000160 TCBxF2
00000168 TCBxF3
00000170 TCBxF4
00000178 TCBxF5
00000180 TCBxF6
00000188 TCBxF7
00000190 LockSysSemaphore
00000190 TCBxF8
00000198 TCBxF9
000001A0 TCBxF10
000001A8 TCBxF11
000001AC LockMMUSemaphore
000001B0 TCBxF12
000001B8 TCBxF13
000001C0 TCBxF14
000001C8 TCBxF15
000001C8 LockACBSemaphore
000001D0 TCBxF16
000001D8 TCBxF17
000001E0 TCBxF18
000001E4 LockPMTSemaphore
000001E8 TCBxF19
000001F0 TCBxF20
000001F8 TCBxF21
00000200 TCBxF22
00000200 LockMSGSemaphore
00000208 TCBxF23
00000210 TCBxF24
00000218 TCBxF25
0000021C _UnlockSysSemaphore
00000220 TCBxF26
00000224 _UnlockMMUSemaphore
00000228 TCBxF27
0000022C _UnlockACBSemaphore
00000230 TCBxF28
00000234 _UnlockPMTSemaphore
00000238 TCBxF29
0000023C _UnlockMSGSemaphore
00000240 TCBxF30
00000244 EnvCallHeavy
00000248 TCBxF31
00000250 TCBxPC
00000258 TCBxXH
00000298 TCBxSR
00000298 EnvExitHeavy
000002A0 TCBxFPSR
000002BC TCBStatus
000002BD TCBPriority
000002C4 EnvCallMedium
000002C4 TCBHasFocus
000002E4 TCBStartTick
000002EC TCBEndTick
000002F4 TCBTicks
000002FC TCBException
00000300 EnvExitMedium
00000304 TCBNext
0000030C TCBPrev
00000314 EnvCallLight
00000314 TCBAffinity
0000031C TCBTimeout
00000324 TCBtid
0000032C TCBappid
0000033C EnvExitLight
00000348 EnvCallBadFunc
00000350 TCBAcbNext
00000350 ACBpVidMem
00000354 EnvCallHeavyBadFunc2
00000358 TCBTsCmd
0000035C EnvCallMediumBadFunc2
00000360 ACBVideoRows
00000360 TCBTsResp
00000361 ACBVideoCols
00000362 ACBCursorRow
00000363 ACBCursorCol
00000364 EnvCallLightBadFunc2
00000368 TCBTsCmdParm
00000368 ACBNormAttr
0000036C FMTK_RetOK
00000370 TCBhMailboxes
00000374 GetAppMid
00000384 EnvCallHeavyTable
00000398 TCBbrk
0000039C TCBMsg
000003C0 ACBTaskList
000003C8 ACBHasFocus
000003CA ACBmid
00000400 TCB_SIZE
00000458 EnvCallLightTable
00000458 EnvCallMediumTable
00000490 FMTK_Initialize
0000049C GetCurrentTid
000004A4 FMTK_GetCurrentTid
000004F8 ConvertVirtualToPhysical
00000530 GetIRQFlag
0000057C SetIRQFlag
00000588 FMTK_GetTaskAppId
000005F8 FMTK_SetTaskAppId
00000630 FMTK_GetAppTaskId
000006A8 FMTK_SetTaskId
000006B4 FMTK_GetCurrentMid
000006F8 FMTK_GetMid
00000764 GetRunningTCBPointer
00000774 GetRunningACBPointer
00000790 FMTK_GetRunningTCBPointer
000007E4 DecrementTimeout
00000818 SchedulerIRQHelper
000008B4 FemtikiTimerISR
00000974 SwitchTask
00000D14 FMTK_Sleep
00000D7C SelectTaskToRun
00000E54 FMTK_StartTask
00000F2C FMTK_ExitTask
00000F30 FMTK_KillTask
00000F80 InitFreeMessageList
00000FB0 InitFreeMailboxList
00000FE0 InitFreeTCBList
00001010 FMTK_Init
000010B4 InitAppOne
00001100 InitTaskOne
00001134 IAllocTCB
00001150 FMTK_AllocTCB
00001154 IFreeTCB
0000116C FMTK_FreeTCB
00001190 InsertIntoReadyQueue
000011BC RemoveFromReadyQueue
000011D8 RemoveFromTimeoutList
00001234 PopTimeoutList
00001274 DispTwoSpace
00001280 DispSpace
00001290 DumpTCBs
000012E4 CopyMsg
00001324 FreeMsg
0000134C QueueMsg
0000149C DequeueMsg
000014E0 DequeTaskFromMbx
000015AC FMTK_AllocMbx
00001684 FMTK_FreeMbx
00001764 SetMbxMsgQueStrategy
000017E8 FMTK_SendMsg
00001914 FMTK_PostMsg
00001A3C FMTK_WaitMsg
00001C70 FMTK_PeekMsg
00001C74 FMTK_CheckMsg
00001D9C _ClearPage
00001DC0 _FindFreePage
00001E30 _GetPageTableEntryAddress
00001ECC _PageFaultHandlerISR
00002000 _PAM
00003004 M_SR
00003004 SR
0000300C M_SEMA
00003010 XS
00003041 SCRATCH
00003080 ESR0
00003108 EPC0
00004000 _PAMend
00004000 ACB_SIZE
00104000 acbs
00184000 tcbs
00312345 CB_XOR
00584000 messages
00684000 messages_end
00684000 mailboxes
006E4000 mailboxes_end
