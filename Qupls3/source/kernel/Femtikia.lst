Sections:
00: ".data" (0-1C)
01: ".text" (0-1DBC)


Source: "Femtikia.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .include "../inc/config.qpa"

Source: "..\inc\config.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # These constants are used in the code.
                            	    38: # They are not used by the variable declarations. The varible declarations
                            	    39: # will have to updated to match these constants.
                            	    40: 
                            	    41: .set MAX_TID,4095
                            	    42: .set NR_TCB,4095
                            	    43: # number of tasks allowed
                            	    44: .set NTASK,4095
                            	    45: # TCB size in bits of address space    		
                            	    46: .set LOG_TCBSZ,10
                            	    47: # MMU page size			
                            	    48: .set LOG_PGSZ,14
                            	    49: # ACB size in bits of address space			
                            	    50: .set LOG_ACBSZ,14
                            	    51: # pages of memory dedicated to OS			
                            	    52: .set OSPAGES,512
                            	    53: # size of a page of memory			
                            	    54: .set PAGESZ,16384
                            	    55: # number of pages of memory  		
                            	    56: .set MEMSZ,65536
                            	    57: # number of block pointer entries   		
                            	    58: .set MBX_BLOCKPTR_BUFSZ,8 	
                            	    59: # number of messages available
                            	    60: .set NR_MSG,32768
                            	    61: # number of mailboxes			
                            	    62: .set NR_MBX,16384			
                            	    63: 
                            	    64: 
                            	    65: 

Source: "Femtikia.qpa"
                            	    38: .include "../inc/const.qpa"

Source: "..\inc\const.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # task states
                            	    38: .set TS_NONE,0
                            	    39: .set TS_READY,1
                            	    40: .set TS_DEAD,2
                            	    41: .set TS_MSGRDY,4
                            	    42: .set TS_WAITMSG,8
                            	    43: .set TS_TIMEOUT,16
                            	    44: .set TS_PREEMPT,32
                            	    45: .set TS_RUNNING,128
                            	    46: 
                            	    47: # Comamnds to the timer ISR
                            	    48: .set TSC_NONE,0
                            	    49: .set TSC_ALLOCTCB,1
                            	    50: .set TSC_FREETCB,2
                            	    51: .set TSC_SLEEP,3
                            	    52: 
                            	    53: # error codes
                            	    54: .set E_Ok,00
                            	    55: .set E_Arg,01
                            	    56: .set E_Func,02
                            	    57: .set E_BadMbx,4
                            	    58: .set E_QueFull,5
                            	    59: .set E_NoThread,6
                            	    60: .set E_NotAlloc,7
                            	    61: .set E_NoMsg,8
                            	    62: .set E_Timeout,10
                            	    63: .set E_BadAlarm,11
                            	    64: .set E_NotOwner,12
                            	    65: .set E_QueStrategy,13
                            	    66: .set E_Busy,14
                            	    67: .set E_DCBInUse,19
                            	    68: # Device driver errors
                            	    69: .set E_BadDevNum,20
                            	    70: .set E_NoDev,21
                            	    71: .set E_BadDevOp,22
                            	    72: .set E_ReadError,23
                            	    73: .set E_WriteError,24
                            	    74: .set E_BadBlockNum,25
                            	    75: .set E_TooManyBlocks,26
                            	    76: 
                            	    77: # resource errors
                            	    78: .set E_NoMoreMbx,40
                            	    79: .set E_NoMoreMsgBlks,41
                            	    80: .set E_NoMoreAlarmBlks,44
                            	    81: .set E_NoMoreTCBs,45
                            	    82: .set E_NoMem,46
                            	    83: 
                            	    84: # codes for CSR registers in the CPU
                            	    85: .set M_SR,0x3004
                            	    86: .set M_SEMA,0x300C
                            	    87: 

Source: "Femtikia.qpa"
                            	    39: .include "../inc/types.qpa"

Source: "..\inc\types.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Stratford
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .set OBJMagic,0
                            	    38: .set OBJSize,4
                            	    39: .set OBJTypenum,8
                            	    40: .set OBJID,12
                            	    41: # WHITE, GREY, BLACK
                            	    42: .set OBJStat,16 
                            	    43: # scavange count   		
                            	    44: .set OBJScavcnt,20    
                            	    45: .set OBJOwningMap,24
                            	    46: .set OBJCollectionIndex,28
                            	    47: # used in map
                            	    48: .set OBJUsedInMap,32
                            	    49: # forwarding address  
                            	    50: .set OBJFWAddr,36    	
                            	    51: .set OBJFinalizer,40
                            	    52: .set OBJ_SIZE,44
                            	    53: 
                            	    54: # Task Control Block
                            	    55: # integer register set storage area
                            	    56: .set TCBIntRegs,000    
                            	    57: # Condition Registers
                            	    58: .set TCBxCR0,4
                            	    59: .set TCBxCR1,5
                            	    60: .set TCBxCR2,6
                            	    61: .set TCBxCR3,7
                            	    62: .set TCBxCR4,8
                            	    63: .set TCBxCR5,9
                            	    64: .set TCBxCR6,10
                            	    65: .set TCBxCR7,11
                            	    66: # Branch Registers
                            	    67: .set TCBxBR1,16
                            	    68: .set TCBxBR2,24
                            	    69: .set TCBxBR3,32
                            	    70: .set TCBxBR4,40
                            	    71: .set TCBxBR5,48
                            	    72: .set TCBxBR6,56
                            	    73: # Fixed point registers
                            	    74: .set TCBxA0,64
                            	    75: .set TCBxA1,72
                            	    76: .set TCBxA2,80
                            	    77: .set TCBxA3,88
                            	    78: .set TCBxA4,96
                            	    79: .set TCBxA5,104
                            	    80: .set TCBxA6,112
                            	    81: .set TCBxA7,120
                            	    82: .set TCBxT0,128
                            	    83: .set TCBxT1,136
                            	    84: .set TCBxT2,144
                            	    85: .set TCBxT3,152
                            	    86: .set TCBxT4,160
                            	    87: .set TCBxT5,168
                            	    88: .set TCBxT6,176
                            	    89: .set TCBxT7,184
                            	    90: .set TCBxT8,192
                            	    91: .set TCBxT9,200
                            	    92: .set TCBxS0,208
                            	    93: .set TCBxS1,216
                            	    94: .set TCBxS2,224
                            	    95: .set TCBxS3,232
                            	    96: .set TCBxS4,240
                            	    97: .set TCBxS5,248
                            	    98: .set TCBxS6,256
                            	    99: .set TCBxS7,264
                            	   100: .set TCBxS8,272
                            	   101: .set TCBxS9,280
                            	   102: .set TCBxGP,288
                            	   103: .set TCBxFP,296
                            	   104: # Stack pointers
                            	   105: .set TCBxUSP,304
                            	   106: .set TCBxSSP,312
                            	   107: .set TCBxHSP,320
                            	   108: # Loop Counter
                            	   109: .set TCBxLC,328
                            	   110: # Floating-point registers
                            	   111: .set TCBxF0,336
                            	   112: .set TCBxF1,344
                            	   113: .set TCBxF2,352
                            	   114: .set TCBxF3,360
                            	   115: .set TCBxF4,368
                            	   116: .set TCBxF5,376
                            	   117: .set TCBxF6,384
                            	   118: .set TCBxF7,392
                            	   119: .set TCBxF8,400
                            	   120: .set TCBxF9,408
                            	   121: .set TCBxF10,416
                            	   122: .set TCBxF11,424
                            	   123: .set TCBxF12,432
                            	   124: .set TCBxF13,440
                            	   125: .set TCBxF14,448
                            	   126: .set TCBxF15,456
                            	   127: .set TCBxF16,464
                            	   128: .set TCBxF17,472
                            	   129: .set TCBxF18,480
                            	   130: .set TCBxF19,488
                            	   131: .set TCBxF20,496
                            	   132: .set TCBxF21,504
                            	   133: .set TCBxF22,512
                            	   134: .set TCBxF23,520
                            	   135: .set TCBxF24,528
                            	   136: .set TCBxF25,536
                            	   137: .set TCBxF26,544
                            	   138: .set TCBxF27,552
                            	   139: .set TCBxF28,560
                            	   140: .set TCBxF29,568
                            	   141: .set TCBxF30,576
                            	   142: .set TCBxF31,584
                            	   143: .set TCBxPC,592
                            	   144: .set TCBxXH,600
                            	   145: # Status registers
                            	   146: .set TCBxSR,664
                            	   147: .set TCBxFPSR,672
                            	   148: # OS
                            	   149: .set TCBStatus,700
                            	   150: .set TCBPriority,701
                            	   151: .set TCBWaitMbx,704
                            	   152: .set TCBHasFocus,708
                            	   153: .set TCBStackBot,712
                            	   154: .set TCBMsgD1,716
                            	   155: .set TCBMsgD2,724
                            	   156: .set TCBMsgD3,732
                            	   157: .set TCBStartTick,740
                            	   158: .set TCBEndTick,748
                            	   159: .set TCBTicks,756
                            	   160: .set TCBException,764
                            	   161: .set TCBNext,772
                            	   162: .set TCBPrev,780
                            	   163: .set TCBAffinity,788
                            	   164: .set TCBTimeout,796
                            	   165: .set TCBtid,804
                            	   166: .set TCBmid,808
                            	   167: .set TCBappid,812
                            	   168: .set TCBOpMode,816
                            	   169: .set TCBMbxNext,824
                            	   170: .set TCBMbxPrev,832
                            	   171: .set TCBTaskNum,840
                            	   172: .set TCBAcbNext,848
                            	   173: .set TCBAcbPrev,852
                            	   174: .set TCBTsCmd,856
                            	   175: .set TCBTsResp,864
                            	   176: .set TCBTsCmdParm,872
                            	   177: # room for 10 mailbox handles
                            	   178: .set TCBhMailboxes,880	
                            	   179: # memoey brk point
                            	   180: .set TCBbrk,920					
                            	   181: .set TCBMsg,924
                            	   182: # room for 32 16-bit characters
                            	   183: .set TCBName,952				
                            	   184: .set TCB_SIZE,1024
                            	   185: 
                            	   186: # Application Control Block
                            	   187: .set ACBObject,0
                            	   188: .set ACBNumTask,66
                            	   189: .set ACBStackSize,72
                            	   190: .set ACBpData,80
                            	   191: .set ACBDataSize,88
                            	   192: .set ACBpUIData,96
                            	   193: .set ACBUIDataSize,104
                            	   194: .set ACBGCRoots,112
                            	   195: .set ACBGCRootCnt,120
                            	   196: .set ACBGCNdx,128
                            	   197: .set ACBGCMarkingQue,136
                            	   198: .set ACBGCMarkingQueFull,144
                            	   199: .set ACBGCMarkingQueEmpty,145
                            	   200: .set ACBGCOverflow,146
                            	   201: .set ACBpCode,152
                            	   202: .set ACBObjectList,160
                            	   203: .set ACBGarbageList,168
                            	   204: # 640+ bytes for heap object info
                            	   205: .set ACBHeap,176   				
                            	   206: .set ACBiofNext,824
                            	   207: .set ACBiofPrev,832
                            	   208: # 2 byte index of string in string area
                            	   209: .set ACBUserName,840 
                            	   210: # 2 byte index of string in string area  		
                            	   211: .set ACBPath,842
                            	   212: # 2 byte index of string in string area   				
                            	   213: .set ACBExitRunFile,844
                            	   214: # 2 byte index of string in string area 	
                            	   215: .set ACBCommandLine,846 	
                            	   216: .set ACBpVidMem,848
                            	   217: .set ACBpVirtVidMem,856
                            	   218: .set ACBVideoRows,864
                            	   219: .set ACBVideoCols,865
                            	   220: .set ACBCursorRow,866
                            	   221: .set ACBCursorCol,867
                            	   222: .set ACBNormAttr,872
                            	   223: .set ACBKeyState1,880
                            	   224: .set ACBKeyState2,882
                            	   225: .set ACBKeybdWaitFlag,884
                            	   226: .set ACBKeybdHead,886
                            	   227: .set ACBKeybdTail,887
                            	   228: .set ACBKeybdBuffer,888
                            	   229: .set ACBnumber,944
                            	   230: .set ACBNext,952
                            	   231: .set ACBTaskList,960
                            	   232: .set ACBHasFocus,968
                            	   233: .set ACBmid,970
                            	   234: .set ACBStatus,972
                            	   235: # 256 * 8 bytes reserved for template pointers
                            	   236: .set ACBTemplates,984   	
                            	   237: .set ACBPad,3032
                            	   238: # start of 1kB string area
                            	   239: .set ACBStrings,3072
                            	   240: # 8kB Text screen  		
                            	   241: .set ACBVTextScreen,8192	
                            	   242: .set ACBEnd,16384
                            	   243: .set ACB_SIZE,16384
                            	   244: 
                            	   245: # Application startup record
                            	   246: .set ASRPageSize,0
                            	   247: .set ASRPriority,1
                            	   248: .set ASRRegset,2
                            	   249: .set ASRmid,3
                            	   250: .set ASRAffinity,4
                            	   251: .set ASRCodeSize,8
                            	   252: .set ASRDataSize,16
                            	   253: .set ASRUIDataSize,24
                            	   254: .set ASRHeapSize,32
                            	   255: .set ASRStackSize,40
                            	   256: .set ASRpCode,48
                            	   257: .set ASRpData,56
                            	   258: .set ASRpUIData,64
                            	   259: .set ASR_SIZE,72
                            	   260: 
                            	   261: # tid of owning task
                            	   262: .set MBX_OWNER,0	
                            	   263: #MBX_WTIDS			equ		4		; tasks waiting at mailbox
                            	   264: .set MBXLink,4
                            	   265: # link field for free list shared with task queue head
                            	   266: .set MBXTQHead,8	
                            	   267: .set MBXTQTail,12
                            	   268: .set MBXTQCount,16
                            	   269: .set MBXMQHead,20
                            	   270: .set MBXMQTail,24
                            	   271: .set MBXMQCount,28
                            	   272: .set MBXMQSize,32
                            	   273: .set MBXMQMissed,36
                            	   274: .set MBXMQStrategy,40
                            	   275: .set MBX_SIZE,44
                            	   276: 
                            	   277: .set MSGLink,0
                            	   278: .set MSGRetAdr,4
                            	   279: .set MSGDestAdr,8
                            	   280: .set MSGType,12
                            	   281: .set MSGD1,16
                            	   282: .set MSGD2,20
                            	   283: .set MSGD3,24
                            	   284: .set MSG_SIZE,28
                            	   285: 
                            	   286: .set PMT_SIZE,64
                            	   287: 
                            	   288: 

Source: "Femtikia.qpa"
                            	    40: #include "../inc/io_equates.qpa"
                            	    41: .include "./Femtiki_vars.qpa"

Source: ".\Femtiki_vars.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: # These OS structures and variables are statically allocatedfor now until the
                            	    38: # the OS is in a better working state.
                            	    39: # 65536 bits (8kB)
                            	    40: 	.data
                            	    41: 
                            	    42: .set _PAM,0x00002000										
                            	    43: .set _PAMend,0x00004000
                            	    44: # 65536 16B PMTEs
                            	    45: .set _PageManagementTable,0x00004000		
                            	    46: .set _PageManagementTableEnd,0x00104000
                            	    47: .set acbs,0x00104000
                            	    48: # 32 16kB ACBs
                            	    49: .set acbs_end,0x00184000			
                            	    50: .set tcbs,0x00184000
                            	    51: # 4096 1kB TCBs
                            	    52: .set tcbs_end,0x00584000			
                            	    53: .set messages,0x00584000
                            	    54: # 32768 32B MSGs
                            	    55: .set messages_end,0x00684000	
                            	    56: .set mailboxes,0x00684000
                            	    57: # 16384 34B MBXs
                            	    58: .set mailboxes_end,0x006E4000	
                            	    59: 
                            	    60: .set sys_stacks,0xFFFB0000
                            	    61: .set FemtikiVars,0xFFF80020
                            	    62: .set PAMLastAllocate2,0xFFF80020
                            	    63: .set RunningAID,0xFFF80024
                            	    64: .set RunningID,0xFFF80028
                            	    65: .set ACBPtrs,0xFFF8002C
                            	    66: .set MidStackBottoms,0xFFF800AC
                            	    67: .set FemtikiInited,0xFFF800B0
                            	    68: #.set missed_ticks,0xFFF800B4
00:00000000 00000000        	    69: 	.4byte missed_ticks
00:00000004 00000000        	    70: 	.4byte OSSEMA
00:00000008 00000000        	    71: 	.4byte MSGSEMA
00:0000000C 00000000        	    72: 	.4byte TCBSEMA
00:00000010 00000000        	    73: 	.4byte MMUSEMA
00:00000014 00000000        	    74: 	.4byte ACBSEMA
00:00000018 00000000        	    75: 	.4byte PMTSEMA 
                            	    76: .set IOFocusList,0xFFF800B8
                            	    77: .set IOFocusID,0xFFF800B9
                            	    78: .set iof_switch,0xFFF800BA
                            	    79: .set nMessage,0xFFF800BC
                            	    80: .set nMailbox,0xFFF800C0
                            	    81: .set FreeACB,0xFFF800C4
                            	    82: .set FreeTCB,0xFFF800C8
                            	    83: .set FreeMSG,0xFFF800CC
                            	    84: .set FreeMBX,0xFFF800D0
                            	    85: .set TimeoutList,0xFFF800D4
                            	    86: .set hKeybdMbx,0xFFF800D8
                            	    87: .set hFocusSwitchMbx,0xFFF800DC
                            	    88: .set BIOS_RespMbx,0xFFF800E0
                            	    89: .set hasUltraHighPriorityTasks,0xFFF800E4
                            	    90: .set im_save,0xFFF800E8
                            	    91: .set sp_tmp,0xFFF800EC
                            	    92: .set readyQ,0xFFF800F0
                            	    93: .set readyQTail,0xFFF800F4
                            	    94: .set NPAGES,0xFFF800F8
                            	    95: .set syspages,0xFFF800FC
                            	    96: .set mmu_FreeMaps,0xFFF80100
                            	    97: .set mmu_entries,0xFFF80104
                            	    98: .set freelist,0xFFF80108
                            	    99: .set hSearchMap,0xFFF8010C
                            	   100: .set OSActive,0xFFF80110
                            	   101: .set FemtikiVars_end,0xFFF80114
                            	   102: 
                            	   103: #gc_stack		rmb		512
                            	   104: #gc_pc				fcdw		0
                            	   105: #gc_omapno		fcw			0
                            	   106: #gc_mapno		fcw			0
                            	   107: #gc_dl				fcw			0
                            	   108: 

Source: "Femtikia.qpa"
                            	    42: 
                            	    43: .set IRQFlag,0xFFFC0012
                            	    44: .set InTimerISRFlag,1
                            	    45: 
                            	    46: .set MMUxVIRTADR,0xFFF40040
                            	    47: .set MMUxPHYSADR,0xFFF40050
                            	    48: .set MMUxPADRV,0xFFF40060
                            	    49: 
                            	    50: .set CB_XOR,0x00312345
                            	    51: .set ESR0,0x3080
                            	    52: .set EPC0,0x3108
                            	    53: .set FPStateBegin,3
                            	    54: .set FPStateEnd,4
                            	    55: 
                            	    56: 	.text
                            	    57: 
                            	    58: #------------------------------------------------------------------------------
                            	    59: # Convert a TCB handle into a pointer to the corresponding TCB.
                            	    60: # The handle is just the address for the TCB shifted right and XOR'd to
                            	    61: # randomize it. Got to be simple and turned into a .macro for performance
                            	    62: # reasons. So, it is just a matter of reversing the steps.
                            	    63: #------------------------------------------------------------------------------
                            	    64: 
                            	    65: .macro macTCBHandleToPointer
                            	    66: 	xori %a0,%a0,CB_XOR
                            	    67: 	slli %a0,%a0,LOG_TCBSZ
                            	    68: .endm
                            	    69: 
                            	    70: TCBHandleToPointer:
01:00000000 4408FE7F        	    71: 	subi %a0,%a0,1
01:00000004 42081400        	    72: 	slli %a0,%a0,LOG_TCBSZ
01:00000008 440800A0        	    73: 	addi %a0,%a0,tcbs
01:0000000C 1B00FE87        	    74: 	blr
                            	    75: 
                            	    76: #------------------------------------------------------------------------------
                            	    77: # Convert an ACB handle into a pointer to the corresponding ACB.
                            	    78: # Handles vary from 1 to 32.
                            	    79: #------------------------------------------------------------------------------
                            	    80: 
                            	    81: .macro macACBHandleToPointer
                            	    82: 	xori %a0,%a0,CB_XOR
                            	    83: 	slli %a0,%a0,LOG_ACBSZ
                            	    84: .endm
                            	    85: 
                            	    86: ACBHandleToPointer:
01:00000010 4408FE7F        	    87: 	subi %a0,%a0,1
01:00000014 42081C00        	    88: 	slli %a0,%a0,LOG_ACBSZ
01:00000018 440804A0        	    89: 	addi %a0,%a0,acbs
01:0000001C 1B00FE87        	    90: 	blr
                            	    91: 
                            	    92: #------------------------------------------------------------------------------
                            	    93: # Convert a TCB pointer into a handle for the TCB.
                            	    94: #------------------------------------------------------------------------------
                            	    95: 
                            	    96: .macro macTCBPointerToHandle
                            	    97: 	srli %a0,%a0,LOG_TCBSZ
                            	    98: 	xori %a0,%a0,CB_XOR
                            	    99: .endm
                            	   100: 
                            	   101: TCBPointerToHandle:
01:00000020 440808A0        	   102: 	subi %a0,%a0,tcbs
01:00000024 42580010        	   103: 	srli %a0,%a0,LOG_TCBSZ
01:00000028 44080200        	   104: 	addi %a0,%a0,1
01:0000002C 1B00FE87        	   105: 	blr
                            	   106: 
                            	   107: .macro macACBPointerToHandle
                            	   108: 	srli %a0,%a0,LOG_ACBSZ
                            	   109: 	xori %a0,%a0,CB_XOR
                            	   110: .endm
                            	   111: 
                            	   112: #------------------------------------------------------------------------------
                            	   113: # Set the TCB status in an atomic fasion.
                            	   114: # There is no error checking on the handle for performance reasons.
                            	   115: # This function is called by the OS and assumes it has valid parameters.
                            	   116: #
                            	   117: # Side effects
                            	   118: #		TCB status updated
                            	   119: # Registers Affected
                            	   120: #		a0: converted from handle to pointer
                            	   121: #		%br2: used to stack the return address
                            	   122: # Parameters
                            	   123: #		a0 = handle of TCB to set status of
                            	   124: #		a1 = status to set
                            	   125: # Returns:
                            	   126: #		none
                            	   127: #------------------------------------------------------------------------------
                            	   128: 
                            	   129: .macro macTCBSetStatusBit
                            	   130: 	macTCBHandleToPointer
                            	   131: 	amoor %r0,%a1,TCBStatus[%a0]
                            	   132: .endm
                            	   133: 
                            	   134: TCBSetStatusBit:
                            	   135: 	macTCBHandleToPointer
01:00000030 4A080CA000401800	     1M 	xori %a0,%a0,CB_XOR
01:00000038 0040100000C0E7FF
01:00000040 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000044 3B18C0A2        	   136: 	amoor %r0,%a1,TCBStatus[%a0]
01:00000048 1B00FE87        	   137: 	blr
                            	   138: 
                            	   139: #------------------------------------------------------------------------------
                            	   140: # Clear the TCB status in an atomic fasion.
                            	   141: #
                            	   142: # Side effects
                            	   143: #		TCB status updated
                            	   144: # Registers Affected
                            	   145: #		a0: converted from handle to pointer
                            	   146: #		%br2: used to stack the return address
                            	   147: # Parameters
                            	   148: #		a0 = handle of TCB to clear status of
                            	   149: #		a1 = status to clear
                            	   150: #------------------------------------------------------------------------------
                            	   151: 
                            	   152: .macro macTCBClearStatusBit
                            	   153: 	macTCBHandleToPointer
                            	   154: 	xori %a1,%a1,-1
                            	   155: 	amoand %r0,%a1,TCBStatus[%a0]
                            	   156: 	xori %a1,%a1,-1
                            	   157: .endm
                            	   158: 
                            	   159: TCBClearStatusBit:
                            	   160: 	macTCBHandleToPointer
01:0000004C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000050 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000054 8A1008A0        	   161: 	xori %a1,%a1,-1
01:00000058 3B18CCA1        	   162: 	amoand %r0,%a1,TCBStatus[%a0]
01:0000005C 8A1008A0        	   163: 	xori %a1,%a1,-1
01:00000060 1B00FE87        	   164: 	blr
                            	   165: 
                            	   166: #------------------------------------------------------------------------------
                            	   167: # Lock a semaphore.
                            	   168: # The id of the currently running task is used as the semaphore value. A task
                            	   169: # id is always one or greater. So, a value of zero for the semaphore means
                            	   170: # it is available. This function accepts a timeout argument which allows the
                            	   171: # loop attempting to set the semaphore to be aborted after the timeout.
                            	   172: #
                            	   173: # Parameters:
                            	   174: #		a0 = number of retry attempts
                            	   175: #		%a1 = semaphore variable address
                            	   176: #	Returns:
                            	   177: #		a0 = 1 if lock successful, 0 otherwise
                            	   178: #------------------------------------------------------------------------------
                            	   179: 
                            	   180: LockSemaphore:
01:00000064 1E020040        	   181: 	push %a2				# push %a2
01:00000068 E6000CA0        	   182: 	load %a2,RunningID
                            	   183: .0002:
01:0000006C 4408FE7FBC020000	   184: 	addi. %a0,%a0,-1
01:00000074 45233100FFFFFFFF
01:0000007C 2800F8FF
01:00000080 D93F40E1        	   185: 	beq	%cr0,.0001
01:00000084 3B18C1A6        	   186: 	amoswap. %r0,%a2,[%a1]
01:00000088 D83E80E0        	   187: 	bne	%cr0,.0002
01:0000008C 1F020040        	   188: 	pop %a2
01:00000090 44000204        	   189: 	loadi. %a0,1
01:00000094 1B00FE87        	   190: 	blr
                            	   191: .0001:
01:00000098 1F020040        	   192: 	pop %a2					# 
01:0000009C 44000004        	   193: 	loadi. %a0,0		# set %cr0
01:000000A0 1B00FE87        	   194: 	blr
                            	   195: 
                            	   196: #------------------------------------------------------------------------------
                            	   197: # Lock the system semaphore.
                            	   198: #
                            	   199: # Parameters:
                            	   200: #		a0 = number of retry attempts
                            	   201: #	Returns:
                            	   202: #		a0 = 1 if lock successful, 0 otherwise
                            	   203: #------------------------------------------------------------------------------
                            	   204: 
                            	   205: LockSysSemaphore:
01:000000A4 1E000448        	   206: 	push %br1						# push br1
01:000000A8 1E010040        	   207: 	push %a1
01:000000AC 84000000        	   208: 	loadi %a1,OSSEMA
01:000000B0 5AEAFF7F        	   209: 	bl LockSemaphore		# this will setup a0 and %cr0
01:000000B4 1F010040        	   210: 	pop %a1
01:000000B8 1F00044800000000	   211: 	pop %br1
01:000000C0 1B00FE87        	   212: 	blr
                            	   213: 
                            	   214: #------------------------------------------------------------------------------
                            	   215: # Lock the MMU semaphore.
                            	   216: #
                            	   217: # Parameters:
                            	   218: #		a0 = number of retry attempts
                            	   219: #	Returns:
                            	   220: #		a0 = 1 if lock successful, 0 otherwise
                            	   221: #------------------------------------------------------------------------------
                            	   222: 
                            	   223: LockMMUSemaphore:
01:000000C4 1E000448        	   224: 	push %br1						# push br1
01:000000C8 1E010040        	   225: 	push %a1
01:000000CC 84000000        	   226: 	loadi %a1,MMUSEMA
01:000000D0 5AE2FF7F        	   227: 	bl LockSemaphore
01:000000D4 1F010040        	   228: 	pop %a1
01:000000D8 1F000448        	   229: 	pop %br1
01:000000DC 1B00FE87        	   230: 	blr
                            	   231: 
                            	   232: #------------------------------------------------------------------------------
                            	   233: # Lock the ACB semaphore.
                            	   234: #
                            	   235: # Parameters:
                            	   236: #		a0 = number of retry attempts
                            	   237: #	Returns:
                            	   238: #		a0 = 1 if lock successful, 0 otherwise
                            	   239: #------------------------------------------------------------------------------
                            	   240: 
                            	   241: LockACBSemaphore:
01:000000E0 1E000448        	   242: 	push %br1						# push br1
01:000000E4 1E010040        	   243: 	push %a1
01:000000E8 84000000        	   244: 	loadi %a1,ACBSEMA
01:000000EC 5BDAFF7F        	   245: 	bl LockSemaphore
01:000000F0 1F010040        	   246: 	pop %a1
01:000000F4 1F000448        	   247: 	pop %br1
01:000000F8 1B00FE87        	   248: 	blr
                            	   249: 
                            	   250: #------------------------------------------------------------------------------
                            	   251: # Lock the PMT semaphore.
                            	   252: #
                            	   253: # Parameters:
                            	   254: #		a0 = number of retry attempts
                            	   255: #	Returns:
                            	   256: #		a0 = 1 if lock successful, 0 otherwise
                            	   257: #------------------------------------------------------------------------------
                            	   258: 
                            	   259: LockPMTSemaphore:
01:000000FC 1E000448        	   260: 	push %br1						# push br1
01:00000100 1E010040        	   261: 	push %a1
01:00000104 84000000        	   262: 	loadi %a1,PMTSEMA
01:00000108 5AD4FF7F        	   263: 	bl LockSemaphore
01:0000010C 1F010040        	   264: 	pop %a1
01:00000110 1F000448        	   265: 	pop %br1
01:00000114 1B00FE87        	   266: 	blr
                            	   267: 
                            	   268: #------------------------------------------------------------------------------
                            	   269: # Lock the PMT semaphore.
                            	   270: #
                            	   271: # Parameters:
                            	   272: #		a0 = number of retry attempts
                            	   273: #	Returns:
                            	   274: #		a0 = 1 if lock successful, 0 otherwise
                            	   275: #------------------------------------------------------------------------------
                            	   276: 
                            	   277: LockMSGSemaphore:
01:00000118 1E000448        	   278: 	push %br1						# push br1
01:0000011C 1E010040        	   279: 	push %a1
01:00000120 84000000        	   280: 	loadi %a1,MSGSEMA
01:00000124 5BCCFF7F        	   281: 	bl LockSemaphore
01:00000128 1F010040        	   282: 	pop %a1
01:0000012C 1F000448        	   283: 	pop %br1
01:00000130 1B00FE87        	   284: 	blr
                            	   285: 
                            	   286: #------------------------------------------------------------------------------
                            	   287: # macUnlock system semaphore.
                            	   288: #
                            	   289: # Parameters:
                            	   290: #		none
                            	   291: # Returns:
                            	   292: #		none
                            	   293: #------------------------------------------------------------------------------
                            	   294: 
                            	   295: .macro macUnlockSysSemaphore
                            	   296: 	store %r0,OSSEMA
                            	   297: .endm
                            	   298: 
                            	   299: .macro macUnlockMMUSemaphore
                            	   300: 	store %r0,MMUSEMA
                            	   301: .endm
                            	   302: 
                            	   303: .macro macUnlockACBSemaphore
                            	   304: 	store %r0,ACBSEMA
                            	   305: .endm
                            	   306: 
                            	   307: .macro macUnlockPMTSemaphore
                            	   308: 	store %r0,PMTSEMA
                            	   309: .endm
                            	   310: 
                            	   311: .macro macUnlockMSGSemaphore
                            	   312: 	store %r0,MSGSEMA
                            	   313: .endm
                            	   314: 
                            	   315: # 'C' callable functions
                            	   316: 
                            	   317: _UnlockSysSemaphore:
01:00000134 2E000000        	   318: 	store %r0,OSSEMA
01:00000138 1B00FE87        	   319: 	blr
                            	   320: 
                            	   321: _UnlockMMUSemaphore:
01:0000013C 2E000000        	   322: 	store %r0,MMUSEMA
01:00000140 1B00FE87        	   323: 	blr
                            	   324: 
                            	   325: _UnlockACBSemaphore:
01:00000144 2E000000        	   326: 	store %r0,ACBSEMA
01:00000148 1B00FE87        	   327: 	blr
                            	   328: 
                            	   329: _UnlockPMTSemaphore:
01:0000014C 2E000000        	   330: 	store %r0,PMTSEMA
01:00000150 1B00FE87        	   331: 	blr
                            	   332: 
                            	   333: _UnlockMSGSemaphore:
01:00000154 2E000000        	   334: 	store %r0,MSGSEMA
01:00000158 1B00FE87        	   335: 	blr
                            	   336: 
                            	   337: #------------------------------------------------------------------------------
                            	   338: # Get the system tick (milliseconds).
                            	   339: #
                            	   340: # Trickery involved in guarenteeing that the tick was read without an
                            	   341: # intervening interrupt updating it.
                            	   342: #
                            	   343: # ToDo: make this a .macro?
                            	   344: #
                            	   345: # Parameters:
                            	   346: #		none
                            	   347: # Returns:
                            	   348: #		D,W = tick value
                            	   349: #------------------------------------------------------------------------------
                            	   350: 
                            	   351: .macro macIGetTick
                            	   352: 	load %a0,milliseconds
                            	   353: .endm
                            	   354: 
                            	   355: #------------------------------------------------------------------------------
                            	   356: # Operating system call dispatcher.
                            	   357: #
                            	   358: # Process is to stack registers on the stack, call the function, then
                            	   359: # unstack the registers. Stacking the registers potentially allows some
                            	   360: # functions to be reentrant. It is also faster than context switching to the
                            	   361: # OS. The OS function is running in the context of the caller, except that
                            	   362: # it is running in a higher operating mode which means addresses are 
                            	   363: # untranslated. To get at storage in the current context the mprv flag in 
                            	   364: # the status register is used.
                            	   365: #
                            	   366: # Parameters:
                            	   367: #		a0 = operating system call number
                            	   368: #		a1 to %a6 = arguments for the system call (use depends on called function)
                            	   369: # Returns:
                            	   370: #		a0 = status, E_Ok for success, otherwise an error code
                            	   371: #------------------------------------------------------------------------------
                            	   372: 
                            	   373: OSCall:
01:0000015C 5E400048        	   374: 	push %cr0					# push cr0
01:00000160 030A0000        	   375: 	cmpai %cr0,%a0,OSCallTableLimit	# check if we have a valid function number
01:00000164 D9028800        	   376: 	bgt %cr0,OSCallBadFunc
01:00000168 5F400048        	   377: 	pop %cr0
01:0000016C 07080000        	   378: 	csrrw %r0,SCRATCH,%a0
01:00000170 9E3FFE40        	   379: 	push %r1-%r15					# save registers
01:00000174 DE7FFE40        	   380: 	push %r16-%r31
                            	   381: 	# save status reg, FP status reg
01:00000178 47000000        	   382: 	csrrd %a0,FPSR
01:0000017C 9E000040        	   383: 	push %a0							# push a0
01:00000180 47000000        	   384: 	csrrd %a0,SR
01:00000184 9E000040        	   385: 	push %a0
01:00000188 DE010048        	   386: 	push %usp/%ssp/%hsp		# save SPs
01:0000018C DE7F0048        	   387: 	push %cr0-%lc					# save CRs,BRs and LC
01:00000190 4FE01000        	   388: 	move %a0,%xh					# and XH
01:00000194 9E000040        	   389: 	push %a0
01:00000198 47000000        	   390: 	csrrd %a0,SCRATCH					# get back a0
01:0000019C 42080400        	   391: 	slli %a0,%a0,2						# convert unit index into word index
01:000001A0 6608E807        	   392: 	load. %a0,OSCallTable[%a0]	# fetch vector
01:000001A4 58014001        	   393: 	beq %cr0,OSCallBadFunc2		# nullptr?
01:000001A8 47000000        	   394: 	csrrd %a0,SCRATCH
                            	   395: 	# call the OS function (eg written in C)
                            	   396: 	# we carefully did not modify any registers, so the arguments in registers
                            	   397: 	# should still be correct.
01:000001AC 73008002        	   398: 	blrl %br1	
                            	   399:   # Stuff the error response return value into the right stack position so
                            	   400:   # they it is popped into the a0 register for return
01:000001B0 6EF85803        	   401:   store %a0,428[%sp]					# a0 should be here
                            	   402: 	# fall through to exit
                            	   403: 
                            	   404: #------------------------------------------------------------------------------
                            	   405: # Operating system exit point.
                            	   406: # Pops all the registers off the stack that were saved by the call.
                            	   407: #
                            	   408: # Parameters:
                            	   409: #		none
                            	   410: # Returns:
                            	   411: #		a0 = error code (must have been stuffed into the stack)
                            	   412: #------------------------------------------------------------------------------
                            	   413: 
                            	   414: OSExit:
01:000001B4 9F000040        	   415: 	pop %a0
01:000001B8 0F0F0400        	   416: 	move %xh,%a0
01:000001BC DF7F0048        	   417: 	pop %cr0-%lc					# get CRs,BRs and LC
01:000001C0 DF010048        	   418: 	pop %usp/%ssp/%hsp		# get SPs
                            	   419: 	# restore status reg and FP status reg
01:000001C4 9F000040        	   420: 	pop %a0
01:000001C8 07080000        	   421: 	csrrw %r0,SR,%a0
01:000001CC 9F000040        	   422: 	pop %a0
01:000001D0 07080000        	   423: 	csrrw %r0,FPSR,%a0
                            	   424: 	# restore GPRs
01:000001D4 DF7FFE40        	   425: 	pop %r16-%r31
01:000001D8 9F3FFE40        	   426: 	pop %r1-%r15
01:000001DC 77000000        	   427: 	rfi
                            	   428: 	
                            	   429: #------------------------------------------------------------------------------
                            	   430: # Here a bad function call number was given as the argument.
                            	   431: # This snippet of code returns right away as registers have not been stacked
                            	   432: # yet.
                            	   433: #------------------------------------------------------------------------------
                            	   434: 
                            	   435: OSCallBadFunc:
01:000001E0 5F400048        	   436: 	pop %cr0
01:000001E4 44000400        	   437:   loadi	%a0,E_Func
01:000001E8 1B00FE87        	   438:   blr
                            	   439: 
                            	   440: #------------------------------------------------------------------------------
                            	   441: # Here the OS function was not implemented yet (null pointer in dispatch
                            	   442: # table).
                            	   443: # Stuff the error response into the right stack positions so it is popped into
                            	   444: # the a0 register for return.
                            	   445: #------------------------------------------------------------------------------
                            	   446: 
                            	   447: OSCallBadFunc2:
01:000001EC 44000400        	   448:   loadi	%a0,E_Func
                            	   449: FMTK_RetErr:
01:000001F0 6EF85803        	   450:   store %a0,428[%sp]				# a0 should be here
01:000001F4 1AE8FF7F        	   451:   b OSExit
                            	   452: 
                            	   453: #------------------------------------------------------------------------------
                            	   454: # Some useful OS return points.
                            	   455: #------------------------------------------------------------------------------
                            	   456: 
                            	   457: # Exit OS and return an OKAY status
                            	   458: FMTK_RetOK:
01:000001F8 44000000        	   459: 	loadi %a0,E_OK
01:000001FC 6EF85803        	   460: 	store %a0,428[%sp]
01:00000200 1BE4FF7F        	   461: 	b	OSExit
                            	   462: 
                            	   463: #------------------------------------------------------------------------------
                            	   464: # Got the AppID, now get the mid
                            	   465: #
                            	   466: # Parameters:
                            	   467: #		B = app id
                            	   468: #------------------------------------------------------------------------------
                            	   469: 
                            	   470: GetAppMid:
                            	   471: 	macACBHandleToPointer
01:00000204 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000208 42081C00        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:0000020C 66080000        	   472: 	load %a0,ACBMid[%a0]
01:00000210 1B00FE87        	   473: 	blr
                            	   474: 
                            	   475: #OSCallTbl2:
                            	   476: #  .4byte    SchedulerIRQ
                            	   477: #  .4byte    IStartTask
                            	   478: #  .4byte    ISendMsg
                            	   479: #  .4byte    ISleep
                            	   480: 
                            	   481: OSCallTable:
01:00000214 000002BC        	   482: 	.4byte	FMTK_Initialize					# 0
01:00000218 00000B6C        	   483: 	.4byte	FMTK_StartTask					# 1
01:0000021C 00000C34        	   484: 	.4byte	FMTK_ExitTask
01:00000220 00000C38        	   485: 	.4byte	FMTK_KillTask
                            	   486: #	.4byte		FMTK_SetTaskPriority
01:00000224 000001C0        	   487: 	.4byte  OSCallBadFunc
01:00000228 00000A4C        	   488: 	.4byte	FMTK_Sleep							# 5
01:0000022C 00001244        	   489: 	.4byte	FMTK_AllocMbx
01:00000230 00001304        	   490: 	.4byte		FMTK_FreeMbx
                            	   491: #	.4byte		FMTK_PostMsg
01:00000234 000001C0        	   492: 	.4byte    OSCallBadFunc
01:00000238 0000145C        	   493: 	.4byte		FMTK_SendMsg
01:0000023C 000016A8        	   494: 	.4byte		FMTK_WaitMsg						# 10
01:00000240 000018BC        	   495: 	.4byte		FMTK_PeekMsg
                            	   496: #	.4byte		FMTK_StartApp           # 12
                            	   497: #	.4byte		FMTK_ExitApp            # 13
01:00000244 000001C0        	   498: 	.4byte    OSCallBadFunc
01:00000248 000001C0        	   499: 	.4byte    OSCallBadFunc
01:0000024C 000002D4        	   500: 	.4byte		FMTK_GetCurrentTid
                            	   501: #	.4byte		FMTK_TCBFinalizerExit   # 15
                            	   502: #	.4byte		FMTK_KillApp
                            	   503: #	.4byte		FMTK_RunAsOS            # 17
01:00000250 000001C0        	   504: 	.4byte    OSCallBadFunc
01:00000254 000001C0        	   505: 	.4byte    OSCallBadFunc
01:00000258 000001C0        	   506: 	.4byte    OSCallBadFunc
01:0000025C 00000380        	   507: 	.4byte		FMTK_GetTaskAppId       # 18
01:00000260 00000448        	   508: 	.4byte		FMTK_SetTaskId          # 19
                            	   509: #	.4byte		FMTK_HasIOFocus					# 20
                            	   510: #	.4byte		FMTK_SwitchIOFocus			# 21
                            	   511: #	.4byte		FMTK_ReleaseIOFocus			# 22
                            	   512: #	.4byte		FMTK_ForceReleaseIOFocus	# 23
                            	   513: #	.4byte		FMTK_RequestIOFocus			# 24
01:00000264 000001C0        	   514: 	.4byte    OSCallBadFunc
01:00000268 000001C0        	   515: 	.4byte    OSCallBadFunc
01:0000026C 000001C0        	   516: 	.4byte    OSCallBadFunc
01:00000270 000001C0        	   517: 	.4byte    OSCallBadFunc
01:00000274 000001C0        	   518: 	.4byte    OSCallBadFunc
                            	   519: #	.4byte		FMTK_MapOSVars          # 25
                            	   520: #	.4byte		FMTK_IO									# 26
                            	   521: #	.4byte    FMTK_GetDCBField        # 27
                            	   522: #	.4byte    FMTK_SetDCBField        # 28
01:00000278 000001C0        	   523: 	.4byte    OSCallBadFunc
01:0000027C 000001C0        	   524: 	.4byte    OSCallBadFunc
01:00000280 000001C0        	   525: 	.4byte    OSCallBadFunc
01:00000284 000001C0        	   526: 	.4byte    OSCallBadFunc
01:00000288 000003FC        	   527: 	.4byte    FMTK_GetAppTaskId       # 29
01:0000028C 000003C4        	   528: 	.4byte    FMTK_SetTaskAppId       # 30
01:00000290 000001C0        	   529: 	.4byte    OSCallBadFunc
                            	   530: #	.4byte    GetPamBit               # 32
01:00000294 000001C0        	   531: 	.4byte    OSCallBadFunc
                            	   532: #	.4byte    FetchMemoryWord         # 33
01:00000298 000001C0        	   533: 	.4byte    OSCallBadFunc
                            	   534: #	.4byte    Monitor                 # 34
01:0000029C 000001C0        	   535: 	.4byte    OSCallBadFunc
01:000002A0 00000344        	   536: 	.4byte    GetIRQFlag              # 35
01:000002A4 00000374        	   537: 	.4byte    SetIRQFlag              # 36
01:000002A8 000001C0        	   538: 	.4byte    OSCallBadFunc
01:000002AC 000001C0        	   539: 	.4byte    OSCallBadFunc
01:000002B0 000001C0        	   540: 	.4byte    OSCallBadFunc
01:000002B4 000001C0        	   541: 	.4byte    OSCallBadFunc         	 # 40
01:000002B8 000001C0        	   542: 	.4byte    OSCallBadFunc           # 41
01:000002BC 000001C0        	   543: 	.4byte    OSCallBadFunc           # 42
01:000002C0 000001C0        	   544: 	.4byte    OSCallBadFunc
01:000002C4 000005C8        	   545: 	.4byte    FemtikiTimerISR         # 44
                            	   546: #	.4byte    FMTK_Reschedule         # 45
01:000002C8 000001C0        	   547: 	.4byte    OSCallBadFunc
01:000002CC 0000045C        	   548: 	.4byte    FMTK_GetCurrentMid      # 46
01:000002D0 000004E4        	   549: 	.4byte    FMTK_GetRunningTCBPointer	# 47
01:000002D4 000001C0        	   550: 	.4byte		OSCallBadFunc							 # 48
01:000002D8 00000F70        	   551: 	.4byte		DumpTCBs								# 49
                            	   552: 
                            	   553: .set NUM_OSFUNC,50	#($-OSCallTbl) / 2
                            	   554: 
                            	   555: #------------------------------------------------------------------------------
                            	   556: #------------------------------------------------------------------------------
                            	   557: 
                            	   558: FMTK_Initialize:
01:000002DC 8F4A1400        	   559: 	move %br2,%br1
01:000002E0 5A8E0200        	   560:   bl FMTK_Init
01:000002E4 44000000        	   561:   loadi %a0,E_Ok
01:000002E8 1B00FE8F        	   562:   blr %br2
                            	   563:  
                            	   564: #------------------------------------------------------------------------------
                            	   565: # Get the task id for the currently running task.
                            	   566: # Accesses a global (local to the CPU) variable.
                            	   567: #
                            	   568: # Parameters:
                            	   569: #		none
                            	   570: # Returns:
                            	   571: #		a0 = task id
                            	   572: #------------------------------------------------------------------------------
                            	   573: 
                            	   574: GetCurrentTid:
01:000002EC 660004A0        	   575: 	load %a0,RunningID
01:000002F0 1B00FE87        	   576: 	blr
                            	   577: 
                            	   578: #------------------------------------------------------------------------------
                            	   579: # Get the task id for the currently running task.
                            	   580: #
                            	   581: # Parameters:
                            	   582: #		%a1 = place to put task id
                            	   583: # Returns:
                            	   584: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   585: #		task id at address given in %a1
                            	   586: #------------------------------------------------------------------------------
                            	   587: 
                            	   588: FMTK_GetCurrentTid:
01:000002F4 0310000045233100	   589: 	cmpi %cr0,%a1,0						# check for NULL pointer
01:000002FC 2800F8FF
01:00000300 19004001        	   590: 	beq %cr0,.0001
01:00000304 660000A0        	   591: 	load %a0,RunningID
                            	   592: 	macTCBPointerToHandle
01:00000308 42580010        	     1M 	srli %a0,%a0,LOG_TCBSZ
01:0000030C 4A0804A0        	     2M 	xori %a0,%a0,CB_XOR
01:00000310 070008E0        	   593:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000314 33000058        	   594:   sync
01:00000318 6E100000        	   595: 	store %a0,[%a1]						# do the store to the proper addres space
01:0000031C 070008E0        	   596:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000320 33000058        	   597:   sync
01:00000324 44000000        	   598: 	loadi %a0,E_Ok
01:00000328 1B00FE87        	   599: 	blr
                            	   600: .0001:
01:0000032C 44000200        	   601: 	loadi %a0,E_Arg
01:00000330 1B00FE872800F8FF	   602: 	blr
01:00000338 4523310000000800
                            	   603: 
                            	   604: #------------------------------------------------------------------------------
                            	   605: # (not used - use mprv bit instead)
                            	   606: # Convert the virtual addresss to a physical one. Done by using the MMU's
                            	   607: # conversion facility. One gotcha is that other tasks must be locked out
                            	   608: # during the conversion.
                            	   609: #
                            	   610: # Parameters:
                            	   611: # 	a0 = virtual address
                            	   612: # Returns:
                            	   613: #		a0 = physical address
                            	   614: #------------------------------------------------------------------------------
                            	   615: 
                            	   616: # The virtual address is offset by the base register into the MMU mapping table
                            	   617: ConvertVirtualToPhysical:
01:00000340 1E000448        	   618: 	push %br1
01:00000344 1E030040        	   619: 	push %a1/%a2
01:00000348 CF080000        	   620: 	move %a2,%a0
01:0000034C 4400FE7F        	   621: 	loadi %a0,-1
01:00000350 84000000        	   622: 	loadi %a1,MMUSEMA
01:00000354 5B40FF7F        	   623: 	bl LockSemaphore
01:00000358 EE0000A0        	   624: 	store %a2,MMUxVIRTADR
                            	   625: 	# poll the conversion complete bit, this should not take long
                            	   626: .0001:
01:0000035C 660004A4        	   627: 	load. %a0,MMUxPADRV
01:00000360 583E40E1        	   628: 	beq %cr0,.0001
01:00000364 660008A0        	   629: 	load %a0,MMUxPHYSADR
                            	   630: 	macUnlockMMUSemaphore
01:00000368 2E000000        	     1M 	store %r0,MMUSEMA
01:0000036C 1F030040        	   631: 	pop %a1/%a2
01:00000370 1F0004484000F4FF	   632: 	pop %br1
01:00000378 6000F4FF5000F4FF
01:00000380 1B00FE87        	   633: 	blr
                            	   634: 
                            	   635: #------------------------------------------------------------------------------
                            	   636: # Get the IRQ flag which a CPU local global variable.
                            	   637: #
                            	   638: # Parameters:
                            	   639: #		%a1 = place to put flag
                            	   640: # Returns:
                            	   641: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   642: #		IRQ flag at address given in %a1
                            	   643: #------------------------------------------------------------------------------
                            	   644: 
                            	   645: GetIRQFlag:
01:00000384 03100000        	   646: 	cmpi %cr0,%a1,0			# check for NULL pointer
01:00000388 193F40E1        	   647: 	beq %cr0,.0001
01:0000038C 610000A0        	   648:   ldbz %a0,IRQFlag		# get the flag
01:00000390 07000CE0        	   649:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000394 33000058        	   650:   sync
01:00000398 6E100000        	   651: 	store %a0,[%a1]						# do the store to the proper addres space
01:0000039C 07000CE0        	   652:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:000003A0 33000058        	   653:   sync
01:000003A4 44000000        	   654: 	loadi %a0,E_Ok
01:000003A8 1B00FE87        	   655: 	blr
                            	   656: .0001:
01:000003AC 44000200        	   657: 	loadi %a0,E_Arg
01:000003B0 1B00FE87        	   658: 	blr
                            	   659: 
                            	   660: #------------------------------------------------------------------------------
                            	   661: # Set the IRQ flag which a CPU local global variable.
                            	   662: #
                            	   663: # Parameters:
                            	   664: #		%a1 = value for flag
                            	   665: # Returns:
                            	   666: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a1
                            	   667: #------------------------------------------------------------------------------
                            	   668: 
                            	   669: SetIRQFlag:
01:000003B4 A80000A01200FCFF	   670:   stb %a1,IRQFlag
01:000003BC 00000800
01:000003C0 44000000        	   671:   loadi %a0,E_Ok
01:000003C4 1B00FE87        	   672:   blr
                            	   673: 
                            	   674: #------------------------------------------------------------------------------
                            	   675: # Accessors
                            	   676: #------------------------------------------------------------------------------
                            	   677: 
                            	   678: #------------------------------------------------------------------------------
                            	   679: # Get the owning app id for the task.
                            	   680: #
                            	   681: # Parameters:
                            	   682: #	 	%a1 = task id
                            	   683: #		%a2 = place to store app id
                            	   684: # Returns:
                            	   685: #		a0 = status, E_Ok or E_Arg if not a valid pointer in %a2, E_Arg for bad
                            	   686: #        TCB number
                            	   687: #		app id stored at address pointed to by %a2
                            	   688: #------------------------------------------------------------------------------
                            	   689: 
                            	   690: FMTK_GetTaskAppId:
01:000003C8 03120000        	   691:   cmpai %cr0,%a1,0
01:000003CC 983F40E1        	   692:   beq %cr0,.0001
01:000003D0 03180000        	   693: 	cmpi %cr0,%a2,0			# check for NULL pointer
01:000003D4 583F40E1        	   694: 	beq %cr0,.0001
01:000003D8 660000A0        	   695: 	load %a0,RunningID
01:000003DC 66085806        	   696: 	load %a0,TCBappid[%a0]
                            	   697: 	macACBPointerToHandle
01:000003E0 42780010        	     1M 	srli %a0,%a0,LOG_ACBSZ
01:000003E4 4A0804A0        	     2M 	xori %a0,%a0,CB_XOR
01:000003E8 070008E0        	   698:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:000003EC 33000058        	   699:   sync
01:000003F0 6E1800002800F8FF	   700: 	store %a0,[%a2]						# do the store to the proper addres space
01:000003F8 4523310000000800
01:00000400 070008E0        	   701:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000404 33000058        	   702:   sync
01:00000408 44000000        	   703: 	loadi %a0,E_Ok
01:0000040C 1B00FE87        	   704: 	blr
                            	   705: .0001:
01:00000410 44000200        	   706: 	loadi %a0,E_Arg
01:00000414 1B00FE87        	   707: 	blr
                            	   708: 
                            	   709: #------------------------------------------------------------------------------
                            	   710: # Set the owning app id for the task.
                            	   711: #
                            	   712: # Parameters:
                            	   713: #		%a1 = task id
                            	   714: #		%a2 = App id
                            	   715: # Returns:
                            	   716: #		a0 = status, E_Ok or E_Arg for bad TCB number
                            	   717: #------------------------------------------------------------------------------
                            	   718: #
                            	   719: FMTK_SetTaskAppId:
01:00000418 03120000        	   720:   cmpai %cr0,%a1,0
01:0000041C D83E40E1        	   721:   beq %cr0,.0001
01:00000420 4F100000        	   722:   move %a0,%a1
                            	   723: 	macTCBHandleToPointer
01:00000424 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000428 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:0000042C 8F080000        	   724: 	move %a1,%a0
                            	   725: 	# compare to zero?
01:00000430 4F180000        	   726: 	move %a0,%a2
                            	   727: 	macACBHandleToPointer
01:00000434 4A0804A000000800	     1M 	xori %a0,%a0,CB_XOR
01:0000043C 45233100
01:00000440 42081C00        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:00000444 74105806        	   728: 	stptr %a0,TCBappid[%a1]
01:00000448 44000000        	   729: 	loadi %a0,E_Ok
01:0000044C 1B00FE87        	   730: 	blr
                            	   731: .0001:
01:00000450 44000200        	   732: 	loadi %a0,E_Arg
01:00000454 1B00FE87        	   733: 	blr
                            	   734: 
                            	   735: #------------------------------------------------------------------------------
                            	   736: # Get the task associated with the app.
                            	   737: #
                            	   738: # Parameters
                            	   739: #		%a1 = app id
                            	   740: #		%a2 = address to store task id at
                            	   741: #------------------------------------------------------------------------------
                            	   742: 
                            	   743: FMTK_GetAppTaskId:
01:00000458 03120000        	   744:   cmpai %cr0,%a1,0
01:0000045C 193F40E1        	   745:   beq %cr0,.0001
01:00000460 03180000        	   746: 	cmpi %cr0,%a2,0			# check for NULL pointer
01:00000464 D93E40E1        	   747: 	beq %cr0,.0001
01:00000468 4F100000        	   748: 	move %a0,%a1				# a0 = app id
                            	   749: 	macACBHandleToPointer
01:0000046C 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000470 42081C00        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:00000474 66080000        	   750: 	load %a0,ACBTask[%a0]
                            	   751: 	macTCBPointerToHandle
01:00000478 4258001045233100	     1M 	srli %a0,%a0,LOG_TCBSZ
01:00000480 4A0800A0        	     2M 	xori %a0,%a0,CB_XOR
01:00000484 07000CE0        	   752:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000488 33000058        	   753:   sync
01:0000048C 6E180000        	   754: 	store %a0,[%a2]						# do the store to the proper addres space
01:00000490 07000CE0        	   755:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000494 33000058        	   756:   sync
01:00000498 44000000        	   757: 	loadi %a0,E_Ok
01:0000049C 1B00FE87        	   758: 	blr
                            	   759: .0001:
01:000004A0 44000200        	   760: 	loadi %a0,E_Arg
01:000004A4 1B00FE87        	   761: 	blr
                            	   762: 
                            	   763: #------------------------------------------------------------------------------
                            	   764: # Set the task associated with the app.
                            	   765: #
                            	   766: # The following only really needed by startup code, otherwise the task id
                            	   767: # is completely managed by the OS.
                            	   768: #------------------------------------------------------------------------------
                            	   769: 
                            	   770: FMTK_SetTaskId:
                            	   771:   # Should get the id and see if it s currently zero (unset).
                            	   772:   # but this would be more code bloat.
                            	   773:   macTCBHandleToPointer
01:000004A8 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:000004AC 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:000004B0 B40008A045233100	   774:   stptr %a1,RunningID
01:000004B8 000008002800F8FF
01:000004C0 44000000        	   775:   loadi %a0,E_Ok
01:000004C4 1B00FE87        	   776:   blr
                            	   777: 
                            	   778: #------------------------------------------------------------------------------
                            	   779: #------------------------------------------------------------------------------
                            	   780: 
                            	   781: FMTK_GetCurrentMid:
01:000004C8 660000A0        	   782: 	load %a0,RunningID
01:000004CC 66085806        	   783: 	load %a0,TCBappid[%a0]
01:000004D0 61089407        	   784: 	ldbz %a0,ACBmid[%a0]
01:000004D4 07000CE0        	   785:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:000004D8 33000058        	   786:   sync
01:000004DC 6E100000        	   787: 	store %a0,[%a1]						# do the store to the proper addres space
01:000004E0 07000CE0        	   788:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:000004E4 33000058        	   789:   sync
01:000004E8 44000000        	   790: 	loadi %a0,E_Ok
01:000004EC 1B00FE87        	   791: 	blr
                            	   792: .0001:
01:000004F0 44000200        	   793: 	loadi %a0,E_Arg
01:000004F4 1B00FE872800F8FF	   794: 	blr
01:000004FC 00000800
                            	   795: 
                            	   796: #------------------------------------------------------------------------------
                            	   797: # Parameters:
                            	   798: #		%a1 = task id
                            	   799: #		%a2 = address to put mid in
                            	   800: #------------------------------------------------------------------------------
                            	   801: 
                            	   802: FMTK_GetMid:
01:00000500 03100000        	   803: 	cmpi %cr0,%a1,0
01:00000504 583E40E1        	   804: 	beq %cr0,.0001
01:00000508 03180000        	   805: 	cmpi %cr0,%a2,0	
01:0000050C 183E40E1        	   806: 	beq %cr0,.0001
01:00000510 4F100000        	   807: 	move %a0,%a1
                            	   808: 	macTCBHandleToPointer
01:00000514 4A0800A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000518 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:0000051C 66085806        	   809: 	load %a0,TCBappid[%a0]
01:00000520 61089407        	   810: 	ldbz %a0,ACBmid[%a0]
01:00000524 07000CE0        	   811:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000528 33000058        	   812:   sync
01:0000052C 6E180000        	   813: 	store %a0,[%a2]						# do the store to the proper addres space
01:00000530 07000CE0        	   814:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000534 3300005845233100	   815:   sync
01:0000053C 00000800
01:00000540 44000000        	   816: 	loadi %a0,E_Ok
01:00000544 1B00FE87        	   817: 	blr
                            	   818: .0001:
01:00000548 44000200        	   819: 	loadi %a0,E_Arg
01:0000054C 1B00FE87        	   820: 	blr
                            	   821: 	
                            	   822: #------------------------------------------------------------------------------
                            	   823: # Get a pointer to the TCB for the currently running task.
                            	   824: #
                            	   825: # Parameters:
                            	   826: #		none
                            	   827: # Returns:
                            	   828: #		a0 = pointer to running TCB
                            	   829: #------------------------------------------------------------------------------
                            	   830: 
                            	   831: .macro macGetRunningTCBPointer
                            	   832: 	load %a0,RunningID
                            	   833: 	macTCBHandleToPointer
                            	   834: .endm
                            	   835: 
                            	   836: GetRunningTCBPointer:
01:00000550 660000A0        	   837: 	load %a0,RunningID
                            	   838: 	macTCBHandleToPointer
01:00000554 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000558 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:0000055C 1B00FE87        	   839: 	blr
                            	   840: 	
                            	   841: #------------------------------------------------------------------------------
                            	   842: # ToDo: Should check that app is capable of using TCB pointers
                            	   843: #
                            	   844: # Parameters:
                            	   845: #		%a1 = address to put pointer in
                            	   846: #------------------------------------------------------------------------------
                            	   847: 
                            	   848: FMTK_GetRunningTCBPointer:
01:00000560 03100000        	   849:   cmpi %cr0,%a1,0						# check for null pointer
01:00000564 983D40E1        	   850:   beq %cr0,.0001
                            	   851: 	macGetRunningTCBPointer
01:00000568 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:0000056C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000570 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000574 070008E02800F8FF	   852:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:0000057C 45233100
01:00000580 33000058        	   853:   sync
01:00000584 74100000        	   854: 	stptr %a0,[%a1]						# do the store to the proper address space
01:00000588 070008E0        	   855:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:0000058C 33000058        	   856:   sync
01:00000590 44000000        	   857: 	loadi %a0,E_Ok
01:00000594 1B00FE87        	   858: 	blr
                            	   859: .0001:
01:00000598 44000200        	   860: 	loadi %a0,E_Arg
01:0000059C 1B00FE87        	   861: 	blr
                            	   862: 
                            	   863: #------------------------------------------------------------------------------
                            	   864: # Decrement the timeout. Only the timeout at the head of the list need be
                            	   865: # decremented. If the timeout as reached zero (or lower) then insert the 
                            	   866: # task into the ready queue. Then check the next item in the timeout list
                            	   867: # to see if it is also zero (or lower).
                            	   868: # There is a loop in this code. Usually it would short however unless there
                            	   869: # are a lot of tasks timing out at the same time.
                            	   870: #
                            	   871: # Some experimentation has gone into doing this with hardware.
                            	   872: #------------------------------------------------------------------------------
                            	   873: 
                            	   874: #				while (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   875: #					if (tcbs[TimeoutList].timeout<=0)
                            	   876: #						InsertIntoReadyList(PopTimeoutList());
                            	   877: #					else {
                            	   878: #						tcbs[TimeoutList].timeout = tcbs[TimeoutList].timeout - missed_ticks - 1;
                            	   879: #						missed_ticks = 0;
                            	   880: #						break;
                            	   881: #					}
                            	   882: #				}
                            	   883: 
                            	   884: DecrementTimeout:
                            	   885: .0003:
01:000005A0 660004A4        	   886: 	load.	%a0,TimeoutList				# a0 = pointer to timeout list
01:000005A4 583D40E1        	   887: 	beq %cr0,.0001
01:000005A8 A6083806        	   888: 	load. %a1,TCBTimeout[%a0]
01:000005AC 593C88E0        	   889: 	bgt %cr0,.0002
01:000005B0 5B580200        	   890: 	bl PopTimeoutList
01:000005B4 5B32020000000800	   891: 	bl InsertIntoReadyQueue
01:000005BC D400F8FF
01:000005C0 1BD6FF7F        	   892: 	b .0003
                            	   893: .0002:
01:000005C4 8410FE7F        	   894: 	subi %a1,%a1,1
01:000005C8 8A100000        	   895: 	neg %a1,%a1									# we really wanted amosub here
01:000005CC 3B10C0A0        	   896: 	amoadd %r0,%a1,missed_ticks
01:000005D0 8A100000        	   897: 	neg %a1,%a1
01:000005D4 AE083806        	   898: 	store %a1,TCBTimeout[%a0]
                            	   899: .0001:
01:000005D8 1B00FE87        	   900: 	blr
                            	   901: 
                            	   902: #------------------------------------------------------------------------------
                            	   903: # Helper routine for the timer ISR. Makes the code a little easier to read.
                            	   904: #------------------------------------------------------------------------------
                            	   905: 
                            	   906: SchedulerIRQHelper:
01:000005DC CF4A1400        	   907: 	move %br3,%br1
01:000005E0 44002800        	   908: 	loadi %a0,20
01:000005E4 03080000        	   909: 	cmpi %cr0,%a0,0
01:000005E8 983E40E1        	   910: 	beq %cr0,.0003
01:000005EC 660004A0        	   911: 	load %a0,RunningID
                            	   912: 	# Compute %a5 = number of ticks running
01:000005F0 A608D805        	   913: 	load %a1,TCBEndTick[%a0]
01:000005F4 E608C80500000000	   914: 	load %a2,TCBStartTick[%a0]
01:000005FC 2800F8FF
01:00000600 8C190480        	   915: 	sub %a5,%a1,%a2
01:00000604 3B38C0A0        	   916: 	amoadd %r0,%a5,TCBTicks[%a0]	# calc total cumulative ticks running
                            	   917: 
                            	   918: 	# Check the task priority, special priority 63
01:00000608 A1080000        	   919: 	ldbz %a1,TCBPriorty[%a0]
01:0000060C 03127E00        	   920: 	cmpai %cr0,%a1,63						# highest priority: refuse to task switch or even
01:00000610 583D86E0        	   921: 	bge %cr0,.0003							# decrement timeout
01:00000614 84004000        	   922: 	loadi %a1,TS_PREEMPT
01:00000618 3B1800A2        	   923: 	amoorb %r0,%a1,TCBStatus[%a0]
01:0000061C 5AC0FF7F        	   924: 	bl DecrementTimeout
01:00000620 A1087A05        	   925: 	ldbz %a1,TCBPriority[%a0]		# very high priority > 59, don't switch
01:00000624 03127800        	   926: 	cmpai %cr0,%a1,60
01:00000628 183C86E0        	   927: 	bge %cr0,.0002
01:0000062C 03320600        	   928: 	cmpai %cr0,%a5,3							# allow the task to run for 3 ticks
01:00000630 D83B46E1        	   929: 	blt %cr0,.0002
01:00000634 5A1C0100F4020000	   930: 	bl SelectTaskToRun
01:0000063C BC020000
01:00000640 740000A0        	   931: 	stptr %a0,RunningID
                            	   932: .0002:
01:00000644 84000001        	   933: 	loadi %a1,TS_RUNNING
01:00000648 3B1800A2        	   934: 	amoorb %r0,%a1,TCBStatus[%a0]
01:0000064C 4F5A1400        	   935: 	move %br1,%br3
01:00000650 1B00FE87        	   936: 	blr
                            	   937: .0003:
01:00000654 44000200        	   938: 	loadi %a0,1
01:00000658 3B08C0A0        	   939: 	amoadd %r0,%a0,missed_ticks
01:0000065C 4F5A1400        	   940: 	move %br1,%br3
01:00000660 1B00FE87        	   941: 	blr
                            	   942: 
                            	   943: #------------------------------------------------------------------------------
                            	   944: # Femtiki Timer ISR
                            	   945: #
                            	   946: # The only thing manipulating the TCB ready list must be the timer IRQ. This
                            	   947: # is to prevent deadlocks from ocurring. Since only the timer IRQ manipulates
                            	   948: # the list, there is no need to protect it with a semaphore. However, with
                            	   949: # the restriction that the ISR is the only list manipulator, it must then
                            	   950: # provide services for updating the list to other OS functions.
                            	   951: #
                            	   952: # Side Effects:
                            	   953: #		The context may be changed to another task.
                            	   954: #		If an exception occurred in the task, the task is setup to return to
                            	   955: #		the exception handler.
                            	   956: # Parameters:
                            	   957: #		none - it is a hardware ISR.
                            	   958: # Returns:
                            	   959: #		none - hardware ISR
                            	   960: #------------------------------------------------------------------------------
                            	   961: 
                            	   962: FemtikiTimerISR:
01:00000664 9E1F0040        	   963: 	push %a0-%a6								# push a0 to %a6
01:00000668 5E400048        	   964: 	push %cr0
01:0000066C 1E007C48        	   965: 	push %br1-%br6							# push %br1 to %br6
01:00000670 660000A02800F8FF	   966: 	load %a0,RunningID
01:00000678 BC02000000000000
01:00000680 87001A60        	   967: 	csrrsi %a1,M_SEMA,InTimerISRFlag	# get InTimerISR flag
01:00000684 88100204        	   968: 	andi. %a1,%a1,InTimerISRFlag
01:00000688 593E80E0        	   969: 	bne %cr0,.0004
01:0000068C 74000000        	   970: 	stptr %a0,PrevRunningID			# Keep track of previous Running TCB
01:00000690 4F090000        	   971: 	move %a4,%a0									
01:00000694 8F080000        	   972: 	move %a1,%a0
                            	   973: 	macIGetTick
01:00000698 66000000        	     1M 	load %a0,milliseconds
01:0000069C 6E10D805        	   974: 	store %a0,TCBEndTick[%a1]
01:000006A0 5AACFF7F        	   975: 	bl SchedulerIRQHelper
01:000006A4 660000A0        	   976: 	load %a0,RunningID						# scheduling may have changed this value
01:000006A8 8F090000        	   977: 	move %a5,%a0									# save a copy of the id
01:000006AC 4A090A80        	   978: 	xor %a4,%a0,%a4								# %a4 = flag if running changed
01:000006B0 A108F905        	   979: 	ldbz. %a1,TCBException[%a0]
01:000006B4 993B40E1        	   980: 	beq %cr0,.0001
                            	   981: 	# Exception processing code
                            	   982: 	# Causes a transfer to the exception handler
01:000006B8 AE0880002800F8FF	   983: 	store %a1,TCBxA0[%a0]					# save exception code in %a0
01:000006C0 2E08DA00        	   984: 	storei 45,TCBxA1[%a0]					# store exception type in %a1
01:000006C4 2E08F805        	   985: 	store %r0,TCBException[%a0]		# set exception to zero
01:000006C8 A608B004        	   986: 	load %a1,TCBxXH[%a0]					# move handler address to link register
01:000006CC B4082000        	   987: 	stptr %a1,TCBxBR1[%a0]
01:000006D0 B408A004        	   988: 	stptr %a1,TCBxPC[%a0]					# move handler address to PC register
                            	   989: .0001:
01:000006D4 8F080000        	   990: 	move %a1,%a0
                            	   991: 	macIGetTick
01:000006D8 66000000        	     1M 	load %a0,milliseconds
01:000006DC 6E10C805        	   992: 	store %a0,TCBStartTick[%a1]
                            	   993: 	# Did we stay in the same task?
01:000006E0 03280000        	   994: 	cmpi %cr0,%a4,0
01:000006E4 583C80E0        	   995: 	bne %cr0,.0002
                            	   996: 	# If in same task, just pop registers and return
01:000006E8 1F007C48        	   997: 	pop %br1-%br6							# get back %br1 to %br6
01:000006EC 5F400048        	   998: 	pop %cr0
01:000006F0 9F1F0040        	   999: 	pop %a0-%a6								# get back a0 to %a6
                            	  1000: 	# We need the rfi to execute without an interrupt between the csrrc and rfi
01:000006F4 3C007E00        	  1001: 	atom 63,3
01:000006F8 07001A60        	  1002: 	csrrci %r0,M_SEMA,InTimerISRFlag
01:000006FC 77000000        	  1003: 	rfi
                            	  1004: 	# Return, but do not flag as ISR complete. We are returning to the ISR.
                            	  1005: .0004:
01:00000700 44000200        	  1006: 	loadi %a0,1
01:00000704 3B08C0A0        	  1007: 	amoadd %r0,%a0,missed_ticks
01:00000708 1F007C48        	  1008: 	pop %br1-%br6							# get back %br1 to %br6
01:0000070C 5F400048        	  1009: 	pop %cr0
01:00000710 9F1F0040        	  1010: 	pop %a0-%a6								# get back a0 to %a6
01:00000714 77000000        	  1011: 	rfi
                            	  1012: 
                            	  1013: 	# Here a different task was selected, save and restore contexts
                            	  1014: 	# Going in:
                            	  1015: 	# 	%a4 = old task
                            	  1016: 	#		%a5 = new task
                            	  1017: .0002:
01:00000718 1F007C48        	  1018: 	pop %br1-%br6							# get back %br1 to %br6
01:0000071C 5F400048        	  1019: 	pop %cr0
01:00000720 9F1F0040        	  1020: 	pop %a0-%a6								# get back a0 to %a6
                            	  1021: 
                            	  1022: #------------------------------------------------------------------------------
                            	  1023: # Context switch code	
                            	  1024: # Switches from PrevRunningID to RunningID
                            	  1025: #
                            	  1026: # One issue with the context switching code and the current system is that
                            	  1027: # the queue in the memory controller can overflow if there are a lot of
                            	  1028: # stores in rapid succession. The queue full status is passed to the CPU
                            	  1029: # and ends up in the extra bit CR7. Loads do not have this issue as they
                            	  1030: # wait for responses from the memory controller.
                            	  1031: #------------------------------------------------------------------------------
                            	  1032: 
                            	  1033: SwitchTask:
01:00000724 07080000        	  1034: 	csrrw %r0,SCRATCH,%a0		# save a0 in scratch register
01:00000728 1E000448        	  1035: 	push %br1
01:0000072C 66000000        	  1036: 	load %a0,PrevRunningID
                            	  1037: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1038: 	# Store the destination context
                            	  1039: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01:00000730 AE089000        	  1040: 	store %a1,TCBxA1[%a0]		# save %a1 in TCB so we can use it
01:00000734 1F000448        	  1041: 	pop %br1								# restore link register
01:00000738 8700000000000000	  1042: 	csrrd %a1,SCRATCH			# save original a0 in task control block
01:00000740 AE088000        	  1043: 	store %a1,TCBxA0[%a0]
                            	  1044: 	# save condition registers
01:00000744 8F801000        	  1045: 	move %a1,%cr0
01:00000748 AE080800        	  1046: 	store %a1,TCBxCR0[%a0]
01:0000074C 8F881000        	  1047: 	move %a1,cr1
01:00000750 AE080A00        	  1048: 	store %a1,TCBxCR1[%a0]
01:00000754 8F901000        	  1049: 	move %a1,cr2
01:00000758 AE080C00        	  1050: 	store %a1,TCBxCR2[%a0]
01:0000075C 8F981000        	  1051: 	move %a1,cr3
01:00000760 AE080E00        	  1052: 	store %a1,TCBxCR3[%a0]
01:00000764 8FA01000        	  1053: 	move %a1,cr4
                            	  1054: .0004:	
01:00000768 983A7EE1        	  1055: 	bbf %cr7,.0004	
01:0000076C AE081000        	  1056: 	store %a1,TCBxCR4[%a0]
01:00000770 8FA81000        	  1057: 	move %a1,cr5
01:00000774 AE081200        	  1058: 	store %a1,TCBxCR5[%a0]
01:00000778 8FB01000        	  1059: 	move %a1,cr6
01:0000077C AE081400        	  1060: 	store %a1,TCBxCR6[%a0]
01:00000780 8FB81000        	  1061: 	move %a1,%cr7
01:00000784 AE081600        	  1062: 	store %a1,TCBxCR7[%a0]
                            	  1063: 	# save branch registers
01:00000788 8F481000        	  1064: 	move %a1,%br1
01:0000078C AE082000        	  1065: 	store %a1,TCBxBR1[%a0]
                            	  1066: .0005:	
01:00000790 983A7EE1        	  1067: 	bbf %cr7,.0005	
01:00000794 8F501000        	  1068: 	move %a1,%br2
01:00000798 AE083000        	  1069: 	store %a1,TCBxBR2[%a0]
01:0000079C 8F581000        	  1070: 	move %a1,%br3
01:000007A0 AE084000        	  1071: 	store %a1,TCBxBR3[%a0]
01:000007A4 8F601000        	  1072: 	move %a1,%br4
01:000007A8 AE085000        	  1073: 	store %a1,TCBxBR4[%a0]
01:000007AC 8F681000        	  1074: 	move %a1,%br5
01:000007B0 AE086000        	  1075: 	store %a1,TCBxBR5[%a0]
01:000007B4 8F701000        	  1076: 	move %a1,%br6
01:000007B8 AE087000        	  1077: 	store %a1,TCBxBR6[%a0]
                            	  1078: 	# save loop counter
01:000007BC 8FC01000        	  1079: 	move %a1,%lc
01:000007C0 AE089002        	  1080: 	store %a1,TCBxLC[%a0]
                            	  1081: .0006:	
01:000007C4 983A7EE1        	  1082: 	bbf %cr7,.0006
                            	  1083: 	# exception handler address
01:000007C8 8FE01000        	  1084: 	move %a1,xh
01:000007CC AE08B004        	  1085: 	store %a1,TCBxXH[%a0]
                            	  1086: 	# save GPRs
01:000007D0 EE08A000        	  1087: 	store %a2,TCBxA2[%a0]
01:000007D4 2E09B000        	  1088: 	store %a3,TCBxA3[%a0]
01:000007D8 6E09C000        	  1089: 	store %a4,TCBxA4[%a0]
01:000007DC AE09D000        	  1090: 	store %a5,TCBxA5[%a0]
01:000007E0 EE09E000        	  1091: 	store %a6,TCBxA6[%a0]
01:000007E4 2E0AF000        	  1092: 	store %a7,TCBxA7[%a0]
                            	  1093: .0007:
01:000007E8 983A7EE1        	  1094: 	bbf %cr7,.0007
01:000007EC 6E0A0001        	  1095: 	store %t0,TCBxT0[%a0]
01:000007F0 AE0A1001        	  1096: 	store %t1,TCBxT1[%a0]
01:000007F4 EE0A2001        	  1097: 	store %t2,TCBxT2[%a0]
01:000007F8 2E0B3001        	  1098: 	store %t3,TCBxT3[%a0]
01:000007FC 6E0B4001        	  1099: 	store %t4,TCBxT4[%a0]
01:00000800 AE0B5001        	  1100: 	store %t5,TCBxT5[%a0]
                            	  1101: .0008:
01:00000804 983A7EE1        	  1102: 	bbf %cr7,.0008
01:00000808 EE0B6001        	  1103: 	store %t6,TCBxT6[%a0]
01:0000080C 2E0C7001        	  1104: 	store %t7,TCBxT7[%a0]
01:00000810 6E0C8001        	  1105: 	store %t8,TCBxT8[%a0]
01:00000814 AE0C9001        	  1106: 	store %t9,TCBxT9[%a0]
01:00000818 EE0CA001        	  1107: 	store %s0,TCBxS0[%a0]
01:0000081C 2E0DB001        	  1108: 	store %s1,TCBxS1[%a0]
                            	  1109: .0009:
01:00000820 983A7EE1        	  1110: 	bbf %cr7,.0009
01:00000824 6E0DC001        	  1111: 	store %s2,TCBxS2[%a0]
01:00000828 AE0DD001        	  1112: 	store %s3,TCBxS3[%a0]
01:0000082C EE0DE001        	  1113: 	store %s4,TCBxS4[%a0]
01:00000830 2E0EF001        	  1114: 	store %s5,TCBxS5[%a0]
01:00000834 6E0E0002        	  1115: 	store %s6,TCBxS6[%a0]
                            	  1116: .0010:
01:00000838 983A7EE1        	  1117: 	bbf %cr7,.0010
01:0000083C AE0E1002        	  1118: 	store %s7,TCBxS7[%a0]
01:00000840 EE0E2002        	  1119: 	store %s8,TCBxS8[%a0]
01:00000844 2E0F3002        	  1120: 	store %s9,TCBxS9[%a0]
01:00000848 6E0F4002        	  1121: 	store %gp,TCBxGP[%a0]
01:0000084C AE0F5002        	  1122: 	store %fp,TCBxFP[%a0]
                            	  1123: .0011:
01:00000850 983A7EE1        	  1124: 	bbf %cr7,.0011
01:00000854 87000000        	  1125: 	csrrd %a1,SR
01:00000858 AE083005        	  1126: 	store %a1,TCBxSR[%a0]
                            	  1127: 	# check to see if FPRs need to be saved
01:0000085C 87000000        	  1128: 	csrrd %a1,FPSR
01:00000860 AE084005        	  1129: 	store %a1,TCBxFPSR[%a0]
01:00000864 82100E00        	  1130: 	ext. %a1,%a1,FPStateBegin,FPStateEnd
01:00000868 593F40E1        	  1131: 	beq %cr0,.0002
01:0000086C 3908A002        	  1132: 	stfd %f0,TCBxF0[%a0]
01:00000870 7908B002        	  1133: 	stfd %f1,TCBxF1[%a0]
01:00000874 B908C002        	  1134: 	stfd %f2,TCBxF2[%a0]
                            	  1135: .0012:
01:00000878 983A7EE1        	  1136: 	bbf %cr7,.0012
01:0000087C F908D002        	  1137: 	stfd %f3,TCBxF3[%a0]
01:00000880 3909E002        	  1138: 	stfd %f4,TCBxF4[%a0]
01:00000884 7909F002        	  1139: 	stfd %f5,TCBxF5[%a0]
01:00000888 B9090003        	  1140: 	stfd %f6,TCBxF6[%a0]
01:0000088C F9091003        	  1141: 	stfd %f7,TCBxF7[%a0]
01:00000890 390A2003        	  1142: 	stfd %f8,TCBxF8[%a0]
                            	  1143: .0013:
01:00000894 983A7EE1        	  1144: 	bbf %cr7,.0013
01:00000898 790A3003        	  1145: 	stfd %f9,TCBxF9[%a0]
01:0000089C B90A4003        	  1146: 	stfd %f10,TCBxF10[%a0]
01:000008A0 F90A5003        	  1147: 	stfd %f11,TCBxF11[%a0]
01:000008A4 390B6003        	  1148: 	stfd %f12,TCBxF12[%a0]
01:000008A8 790B7003        	  1149: 	stfd %f13,TCBxF13[%a0]
01:000008AC B90B8003        	  1150: 	stfd %f14,TCBxF14[%a0]
                            	  1151: .0014:
01:000008B0 983A7EE1        	  1152: 	bbf %cr7,.0014
01:000008B4 F90B9003        	  1153: 	stfd %f15,TCBxF15[%a0]
01:000008B8 390CA003        	  1154: 	stfd %f16,TCBxF16[%a0]
01:000008BC 790CB003        	  1155: 	stfd %f17,TCBxF17[%a0]
01:000008C0 B90CC003        	  1156: 	stfd %f18,TCBxF18[%a0]
01:000008C4 F90CD003        	  1157: 	stfd %f19,TCBxF19[%a0]
01:000008C8 390DE003        	  1158: 	stfd %f20,TCBxF20[%a0]
                            	  1159: .0015:
01:000008CC 983A7EE1        	  1160: 	bbf %cr7,.0015
01:000008D0 790DF003        	  1161: 	stfd %f21,TCBxF21[%a0]
01:000008D4 B90D0004        	  1162: 	stfd %f22,TCBxF22[%a0]
01:000008D8 F90D1004        	  1163: 	stfd %f23,TCBxF23[%a0]
01:000008DC 390E2004        	  1164: 	stfd %f24,TCBxF24[%a0]
01:000008E0 790E3004        	  1165: 	stfd %f25,TCBxF25[%a0]
01:000008E4 B90E4004        	  1166: 	stfd %f26,TCBxF26[%a0]
                            	  1167: .0016:
01:000008E8 983A7EE1        	  1168: 	bbf %cr7,.0016
01:000008EC F90E5004        	  1169: 	stfd %f27,TCBxF27[%a0]
01:000008F0 390F6004        	  1170: 	stfd %f28,TCBxF28[%a0]
01:000008F4 790F7004        	  1171: 	stfd %f29,TCBxF29[%a0]
01:000008F8 B90F8004        	  1172: 	stfd %f30,TCBxF30[%a0]
01:000008FC F90F9004        	  1173: 	stfd %f31,TCBxF31[%a0]
                            	  1174: .0017:
01:00000900 983A7EE1        	  1175: 	bbf %cr7,.0017
                            	  1176: .0002:	
                            	  1177: 	# save stack pointers and branch registers
01:00000904 8F001010        	  1178: 	movea %a1,%usp
01:00000908 AE086002        	  1179: 	store %a1,TCBxUSP[%a0]
01:0000090C 8F081010        	  1180: 	movea %a1,%ssp
01:00000910 AE087002        	  1181: 	store %a1,TCBxSSP[%a0]
01:00000914 8F101010        	  1182: 	movea %a1,%hsp
01:00000918 AE088002        	  1183: 	store %a1,TCBxHSP[%a0]
01:0000091C 87001062        	  1184: 	csrrd %a1,EPC0
01:00000920 AE08A004        	  1185: 	store %a1,TCBxPC[%a0]
01:00000924 87000061        	  1186: 	csrrd %a1,ESR0
01:00000928 AE083005        	  1187: 	store %a1,TCBxSR[%a0]
                            	  1188: .0018:
01:0000092C 983A7EE1        	  1189: 	bbf %cr7,.0018
                            	  1190: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1191: 	# Load the destination context
                            	  1192: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	  1193: 	# walk forwards loading registers
                            	  1194: 	macGetRunningTCBPointer
01:00000930 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000934 4A0804A02800F8FF	     1M 	xori %a0,%a0,CB_XOR
01:0000093C 45233100
01:00000940 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000944 07080000        	  1195: 	csrrw %r0,TCBA,%a0			# update running TCB address
                            	  1196: 
                            	  1197: 	# load condition registers
01:00000948 A6080800        	  1198: 	load %a1,TCBxCR0[%a0]
01:0000094C 0F140400        	  1199: 	move %cr0,%a1
01:00000950 A6080A00        	  1200: 	load %a1,TCBxCR1[%a0]
01:00000954 4F140400        	  1201: 	move cr1,%a1
01:00000958 A6080C00        	  1202: 	load %a1,TCBxCR2[%a0]
01:0000095C 8F140400        	  1203: 	move cr2,%a1
01:00000960 A6080E00        	  1204: 	load %a1,TCBxCR3[%a0]
01:00000964 CF140400        	  1205: 	move cr3,%a1
01:00000968 A6081000        	  1206: 	load %a1,TCBxCR4[%a0]
01:0000096C 0F150400        	  1207: 	move cr4,%a1
01:00000970 A6081200        	  1208: 	load %a1,TCBxCR5[%a0]
01:00000974 4F150400        	  1209: 	move cr5,%a1
01:00000978 A6081400        	  1210: 	load %a1,TCBxCR6[%a0]
01:0000097C 8F150400        	  1211: 	move cr6,%a1
01:00000980 A6081600        	  1212: 	load %a1,TCBxCR7[%a0]
01:00000984 CF150400        	  1213: 	move %cr7,%a1
                            	  1214: 	# load branch registers
01:00000988 A6082000        	  1215: 	load %a1,TCBxBR1[%a0]
01:0000098C 4F120400        	  1216: 	move %br1,%a1
01:00000990 A6083000        	  1217: 	load %a1,TCBxBR2[%a0]
01:00000994 8F120400        	  1218: 	move %br2,%a1
01:00000998 A6084000        	  1219: 	load %a1,TCBxBR3[%a0]
01:0000099C CF120400        	  1220: 	move %br3,%a1
01:000009A0 A6085000        	  1221: 	load %a1,TCBxBR4[%a0]
01:000009A4 0F130400        	  1222: 	move %br4,%a1
01:000009A8 A6086000        	  1223: 	load %a1,TCBxBR5[%a0]
01:000009AC 4F130400        	  1224: 	move %br5,%a1
01:000009B0 A6087000        	  1225: 	load %a1,TCBxBR6[%a0]
01:000009B4 8F130400        	  1226: 	move %br6,%a1
                            	  1227: 	# load loop counter
01:000009B8 A6089002        	  1228: 	load %a1,TCBxLC[%a0]
01:000009BC 0F160400        	  1229: 	move %lc,%a1
                            	  1230: 	# excaption handler address
01:000009C0 A608B004        	  1231: 	load %a1,TCBxXH[%a0]
01:000009C4 0F170400        	  1232: 	move %xh,%a1
                            	  1233: 	# Load GPRs
01:000009C8 E608A000        	  1234: 	load %a2,TCBxA2[%a0]
01:000009CC 2609B000        	  1235: 	load %a3,TCBxA3[%a0]
01:000009D0 6609C000        	  1236: 	load %a4,TCBxA4[%a0]
01:000009D4 A609D000        	  1237: 	load %a5,TCBxA5[%a0]
01:000009D8 E609E000        	  1238: 	load %a6,TCBxA6[%a0]
01:000009DC 260AF000        	  1239: 	load %a7,TCBxA7[%a0]
01:000009E0 660A0001        	  1240: 	load %t0,TCBxT0[%a0]
01:000009E4 A60A1001        	  1241: 	load %t1,TCBxT1[%a0]
01:000009E8 E60A2001        	  1242: 	load %t2,TCBxT2[%a0]
01:000009EC 260B3001        	  1243: 	load %t3,TCBxT3[%a0]
01:000009F0 660B4001        	  1244: 	load %t4,TCBxT4[%a0]
01:000009F4 A60B5001        	  1245: 	load %t5,TCBxT5[%a0]
01:000009F8 E60B6001        	  1246: 	load %t6,TCBxT6[%a0]
01:000009FC 260C7001        	  1247: 	load %t7,TCBxT7[%a0]
01:00000A00 660C8001        	  1248: 	load %t8,TCBxT8[%a0]
01:00000A04 A60C9001        	  1249: 	load %t9,TCBxT9[%a0]
01:00000A08 E60CA001        	  1250: 	load %s0,TCBxS0[%a0]
01:00000A0C 260DB001        	  1251: 	load %s1,TCBxS1[%a0]
01:00000A10 660DC001        	  1252: 	load %s2,TCBxS2[%a0]
01:00000A14 A60DD001        	  1253: 	load %s3,TCBxS3[%a0]
01:00000A18 E60DE001        	  1254: 	load %s4,TCBxS4[%a0]
01:00000A1C 260EF001        	  1255: 	load %s5,TCBxS5[%a0]
01:00000A20 660E0002        	  1256: 	load %s6,TCBxS6[%a0]
01:00000A24 A60E1002        	  1257: 	load %s7,TCBxS7[%a0]
01:00000A28 E60E2002        	  1258: 	load %s8,TCBxS8[%a0]
01:00000A2C 260F3002        	  1259: 	load %s9,TCBxS9[%a0]
01:00000A30 660F4002        	  1260: 	load %gp,TCBxGP[%a0]
01:00000A34 A60F5002        	  1261: 	load %fp,TCBxFP[%a0]
                            	  1262: 	# check to see if FPRs need to be saved
01:00000A38 A6084005        	  1263: 	load %a1,TCBxFPSR[%a0]
01:00000A3C 07100000        	  1264: 	csrrw %r0,FPSR,%a1
01:00000A40 82100E00        	  1265: 	ext. %a1,%a1,FPStateBegin,FPStateEnd
01:00000A44 593E40E1        	  1266: 	beq %cr0,.0003
01:00000A48 3108A002        	  1267: 	ldfd %f0,TCBxF0[%a0]
01:00000A4C 7108B002        	  1268: 	ldfd %f1,TCBxF1[%a0]
01:00000A50 B108C002        	  1269: 	ldfd %f2,TCBxF2[%a0]
01:00000A54 F108D002        	  1270: 	ldfd %f3,TCBxF3[%a0]
01:00000A58 3109E002        	  1271: 	ldfd %f4,TCBxF4[%a0]
01:00000A5C 7109F002        	  1272: 	ldfd %f5,TCBxF5[%a0]
01:00000A60 B1090003        	  1273: 	ldfd %f6,TCBxF6[%a0]
01:00000A64 F1091003        	  1274: 	ldfd %f7,TCBxF7[%a0]
01:00000A68 310A2003        	  1275: 	ldfd %f8,TCBxF8[%a0]
01:00000A6C 710A3003        	  1276: 	ldfd %f9,TCBxF9[%a0]
01:00000A70 B10A4003        	  1277: 	ldfd %f10,TCBxF10[%a0]
01:00000A74 F10A5003        	  1278: 	ldfd %f11,TCBxF11[%a0]
01:00000A78 310B6003        	  1279: 	ldfd %f12,TCBxF12[%a0]
01:00000A7C 710B7003        	  1280: 	ldfd %f13,TCBxF13[%a0]
01:00000A80 B10B8003        	  1281: 	ldfd %f14,TCBxF14[%a0]
01:00000A84 F10B9003        	  1282: 	ldfd %f15,TCBxF15[%a0]
01:00000A88 310CA003        	  1283: 	ldfd %f16,TCBxF16[%a0]
01:00000A8C 710CB003        	  1284: 	ldfd %f17,TCBxF17[%a0]
01:00000A90 B10CC003        	  1285: 	ldfd %f18,TCBxF18[%a0]
01:00000A94 F10CD003        	  1286: 	ldfd %f19,TCBxF19[%a0]
01:00000A98 310DE003        	  1287: 	ldfd %f20,TCBxF20[%a0]
01:00000A9C 710DF003        	  1288: 	ldfd %f21,TCBxF21[%a0]
01:00000AA0 B10D0004        	  1289: 	ldfd %f22,TCBxF22[%a0]
01:00000AA4 F10D1004        	  1290: 	ldfd %f23,TCBxF23[%a0]
01:00000AA8 310E2004        	  1291: 	ldfd %f24,TCBxF24[%a0]
01:00000AAC 710E3004        	  1292: 	ldfd %f25,TCBxF25[%a0]
01:00000AB0 B10E4004        	  1293: 	ldfd %f26,TCBxF26[%a0]
01:00000AB4 F10E5004        	  1294: 	ldfd %f27,TCBxF27[%a0]
01:00000AB8 310F6004        	  1295: 	ldfd %f28,TCBxF28[%a0]
01:00000ABC 710F7004        	  1296: 	ldfd %f29,TCBxF29[%a0]
01:00000AC0 B10F8004        	  1297: 	ldfd %f30,TCBxF30[%a0]
01:00000AC4 F10F9004        	  1298: 	ldfd %f31,TCBxF31[%a0]
                            	  1299: .0003:	
                            	  1300: 	# load stack pointers
01:00000AC8 A6086002        	  1301: 	load %a1,TCBxUSP[%a0]
01:00000ACC 0F100410        	  1302: 	movea %usp,%a1
01:00000AD0 A6087002        	  1303: 	load %a1,TCBxSSP[%a0]
01:00000AD4 4F100410        	  1304: 	movea %ssp,%a1
01:00000AD8 A6088002        	  1305: 	load %a1,TCBxHSP[%a0]
01:00000ADC 8F100410        	  1306: 	movea %hsp,%a1
01:00000AE0 A6083005        	  1307: 	load %a1,TCBxSR[%a0]
01:00000AE4 07100061        	  1308: 	csrrw %r0,ESR0,%a1
01:00000AE8 A608A004        	  1309: 	load %a1,TCBxPC[%a0]
01:00000AEC 07101062        	  1310: 	csrrw %r0,EPC0,%a1
01:00000AF0 A6089000        	  1311: 	load %a1,TCBxA1[%a0]
01:00000AF4 66088000        	  1312: 	load %a0,TCBxA0[%a0]
01:00000AF8 3C007E00        	  1313: 	atom 63,3
01:00000AFC 07001A60        	  1314: 	csrrci %r0,M_SEMA,InTimerISRFlag
01:00000B00 77000000        	  1315: 	rfi
                            	  1316: 
                            	  1317: 
                            	  1318: #------------------------------------------------------------------------------
                            	  1319: # Put the current task to sleep.
                            	  1320: # If the timeout is zero or less then it is assumed the task is giving up it's
                            	  1321: # time slice, so the timer ISR is forced to run to switch contexts. The task is
                            	  1322: # not put to sleep, but placed back in priority queue.
                            	  1323: # If the timeout is positive then a SLEEP request is setup for the timer ISR
                            	  1324: # and the timer ISR forced to run.
                            	  1325: #
                            	  1326: #	Parameters
                            	  1327: #		%a1 = number of ticks
                            	  1328: #		%a2 = pointer to place to put return value in
                            	  1329: # Returns:
                            	  1330: #		a0 = E_Ok after the sleep interval.
                            	  1331: #------------------------------------------------------------------------------
                            	  1332: 
                            	  1333: FMTK_Sleep:
01:00000B04 03100000        	  1334:   cmpi %cr0,%a1,0						# sleep for <=0?
01:00000B08 983C48E1        	  1335:   ble %cr0,.0003						# giving up time slice?
                            	  1336:   macGetRunningTCBPointer
01:00000B0C 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000B10 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000B14 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000B18 AE08D006        	  1337:   store %a1,TCBTsCmdParm[%a0]	# setup sleep command request
01:00000B1C 04010600        	  1338:   loadi %a3,TSC_SLEEP
01:00000B20 2809B006        	  1339:   stb %a3,TCBTsCmd[%a0]
01:00000B24 CDA9FE7F        	  1340: 	bli FemtikiTimerISR				# Force Timer IRQ processing
01:00000B28 03180000        	  1341:   cmpi %cr0,%a2,0						# we allow null here, maybe no return value needed
01:00000B2C 193B40E1        	  1342:   beq %cr0,.0002
01:00000B30 6608C006        	  1343:   load %a0,TCBTsResp[%a0]		# response should have been updated by timer IRQ
01:00000B34 070008E02800F8FF	  1344:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000B3C 45233100
01:00000B40 33000058        	  1345:   sync
01:00000B44 6E180000        	  1346: 	store %a0,[%a2]						# do the store to the proper address space
01:00000B48 070008E0        	  1347:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000B4C 33000058        	  1348:   sync
                            	  1349:  .0002:
01:00000B50 44000000        	  1350:   loadi %a0,E_Ok
01:00000B54 1B00FE87        	  1351:   blr
                            	  1352: .0003:
01:00000B58 CD9DFE7F        	  1353: 	bli FemtikiTimerISR			# Force Timer IRQ processing
01:00000B5C 44000000        	  1354:   loadi %a0,E_Ok
01:00000B60 1B00FE87        	  1355:   blr
                            	  1356: 
                            	  1357: # ----------------------------------------------------------------------------
                            	  1358: # Select a task to run. Relatively easy as task selection is handled by
                            	  1359: # hardware. All that needs to be done is to keep popping the hardware queue
                            	  1360: # until a valid running task is found.
                            	  1361: # This function also takes care of servicing requests from other OS code.
                            	  1362: #
                            	  1363: # Side Effects:
                            	  1364: #		The ready queue is popped
                            	  1365: #		The TCB list may be modified if a command is present
                            	  1366: # Modifies:
                            	  1367: #		none
                            	  1368: # Retuns:
                            	  1369: #		a0 = next task to run
                            	  1370: #; ----------------------------------------------------------------------------
                            	  1371: 
                            	  1372: SelectTaskToRun:
01:00000B64 1E000448        	  1373: 	push %br1
01:00000B68 1E030040        	  1374: 	push %a1-%a3				# push %a1,%a2,%a3
                            	  1375: 	# There should always be at least one task in the ready queue. It should
                            	  1376: 	# be guarenteed to be popped within 32 tries (the number of attempts for
                            	  1377: 	# all queues to be tested). The following limit is in case something is
                            	  1378: 	# broken.
                            	  1379: .0004:
01:00000B6C 44000001        	  1380: 	loadi %a0,128
                            	  1381: .0001:							#	keep popping tasks from the readyQ until a valid one
01:00000B70 4408FE7F        	  1382: 	addi. %a0,%a0,-1		# is found. If none valid for a long time default to
01:00000B74 193F40E1        	  1383: 	beq	%cr0,.0002			# the OS task
01:00000B78 A600000400000800	  1384: 	load. %a1,RDYQ
01:00000B80 983940E1        	  1385: 	beq %cr0,.0001
                            	  1386: 	# Here we got a valid task id. If the task is still supposed to be
                            	  1387: 	# running, push it back onto the ready queue. Otherwise go get the
                            	  1388: 	# next task.
01:00000B84 4F100000        	  1389: 	move %a0,%a1
01:00000B88 0F110000        	  1390: 	move %a3,%a1				# save this
                            	  1391: 	# Check for commands, if successful clear the command otherwise it will be
                            	  1392: 	# done more than once.
01:00000B8C BB08C1A6        	  1393: 	amoswapb. %a1,%r0,TCBTsCmd[%a0]	# clear command
01:00000B90 583D40E1        	  1394: 	beq %cr0,.0007
01:00000B94 03100400        	  1395: 	cmpi %cr0,%a1,TSC_FREETCB	# was the TCB "freed"	
01:00000B98 583A80E0        	  1396: 	bne %cr0,.0005						# should use a predicate here
01:00000B9C 5AAC0000        	  1397: 	bl IFreeTCB
01:00000BA0 1AE6FF7F        	  1398: 	b .0007
                            	  1399: .0005:
01:00000BA4 03100200        	  1400: 	cmpi %cr0,%a1,TSC_ALLOCTCB
01:00000BA8 D93A80E0        	  1401: 	bne %cr0,.0003
01:00000BAC 8F080000        	  1402: 	move %a1,%a0
01:00000BB0 5B9E0000        	  1403: 	bl IAllocTCB
01:00000BB4 193A80E0        	  1404: 	bne %cr0,.0006
01:00000BB8 2810B20658030000	  1405: 	stbi TSC_ALLOCTCB,TCBTsCmd[%a1]			# repeat command if not successful
                            	  1406: .0006:
01:00000BC0 6E10C006        	  1407: 	store %a0,TCBTsResp[%a1]
01:00000BC4 4F100000        	  1408: 	move %a0,%a1
01:00000BC8 1ADCFF7F        	  1409: 	b .0007
                            	  1410: .0003:
01:00000BCC 03100600        	  1411: 	cmpi %cr0,%a1,TSC_SLEEP
01:00000BD0 583B80E0        	  1412: 	bne %cr0,.0007
01:00000BD4 03100000        	  1413: 	cmpi %cr0,%a1,0
01:00000BD8 993A48E1        	  1414: 	ble %cr0,.0008
01:00000BDC CF080000        	  1415: 	move %a2,%a0
01:00000BE0 A608D006        	  1416: 	load %a1,TCBTsCmdParm[%a0]		# %a1 = timeout
01:00000BE4 660000A0        	  1417: 	load %a0,RunningID						# a0 = running TID
01:00000BE8 5BAE0000        	  1418: 	bl RemoveFromReadyQueue
01:00000BEC 5A000000        	  1419: 	bl InsertIntoTimeoutList
01:00000BF0 8F180000        	  1420: 	move %a1,%a2
                            	  1421: .0008:
01:00000BF4 44000200        	  1422: 	loadi %a0,1
01:00000BF8 6E1000002800F8FF	  1423: 	store %a0,TCBRsResp[%a1]
01:00000C00 4F100000        	  1424: 	move %a0,%a1 	
                            	  1425: .0007:
01:00000C04 A1087805        	  1426: 	ldbz %a1,TCBStatus[%a0]
01:00000C08 08100005        	  1427: 	andi. %r0,%a1,TS_RUNNING
01:00000C0C 183580E0        	  1428: 	bne	%cr0,.0004
01:00000C10 4F200000        	  1429: 	move %a0,%a3									# we want the id here
01:00000C14 5B9A0000        	  1430: 	bl InsertIntoReadyQueue
01:00000C18 1F030040        	  1431: 	pop %a1-%a3
01:00000C1C 1F000448        	  1432: 	pop %br1
01:00000C20 1B00FE87        	  1433: 	blr
                            	  1434: 	# Nothing in queues? There is supposed to be. Add the OS task to the queue.
                            	  1435: .0002:
01:00000C24 44000200        	  1436: 	loadi %a0,1
01:00000C28 5A960000        	  1437: 	bl InsertIntoReadyQueue
01:00000C2C 1F030040        	  1438: 	pop %a1-%a3
01:00000C30 1F000448        	  1439: 	pop %br1
01:00000C34 1B00FE87        	  1440: 	blr
                            	  1441: 
                            	  1442: #// ----------------------------------------------------------------------------
                            	  1443: #// Sleep for a number of clock ticks.
                            	  1444: #// ----------------------------------------------------------------------------
                            	  1445: #
                            	  1446: #int FMTK_Sleep(int timeout)
                            	  1447: #{
                            	  1448: #  hTCB ht;
                            	  1449: #  int tick1, tick2;
                            	  1450: #
                            	  1451: #	while (timeout > 0) {
                            	  1452: #		tick1 = GetTick();
                            	  1453: #    if (LockSysSemaphore(100000)) {
                            	  1454: #      ht = GetRunningTCB();
                            	  1455: #      RemoveFromReadyList(ht);
                            	  1456: #      InsertIntoTimeoutList(ht, timeout);
                            	  1457: #      macUnlockSysSemaphore();
                            	  1458: #			FMTK_Reschedule();
                            	  1459: #      break;
                            	  1460: #    }
                            	  1461: #		else {
                            	  1462: #			tick2 = GetTick();
                            	  1463: #			timeout -= (tick2-tick1);
                            	  1464: #		}
                            	  1465: #;	}
                            	  1466: #  return (E_Ok);
                            	  1467: #}
                            	  1468: 
                            	  1469: #------------------------------------------------------------------------------
                            	  1470: # Start a task.
                            	  1471: #
                            	  1472: # Side Effects:
                            	  1473: #		Triggers the timer ISR to get a TCB from the free list.
                            	  1474: #		The ACB semaphore is briefly locked.
                            	  1475: #
                            	  1476: # Parameters:
                            	  1477: #		%a1 = app id
                            	  1478: #		%a2 = priority
                            	  1479: #		%a3 = start address
                            	  1480: #		%a4 = start parameter
                            	  1481: #		%a5 = affinity
                            	  1482: #		%a6 = place to put task id
                            	  1483: # Returns:
                            	  1484: #		a0 = E_Ok, E_NoMoreTCBs or E_NoMem
                            	  1485: #		in [%a6] task id
                            	  1486: #------------------------------------------------------------------------------
                            	  1487: 
                            	  1488: FMTK_StartTask:
01:00000C38 8F4A1400        	  1489: 	move %br2,%br1
01:00000C3C 660200A0        	  1490: 	load %t0,RunningID
                            	  1491: 	macGetRunningTCBPointer
01:00000C40 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000C44 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000C48 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000C4C 0F0A0000        	  1492: 	move %a7,%a0
01:00000C50 2840B206        	  1493: 	stbi TSC_ALLOCTCB,TCBTsCmd[%a7]	# request a TCB from the scheduler
01:00000C54 CD5DFE7F        	  1494: 	bli FemtikiTimerISR
01:00000C58 6640C006        	  1495: 	load. %a0,TCBTsResp[%a7]
01:00000C5C 2E40C006        	  1496: 	store %r0,TCBTsResp[%a7]
01:00000C60 8F0A0000        	  1497: 	move %t1,%a0								# %t1 = handle for new task
01:00000C64 03080000        	  1498: 	cmpi %cr0,%a0,0
01:00000C68 D93D40E1        	  1499: 	beq	%cr0,.0002
01:00000C6C B4085806        	  1500: 	stptr %a1,TCBappid[%a0]
01:00000C70 E8087A05        	  1501: 	stb %a2,TCBPriority[%a0]
01:00000C74 AA0928062800F8FF	  1502: 	stw %a5,TCBAffinity[%a0]		# todo check size
01:00000C7C 45233100
01:00000C80 2E0830A7        	  1503: 	storei 16777216,TCBbrk[%a0]	# initialize the memory break virtual address
                            	  1504: .0005:
01:00000C84 4400FE7F        	  1505: 	loadi %a0,-1
01:00000C88 5A0EFD7F        	  1506: 	bl LockACBSemaphore
01:00000C8C 193940E1        	  1507: 		beq %cr0,.0005
01:00000C90 4F100000        	  1508: 		move %a0,%a1
                            	  1509: 		macACBHandleToPointer
01:00000C94 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000C98 42081C00        	     2M 	slli %a0,%a0,LOG_ACBSZ
01:00000C9C A6088007        	  1510: 		load %a1,ACBTaskList[%a0]
01:00000CA0 B440A006        	  1511: 		stptr %a1,TCBAcbNext[%a7]
01:00000CA4 740A8007        	  1512: 		stptr %t0,ACBTaskList[%a0]
                            	  1513: 	macUnlockACBSemaphore
01:00000CA8 2E000000        	     1M 	store %r0,ACBSEMA
01:00000CAC 6E418000        	  1514: 	store %a4,TCBxA0[%a7]				# place start parameter in a0 register
01:00000CB0 44000000        	  1515: 	loadi %a0,MF_IncreaseStackSize
01:00000CB4 0000000000000001	  1516: 	sys
01:00000CBC 45233100
01:00000CC0 03080000        	  1517: 	cmpi %cr0,%a0,0
01:00000CC4 583B40E1        	  1518: 	beq %cr0,.0003
01:00000CC8 44080000        	  1519: 	addi %a0,%a0,PGSZ
                            	  1520: #	addd	#PGSZ
01:00000CCC 74400000        	  1521: 	stptr %a0,TCBxSP[%a7]
01:00000CD0 3441A004        	  1522: 	stptr %a3,TCBxPC[%a7]				# set start address
01:00000CD4 4F500000        	  1523: 	move %a0,%t1
01:00000CD8 5A6A0000        	  1524: 	bl InsertIntoReadyQueue
01:00000CDC 03380000        	  1525: 	cmpi %cr0,%a6,0
01:00000CE0 D93940E1        	  1526:   beq %cr0,.0004						# we allow a null pointer here
01:00000CE4 070008E0        	  1527:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00000CE8 33000058        	  1528:   sync
01:00000CEC AE3A0000        	  1529: 	store %t1,[%a6]						# do the store to the proper address space
01:00000CF0 070008E0        	  1530:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00000CF4 33000058        	  1531:   sync
                            	  1532: .0004:
01:00000CF8 4400000000000800	  1533: 	loadi %a0,E_Ok
01:00000D00 1B00FE8F        	  1534: 	blr %br2
                            	  1535: .0002:
01:00000D04 44005A00        	  1536: 	loadi %a0,E_NoMoreTCBs	
01:00000D08 1B00FE8F        	  1537: 	blr %br2
                            	  1538: .0003:
01:00000D0C 44005C00        	  1539: 	loadi %a0,E_NoMem
01:00000D10 1B00FE8F        	  1540: 	blr %br2
                            	  1541: 
                            	  1542: #------------------------------------------------------------------------------
                            	  1543: #------------------------------------------------------------------------------
                            	  1544: 
                            	  1545: #------------------------------------------------------------------------------
                            	  1546: # Exit the current task. (remains to be done)
                            	  1547: #
                            	  1548: # Parameters:
                            	  1549: #		none
                            	  1550: # Modifies:
                            	  1551: #		%a1 = task id
                            	  1552: #------------------------------------------------------------------------------
                            	  1553: 
                            	  1554: FMTK_ExitTask:
01:00000D14 660000A0        	  1555: 	load %a0,RunningID
                            	  1556: 	# fall through to KillTask
                            	  1557: 	
                            	  1558: #------------------------------------------------------------------------------
                            	  1559: # Parameters:
                            	  1560: #		B = tid of task to kill
                            	  1561: #------------------------------------------------------------------------------
                            	  1562: 
                            	  1563: #------------------------------------------------------------------------------
                            	  1564: # ToDo: finish this routine
                            	  1565: #------------------------------------------------------------------------------
                            	  1566: 
                            	  1567: FMTK_KillTask:
01:00000D18 8F4A1400        	  1568: 	move %br2,%br1
                            	  1569: .0001:
01:00000D1C 4400FE7F        	  1570: 	loadi %a0,-1
01:00000D20 5ADAFC7F        	  1571: 	bl LockSysSemaphore
01:00000D24 D83840E1        	  1572: 	beq %cr0,.0001
                            	  1573: 	macGetRunningTCBPointer
01:00000D28 660000A0        	     1M 	load %a0,RunningID
                            	     2M 	macTCBHandleToPointer
01:00000D2C 4A0804A0        	     1M 	xori %a0,%a0,CB_XOR
01:00000D30 42081400        	     2M 	slli %a0,%a0,LOG_TCBSZ
01:00000D34 4F1000002800F8FF	  1574: 	move %a0,%a1
01:00000D3C 45233100
01:00000D40 5B580000        	  1575: 	bl RemoveFromReadyQueue
01:00000D44 5B5C0000        	  1576: 	bl RemoveFromTimeoutList
01:00000D48 E308E006        	  1577: 	ldwz %a2,TCBhMailboxes[%a0]
01:00000D4C 5A000000        	  1578: 	bl IFreeMBX
01:00000D50 E308E406        	  1579: 	ldwz %a2,TCBhMailboxes+2[%a0]
01:00000D54 5A000000        	  1580: 	bl IFreeMBX
01:00000D58 E308E806        	  1581: 	ldwz %a2,TCBhMailboxes+4[%a0]
01:00000D5C 5A000000        	  1582: 	bl IFreeMBX
01:00000D60 E308EC06        	  1583: 	ldwz %a2,TCBhMailboxes+6[%a0]
01:00000D64 5A000000        	  1584: 	bl IFreeMBX
                            	  1585: 	# Remove from list of tasks ACB has
01:00000D68 66085806        	  1586: 	load %a0,TCBappid[%a0]
01:00000D6C E6088007        	  1587: 	load %a2,ACBTaskList[%a0]
                            	  1588: 
                            	  1589: 	# Mark the TCB as free, it will be freed by SelectTaskToRun
                            	  1590: #	atom 63,"MMM"
                            	  1591: #	ldbz %a2,TCBStatus[]
                            	  1592: #	or %a2,%a2,TS_FREE
                            	  1593: #	stb %a2,TCBStatus[]
                            	  1594: 		
                            	  1595: #	cmpe	TCBxAccb,x
                            	  1596: #	beq		0002f
                            	  1597: #	tfr		e,b
                            	  1598: #	clra
                            	  1599: #	lbsr	macTCBHandleToPointer
                            	  1600: #	tfr		d,u
                            	  1601: #	ldf		TCBAcbNext,u
                            	  1602: #	cmpf	TCBxAccb,x
                            	  1603: #	beq		0003f
                            	  1604: 	
                            	  1605: 	
                            	  1606: #------------------------------------------------------------------------------
                            	  1607: # Link each message to the next in the free list.
                            	  1608: #------------------------------------------------------------------------------
                            	  1609: 
                            	  1610: InitFreeMessageList:
01:00000D70 440000A0        	  1611: 	loadi %a0,messages
01:00000D74 740004A000405800	  1612: 	stptr %a0,FreeMSG			# set start of free message list to first message
01:00000D7C CC00F8FF
01:00000D80 840000A0        	  1613: 	loadi %a1,messages	#+OBJ_SIZE
01:00000D84 44083800        	  1614: 	addi %a0,%a0,MSG_SIZE
                            	  1615: .0003:
01:00000D88 74100000        	  1616: 	stptr %a0,MSG_LINK[%a1]	# update link
01:00000D8C 44083800        	  1617: 	addi %a0,%a0,MSG_SIZE
01:00000D90 84103800        	  1618: 	addi %a1,%a1,MSG_SIZE		# increment to next message
01:00000D94 031204A0        	  1619: 	cmpai %cr0,%a1,messages_end	# done all messages?
01:00000D98 183846E1        	  1620: 	blt %cr0,.0003
01:00000D9C 8410C87F        	  1621: 	subi %a1,%a1,MSG_SIZE		# backup
01:00000DA0 34100000        	  1622: 	stptr %r0,MSG_LINK[%a1]	# update last link to null
01:00000DA4 1B00FE87        	  1623: 	blr
                            	  1624: 
                            	  1625: #------------------------------------------------------------------------------
                            	  1626: # Link each mailbox to the next in the free list.
                            	  1627: #------------------------------------------------------------------------------
                            	  1628: 
                            	  1629: InitFreeMailboxList:
01:00000DA8 440004A0        	  1630: 	loadi %a0,mailboxes
01:00000DAC 740008A0        	  1631: 	stptr %a0,FreeMBX			# set start of free mailbox list to first mailbox
01:00000DB0 840004A000405800	  1632: 	loadi %a1,mailboxes	#+OBJ_SIZE
01:00000DB8 00406800D000F8FF
01:00000DC0 44080200        	  1633: 	addi %a0,%a0,1
                            	  1634: .0003:
01:00000DC4 6E100000        	  1635: 	store %a0,MBX_LINK[%a1]	# update link
01:00000DC8 44085800        	  1636: 	addi %a0,%a0,MBX_SIZE
01:00000DCC 84105800        	  1637: 	addi %a1,%a1,MBX_SIZE		# increment to next mailbox
01:00000DD0 031200A0        	  1638: 	cmpai %cr0,%a1,mailboxes_end		# done all mailboxes?
01:00000DD4 993746E1        	  1639: 	blt %cr0,.0003
01:00000DD8 8410A87F        	  1640: 	subi %a1,%a1,MBX_SIZE		# backup
01:00000DDC 34100000        	  1641: 	stptr %r0,MBX_LINK[%a1]	# update last link to null
01:00000DE0 1B00FE87        	  1642: 	blr
                            	  1643: 
                            	  1644: #------------------------------------------------------------------------------
                            	  1645: # Link each TCB to the next in the free list.
                            	  1646: #------------------------------------------------------------------------------
                            	  1647: 
                            	  1648: InitFreeTCBList:
01:00000DE4 440004A0        	  1649: 	loadi %a0,tcbs
01:00000DE8 8F080000        	  1650: 	move %a1,%a0
01:00000DEC 740008A0        	  1651: 	stptr	%a0,FreeTCB
01:00000DF0 1AC4FF7F00406E00	  1652: 	b .0002
01:00000DF8 00401800C800F8FF
                            	  1653: .0001:
01:00000E00 74100000        	  1654: 	stptr %a0,TBCNext[%a1]
01:00000E04 84100008        	  1655: 	addi %a1,%a1,TCB_SIZE
                            	  1656: .0002:
01:00000E08 44100008        	  1657: 	addi %a0,%a1,TCB_SIZE
01:00000E0C 03120000        	  1658: 	cmpai %cr0,%a1,tcb_ends		# end of TCB array?
01:00000E10 583746E1        	  1659: 	blt %cr0,.0001
01:00000E14 84100078        	  1660: 	subi %a1,%a1,TCB_SIZE			# zero out the last link
01:00000E18 34100000        	  1661: 	stptr %r0,TBCNext[%a1]
01:00000E1C 1B00FE87        	  1662: 	blr
                            	  1663: 
                            	  1664: #------------------------------------------------------------------------------
                            	  1665: # Initialize Femtiki
                            	  1666: #------------------------------------------------------------------------------
                            	  1667: 
                            	  1668: FMTK_Init:
01:00000E20 8F4A1400        	  1669: 	move %br2,%br1
                            	  1670: 	# Clear out variable area
01:00000E24 840000A0        	  1671: 	loadi %a1,FemtikiVars
                            	  1672: .0001:
01:00000E28 2E100000        	  1673: 	store %r0,[%a1]
01:00000E2C 84100880        	  1674: 	add %a1,%a1,4
01:00000E30 03102880        	  1675: 	cmpa %cr0,%a1,FemtikiVars_end
01:00000E34 593746E1        	  1676: 	blt %cr0,.0001
01:00000E38 440002002000F8FF	  1677: 	loadi %a0,1
01:00000E40 6E0000A0        	  1678: 	store %a0,OSActive
01:00000E44 440004A0        	  1679: 	loadi %a0,acbs
01:00000E48 740008A0        	  1680: 	stptr %a0,RunningAID
01:00000E4C 44000CA0        	  1681: 	loadi %a0,tcbs
01:00000E50 740010A0        	  1682: 	stptr %a0,RunningID		# reset this
                            	  1683: 
                            	  1684: 	# Set stack bottoms for all the memory maps
01:00000E54 84000000        	  1685: 	loadi %a1,0
01:00000E58 44000000        	  1686: 	loadi %a0,MAXVPG
                            	  1687: .0003:
01:00000E5C 6E1014A0        	  1688: 	store %a0,MidStackBottoms[%a1]
01:00000E60 84100800        	  1689: 	addi %a1,%a1,4
01:00000E64 031000011001F8FF	  1690: 	cmpi %cr0,%a1,32*4
01:00000E6C 004010002400F8FF
01:00000E74 004018002800F8FF
01:00000E7C AC00F8FF
01:00000E80 983646E1        	  1691: 	blt %cr0,.0003
                            	  1692: 
01:00000E84 5B80FF7F        	  1693: 	bl InitFreeMessageList
01:00000E88 5A8CFF7F        	  1694: 	bl InitFreeMailboxList
01:00000E8C 5B96FF7F        	  1695: 	bl InitFreeTCBList
                            	  1696: 
                            	  1697: 	# Set interrupt groups
                            	  1698: 	# there is only 1 CPU ATM
                            	  1699: 	
01:00000E90 44000400        	  1700: 	loadi %a0,2
01:00000E94 840000A0        	  1701: 	loadi %a1,0xFEE20800
                            	  1702: .0002:
01:00000E98 6E100000        	  1703: 	store %a0,[%a1]
01:00000E9C 2E100800        	  1704: 	store %r0,4[%a1]
01:00000EA0 84101000        	  1705: 	addi %a1,%a1,8
01:00000EA4 031204A0        	  1706: 	cmpai %cr0,%a1,0xFEE21000
01:00000EA8 593656E1        	  1707: 	blt .0002
                            	  1708: 	
                            	  1709: 	# Set timer IRQ vector
                            	  1710: 
01:00000EAC 4400900B        	  1711: 	loadi %a0,FemtikiTimerISR
01:00000EB0 6E0008A00008E2FE	  1712: 	store %a0,0xFECC0000
01:00000EB8 0010E2FE0000CCFE
01:00000EC0 2E0000A0        	  1713: 	store %r0,0xFECC0004
01:00000EC4 2E0004A0        	  1714: 	store %r0,0xFECC0008
01:00000EC8 44000400        	  1715: 	loadi %a0,2								# enable interrupts,vector,swstk=0,CPU group #0
01:00000ECC 2E0008A0        	  1716: 	store %r0,0xFECC000C
                            	  1717: 
01:00000ED0 5BB6FF7F        	  1718: 	bl InitAppOne
01:00000ED4 5BC8FF7F        	  1719: 	bl InitTaskOne
                            	  1720: 
                            	  1721: 	# Map ACB into virtual address space at $600000
                            	  1722: #	ldd		#$094F00
                            	  1723: #	std		MMU+$600
                            	  1724: #	inca
                            	  1725: #	std		MMU+$602
01:00000ED8 1B00FE8F        	  1726: 	blr %br2
                            	  1727: 
                            	  1728: #------------------------------------------------------------------------------
                            	  1729: #------------------------------------------------------------------------------
                            	  1730: 
                            	  1731: InitAppOne:
01:00000EDC 44000CA0        	  1732: 	loadi %a0,acbs
01:00000EE0 84000000        	  1733: 	loadi %a1,0
                            	  1734: .0001:
01:00000EE4 2E080480        	  1735: 	store %r0,[%a0+%a1*]
01:00000EE8 84100800        	  1736: 	addi %a1,%a1,4
01:00000EEC 031010A00400CCFE	  1737: 	cmpi	%cr0,%a1,ACB_SIZE
01:00000EF4 0800CCFE0C00CCFE
01:00000EFC 00401000
01:00000F00 993546E1        	  1738: 	blt %cr0,.0001
01:00000F04 840000A0        	  1739: 	loadi %a1,('A' << 16) | ('C' << 8) | 'B'
01:00000F08 AE080000        	  1740: 	store %a1,ACBObject+OBJMagic[%a0]
01:00000F0C 2E089407        	  1741: 	store %r0,ACBmid[%a0]			# system uses map #0
01:00000F10 2E08A4A6        	  1742: 	storei 0xFEC00000,ACBpVidMem[%a0]
01:00000F14 2808C206        	  1743: 	stbi	64,ACBVideoCols[%a0]
01:00000F18 2808C006        	  1744: 	stbi	32,ACBVideoRows[%a0]
01:00000F1C 2808C606        	  1745: 	stb 	%r0,ACBCursorCol[%a0]
01:00000F20 2808C406        	  1746: 	stb		%r0,ACBCursorRow[%a0]
01:00000F24 2E08DC07        	  1747: 	storei	0xCE,ACBNormAttr[%a0]
01:00000F28 84000200        	  1748: 	loadi %a1,1
01:00000F2C A8089007        	  1749: 	stb		%a1,ACBHasFocus[%a0]
01:00000F30 A8088007        	  1750: 	stb		%a1,ACBTaskList[%a0]
01:00000F34 1B00FE8742434100	  1751: 	blr
01:00000F3C 0000C0FE
                            	  1752: 
                            	  1753: #------------------------------------------------------------------------------
                            	  1754: # When called, the context for the task has already been stored in the TCB.
                            	  1755: # Do not zero out the TCB!
                            	  1756: #------------------------------------------------------------------------------
                            	  1757: 
                            	  1758: InitTaskOne:
01:00000F40 8F4A1400        	  1759: 	move %br2,%br1
01:00000F44 440000A0        	  1760: 	loadi %a0,tcbs
01:00000F48 840004A0        	  1761: 	loadi %a1,acbs						# appid 1 is system app
01:00000F4C B4085806        	  1762: 	stptr %a1,TCBappid[%a0]
01:00000F50 28088A05        	  1763: 	stbi	1,TCBHasFocus[%a0]
01:00000F54 8F080000        	  1764: 	move %a1,%a0
01:00000F58 74104806        	  1765: 	stptr	%a0,TCBtid[%a1]
01:00000F5C 74100806        	  1766: 	stptr	%a0,TCBNext[%a1]
01:00000F60 74101806        	  1767: 	stptr	%a0,TCBPrev[%a1]
01:00000F64 28107805        	  1768: 	stbi TS_RUNNING,TCBStatus[%a1]
01:00000F68 28107E05        	  1769: 	stbi 31,TCBPriority[%a1]
01:00000F6C 5BC4FF7F        	  1770: 	bl InsertIntoReadyQueue
01:00000F70 1B00FE8F        	  1771: 	blr %br2
                            	  1772: 
                            	  1773: 
                            	  1774: .include "tcba.qpa"

Source: "tcba.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: #------------------------------------------------------------------------------
                            	    38: # IAllocTCB is called from the timer ISR. It must preserve any registers used.
                            	    39: #------------------------------------------------------------------------------
                            	    40: 
                            	    41: IAllocTCB:
01:00000F74 1E01004000401800	    42: 	push %a1-%a2
01:00000F7C 00401000
01:00000F80 660000A4        	    43: 	load. %a0,FreeTCB
01:00000F84 D93540E1        	    44: 	beq	%cr0,.0001
01:00000F88 A6080806        	    45: 	load %a1,TCBNext[%a0]
01:00000F8C B40000A0        	    46: 	stptr	%a1,FreeTCB
                            	    47: .0001:
01:00000F90 1F010040        	    48: 	pop %a1-%a2
01:00000F94 1B00FE87        	    49: 	blr
                            	    50: 
                            	    51: # Not called from anywhere
                            	    52: 
                            	    53: FMTK_AllocTCB:
01:00000F98 1B00FE87        	    54: 	blr %br1
                            	    55: 	
                            	    56: #------------------------------------------------------------------------------
                            	    57: # IFreeTCB is called from SelectTaskToRun (timer ISR)
                            	    58: #------------------------------------------------------------------------------
                            	    59: 
                            	    60: IFreeTCB:
01:00000F9C 1E010040        	    61: 	push %a1-%a2
01:00000FA0 A60000A0        	    62: 	load %a1,FreeTCB
01:00000FA4 B4080806        	    63: 	stptr %a1,TCBNext[%a0]
01:00000FA8 740000A0        	    64: 	stptr	%a0,FreeTCB
01:00000FAC 1F010040        	    65: 	pop %a1-%a2
01:00000FB0 1B00FE87        	    66: 	blr
                            	    67: 
                            	    68: #------------------------------------------------------------------------------
                            	    69: # FreeTCB does not actually free the TCB, instead it flags it as needed to be
                            	    70: # freed, and the scheduler frees it. It was done this way to avoid the need
                            	    71: # to lock the list with a semaphore which would cause a deadlock.
                            	    72: #------------------------------------------------------------------------------
                            	    73: 
                            	    74: FMTK_FreeTCB:
01:00000FB4 03080080        	    75: 	cmp %cr0,%a0,0
01:00000FB8 183648E1C800F8FF	    76: 	ble %cr0,.0001
01:00000FC0 2808B006        	    77: 	stbi TSC_FREE,TCBTsCmd[%a0]
01:00000FC4 44000000        	    78: 	loadi %a0,E_Ok
01:00000FC8 1B00FE87        	    79: 	blr
                            	    80: .0001:
01:00000FCC 44000E00        	    81: 	loadi %a0,E_NotAlloc
01:00000FD0 1B00FE87        	    82: 	blr
                            	    83: 
                            	    84: #------------------------------------------------------------------------------
                            	    85: # Push task into ready queue. The ready queue is a hardware component on the
                            	    86: # bus.
                            	    87: #
                            	    88: # Stack Space:
                            	    89: #		1 words
                            	    90: # Modifies:
                            	    91: #		none
                            	    92: # Parameters:
                            	    93: #		%a0 = task id to insert
                            	    94: #------------------------------------------------------------------------------
                            	    95: 
                            	    96: InsertIntoReadyQueue:
01:00000FD4 03080000        	    97: 	cmpi %cr0,%a0,0
01:00000FD8 583648E1        	    98: 	ble %cr0,.0001
01:00000FDC A1087A05        	    99: 	ldbz %a1,TCBPriority[%a0]
01:00000FE0 44010001        	   100: 	loadi %a4,TS_RUNNING
01:00000FE4 3B2800A2        	   101: 	amoorb %r0,%a4,TCBStatus[%a0]
01:00000FE8 88107E00        	   102: 	andi %a1,%a1,63							# safety, 0 to 63 for priority
01:00000FEC 82100400        	   103: 	slli %a1,%a1,2
01:00000FF0 6E100000        	   104: 	store %a0,RDYQ[%a1]
                            	   105: .0001:
01:00000FF4 1B00FE87        	   106: 	blr
                            	   107: 
                            	   108: #------------------------------------------------------------------------------
                            	   109: # Remove task from ready queue. Accomplished by clearing the ready / running
                            	   110: # status. The next time the queue is popped, the task will be discarded as
                            	   111: # a choice for running.
                            	   112: #
                            	   113: # Parameters:
                            	   114: #		%a0 = task id to remove
                            	   115: #------------------------------------------------------------------------------
                            	   116: 
                            	   117: RemoveFromReadyQueue:
01:00000FF8 03080000BC020000	   118: 	cmpi %cr0,%a0,0							# sanity check
01:00001000 993540E1        	   119: 	beq %cr0,.0001
01:00001004 8400FC7E        	   120: 	loadi %a1,~(TS_RUNNING|TS_READY)
01:00001008 3B1800A1        	   121: 	amoandb %r0,%a1,TCBStatus[%a0]
                            	   122: .0001:
01:0000100C 1B00FE87        	   123: 	blr
                            	   124: 	
                            	   125: #------------------------------------------------------------------------------
                            	   126: # Remove a task from the timeout list.
                            	   127: # Called when a mailbox is freed and a task is waiting at the
                            	   128: # mailbox.
                            	   129: #
                            	   130: # Parameters:
                            	   131: #		%a0 = task id to remove
                            	   132: # Modifies:
                            	   133: #		none
                            	   134: # Returns:
                            	   135: #		none
                            	   136: #------------------------------------------------------------------------------
                            	   137: 
                            	   138: RemoveFromTimeoutList:
01:00001010 9E070040        	   139: 	push %a0-%a4
01:00001014 A6000000        	   140: 	load %a1,TImeoutList
01:00001018 03080480        	   141: 	cmpa %cr0,%a0,%a1					# head of list?
01:0000101C 993640E1        	   142: 	beq	%cr0,.0001
01:00001020 CF080000        	   143: 	move %a2,%a0							# %a2 points to arg
                            	   144: 	# We want
                            	   145: 	# arg->next->prev = arg->prev
                            	   146: 	# arg->prev->next = arg->next
01:00001024 66180806        	   147: 	load %a0,TCBNext[%a2]
01:00001028 8F080000        	   148: 	move %a1,%a0
01:0000102C 66181806        	   149: 	load %a0,TCBPrev[%a2]
01:00001030 0F090000        	   150: 	move %a3,%a0
                            	   151: 	# Here:
                            	   152: 	# %a1 = arg->next
                            	   153: 	# %a3 = arg->prev
01:00001034 66191806        	   154: 	load %a4,TCBPrev[%a2]
01:00001038 74211806BC020000	   155: 	stptr %a4,TCBPrev[%a3]
01:00001040 66190806        	   156: 	load %a4,TCBNext[%a2]
01:00001044 74110806        	   157: 	stptr %a4,TCBNext[%a1]
01:00001048 1BAEFF7F        	   158: 	b	.0002
                            	   159: 	# Removing from head of timeout list
                            	   160: .0001:
01:0000104C A6080806        	   161: 	load %a1,TCBNext[%a0]
01:00001050 B40000A0        	   162: 	stptr	%a1,TimeoutList		# set new head of list
01:00001054 CF080000        	   163: 	move %a2,%a0
01:00001058 4F100000        	   164: 	move %a0,%a1
01:0000105C 34081806        	   165: 	stptr	%r0,TCBPrev[%a0]		# next->prev = NULL
                            	   166: .0002:
01:00001060 34180806        	   167: 	stptr	%r0,TCBNext[%a2]		# arg->next = NULL
01:00001064 34181806        	   168: 	stptr %r0,TCBPrev[%a2]		# arg->prev = NULL
01:00001068 9F070040        	   169: 	pop %a0-%a4
01:0000106C 1B00FE87        	   170: 	blr
                            	   171: 	
                            	   172: #// ----------------------------------------------------------------------------
                            	   173: #// Pop the top entry from the timeout list.
                            	   174: #// ----------------------------------------------------------------------------
                            	   175: #
                            	   176: #hTCB PopTimeoutList()
                            	   177: #{
                            	   178: #    TCB *p;
                            	   179: #    hTCB h;
                            	   180: #
                            	   181: #    h = TimeoutList;
                            	   182: #    if (TimeoutList > 0 && TimeoutList < NR_TCB) {
                            	   183: #        TimeoutList = tcbs[TimeoutList].next;
                            	   184: #        if (TimeoutList >= 0 && TimeoutList < NR_TCB) {
                            	   185: #            tcbs[TimeoutList].prev = h->prev;
                            	   186: #            h->prev->next = TimeoutList;
                            	   187: #        }
                            	   188: #    }
                            	   189: #    return h;
                            	   190: #}
                            	   191: #
                            	   192: # Returns:
                            	   193: #		B = task at top of list
                            	   194: #
                            	   195: 
                            	   196: PopTimeoutList:
01:00001070 9E030040        	   197: 	push %a0-%a3
01:00001074 660000A4        	   198: 	load. %a0,TimeoutList
01:00001078 993640E1D400F8FF	   199: 	beq	%cr0,.0001
01:00001080 A6080806        	   200: 	load. %a1,TCBNext[%a0]
01:00001084 E6081806        	   201: 	load %a2,TCBPrev[%a0]
01:00001088 B40000A0        	   202: 	stptr %a1,TimeoutList
01:0000108C 183640E1        	   203: 	beq	%cr0,.0001
01:00001090 0F090000        	   204: 	move %a3,%a0
01:00001094 4F100000        	   205: 	move %a0,%a1
01:00001098 F4081806        	   206: 	stptr %a2,TCBPrev[%a0]
01:0000109C 4F180000        	   207: 	move %a0,%a2
01:000010A0 B4080806        	   208: 	stptr %a1,TCBNext[%a0]
01:000010A4 34201806        	   209: 	stptr %r0,TCBPrev[%a3]
01:000010A8 34200806        	   210: 	stptr %r0,TCBNext[%a3]
                            	   211: .0001:
01:000010AC 9F030040        	   212: 	pop %a0-%a3
01:000010B0 1B00FE87        	   213: 	blr
                            	   214: 
                            	   215: # ----------------------------------------------------------------------------
                            	   216: # ----------------------------------------------------------------------------
                            	   217: 
                            	   218: DispTwoSpace:
01:000010B4 1E000448        	   219: 	push %br1
01:000010B8 5AAAFF7FD400F8FF	   220: 	bl DispSpace
01:000010C0 1F000448        	   221: 	pop %br1
                            	   222: DispSpace:
01:000010C4 44000000        	   223: 	loadi %a0,MF_OUTCH
01:000010C8 84004000        	   224: 	loadi %a1,' '
01:000010CC 00000000        	   225: 	sys
01:000010D0 1B00FE87        	   226: 	blr
                            	   227: 
                            	   228: DumpTCBs:
01:000010D4 1E000448        	   229: 	push %br1
01:000010D8 44000000        	   230: 	loadi %a0,MF_CRLF
01:000010DC 00000000        	   231: 	sys
01:000010E0 440000A0        	   232: 	loadi %a0,tcbs
                            	   233: .0002:
01:000010E4 0F090000        	   234: 	move %a3,%a0
01:000010E8 A6084806        	   235: 	load %a1,TCBtid[%a0]
01:000010EC 44000000        	   236: 	loadi %a0,MF_DisplayTetraAsHex
01:000010F0 00000000        	   237: 	sys
01:000010F4 5B9AFF7F        	   238: 	bl DispSpace
01:000010F8 4400000000401800	   239: 	loadi %a0,MF_DisplayByteAsHex
01:00001100 E1207805        	   240: 	ldbz %a2,TCBStatus[%a3]
01:00001104 00000000        	   241: 	sys
01:00001108 5B92FF7F        	   242: 	bl DispTwoSpace
01:0000110C 44000000        	   243: 	loadi %a0,MF_CRLF
01:00001110 00000000        	   244: 	sys
01:00001114 66200806        	   245: 	load. %a0,TCBNext[%a3]
01:00001118 583380E0        	   246: 	bne %cr0,.0002			# could use PRED here
                            	   247: .0001:
01:0000111C 1F000448        	   248: 	pop %br1
01:00001120 1B00FE87        	   249: 	blr
                            	   250: 	
01:00001124 5449442053746174	   251: .byte	"TID Stat"
                            	   252: 
                            	   253: 

Source: "Femtikia.qpa"
                            	  1775: .include "msga.qpa"

Source: "msga.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: #include "..\..\inc\config.qpa"
                            	    38: #include "..\..\inc\const.qpa"
                            	    39: #include "..\..\inc\types.qpa"
                            	    40: ##include "..\..\inc\io_equates.qpa"
                            	    41: #include ".\Femtiki_vars.qpa"
                            	    42: 
                            	    43: # ---------------------------------------------------------------
                            	    44: # ---------------------------------------------------------------
                            	    45: 
                            	    46: .macro macMBXPointerToHandle
                            	    47: 	xor %a0,%a0,0x12345678
                            	    48: .endm
                            	    49: 
                            	    50: .macro macMBXHandleToPointer
                            	    51: 	xor. %a0,%a0,0x12345678
                            	    52: .endm
                            	    53: 
                            	    54: # ---------------------------------------------------------------
                            	    55: #	Description:
                            	    56: #		Copy a message. Assumes guarded by messasge semaphore.
                            	    57: # Stack Space:
                            	    58: #		1 word
                            	    59: # Parameters:
                            	    60: #		%a0 = destination message
                            	    61: #		%a1 = source message
                            	    62: # ---------------------------------------------------------------
                            	    63: 
                            	    64: CopyMsg:
01:0000112C 1E020040        	    65: 	push %a2
01:00001130 E6101800        	    66: 	load %a2,MSGType[%a1]
01:00001134 EE081800        	    67: 	store %a2,MSGType[%a0]
01:00001138 E6100800        	    68: 	load %a2,MSGRetAdr[%a1]
01:0000113C EE080800        	    69: 	store %a2,MSGRetAdr[%a0]
01:00001140 E6101000        	    70: 	load %a2,MSGDestAdr[%a1]
01:00001144 EE081000        	    71: 	store %a2,MSGDestAdr[%a0]
01:00001148 2E08FE7F        	    72: 	storei -1,MSGLink[%a0]
01:0000114C E6102000        	    73: 	load %a2,MSGD1[%a1]
01:00001150 EE082000        	    74: 	store %a2,MSGD1[%a0]
01:00001154 E6102800        	    75: 	load %a2,MSGD2[%a1]
01:00001158 EE082800        	    76: 	store %a2,MSGD2[%a0]
01:0000115C E6103000        	    77: 	load %a2,MSGD3[%a1]
01:00001160 EE083000        	    78: 	store %a2,MSGD3[%a0]
01:00001164 1F020040        	    79: 	pop %a2
01:00001168 1B00FE87        	    80: 	blr
                            	    81: 
                            	    82: # ---------------------------------------------------------------
                            	    83: #	Description:
                            	    84: #		Freeup message and add back to free list. Assumes the message
                            	    85: # semaphore is guarding the operation.
                            	    86: #
                            	    87: # Stack Space:
                            	    88: #		1 word
                            	    89: # Parameters:
                            	    90: #		%a0 = pointer to message
                            	    91: # ---------------------------------------------------------------
                            	    92: 
                            	    93: FreeMsg:
01:0000116C 1E010040        	    94: 	push %a1
01:00001170 2E081800        	    95: 	storei MT_FREE,MSGType[%a0]
01:00001174 2E08FE7F        	    96: 	storei -1,MSGRetAdr[%a0]
01:00001178 2E08FE7F        	    97: 	storei -1,MSGDEstAdr[%a0]
01:0000117C A6000000        	    98: 	load %a1,freeMSG
01:00001180 AE080000        	    99: 	store %a1,MSGLink[%a0]
01:00001184 6E000000        	   100: 	store %a0,freeMSG
01:00001188 3B08C0A0        	   101: 	amoadd %r0,1,nMsgBlk
01:0000118C 1F010040        	   102: 	pop %a1
01:00001190 1B00FE87        	   103: 	blr
                            	   104: 
                            	   105: # ---------------------------------------------------------------
                            	   106: #	Description:
                            	   107: #		Queue a message at a mailbox.
                            	   108: #
                            	   109: #	Assumptions:
                            	   110: #		valid mailbox parameter.
                            	   111: #
                            	   112: #	Called from:
                            	   113: #		SendMsg
                            	   114: #		PostMsg
                            	   115: # Parameters:
                            	   116: #		%a0 = pointer to mailbox
                            	   117: #		%a1 = pointer to message
                            	   118: # ---------------------------------------------------------------
                            	   119: 
                            	   120: QueueMsg:
01:00001194 1E000448        	   121: 	push %br1
01:00001198 1E060040        	   122: 	push %a2-%a4
01:0000119C 44010000        	   123: 	loadi %a4,E_Ok
01:000011A0 CF080000        	   124: 	move %a2,%a0
01:000011A4 4400FE7F        	   125: 	loadi %a0,-1
01:000011A8 5AD4FB7F        	   126: 	bl LockMSGSemaphore
01:000011AC 983C40E1        	   127: 	beq %cr0,.0001
01:000011B0 3B18C0A0        	   128: 	amoadd %r0,1,MBXMQCount[%a2]
01:000011B4 6618500000000000	   129: 	load %a0,MBXMQStrategy[%a2]
01:000011BC 1C000000
01:000011C0 03080000        	   130: 	cmpi %cr0,%a0,MQS_UNLIMITED
01:000011C4 983A40E1        	   131: 	beq %cr0,.0002
01:000011C8 03080000        	   132: 	cmpi %cr0,%a0,MQS_NEWEST
01:000011CC 593680E0        	   133: 	bne %cr0,.0005
                            	   134: .0008:
01:000011D0 66183800        	   135: 	load %a0,MBXMQCount[%a2]
01:000011D4 26194000        	   136: 	load %a3,MBXMQSize[%a2]
01:000011D8 03080880        	   137: 	cmpa %cr0,%a0,%a3
01:000011DC 993A58E1        	   138: 	ble .0004
01:000011E0 66182800        	   139: 	load %a0,MBXMQHead[%a2]
01:000011E4 26090000        	   140: 	load %a3,MSGLink[%a0]
01:000011E8 5B86FF7F        	   141: 	bl FreeMsg
01:000011EC 3BF8C0A0        	   142: 	amoadd %r0,-1,MBXMQCount[%a2]
01:000011F0 2E192800        	   143: 	store %a3,MBXMQHead[%a2]
01:000011F4 66184804        	   144: 	load. %a0,MBXMQMissed[%a2]
01:000011F8 D83486E01C000000	   145: 	bge %cr0,.0007
01:00001200 3B18C0A0        	   146: 	amoadd %r0,1,MBXMQMissed[%a2]
                            	   147: .0007:
01:00001204 44010A00        	   148: 	loadi %a4,E_QueFull
01:00001208 1A96FF7F        	   149: 	b .0008
                            	   150: .0005:
01:0000120C 03080000        	   151: 	cmpi %cr0,%a0,MQS_OLDEST
01:00001210 183980E0        	   152: 	bne %cr0,.0004
01:00001214 66183800        	   153: 	load %a0,MBXMQCount[%a2]
01:00001218 26194000        	   154: 	load %a3,MBXMQSize[%a2]
01:0000121C 03080880        	   155: 	cmpa %cr0,%a0,%a3
01:00001220 193558E1        	   156: 	ble .0009
01:00001224 4F100000        	   157: 	move %a0,%a1										# free up passed in message
01:00001228 5B76FF7F        	   158: 	bl FreeMsg
01:0000122C 3BF8C0A0        	   159: 	amoadd %r0,-1,MBXMQCount[%a2]
01:00001230 2E192800        	   160: 	store %a3,MBXMQHead[%a2]
01:00001234 6618480424000000	   161: 	load. %a0,MBXMQMissed[%a2]
01:0000123C 1C000000
                            	   162: .0009:
01:00001240 66183800        	   163: 	load %a0,MBXMQCount[%a2]
01:00001244 26194000        	   164: 	load %a3,MBXMQSize[%a2]
01:00001248 03080880        	   165: 	cmpa %cr0,%a0,%a3
01:0000124C 183648E1        	   166: 	ble %cr0,.00010
01:00001250 66182800        	   167: 	load %a0,MBXMQHead[%a2]
01:00001254 26193000        	   168: 	load %a3,MBXMQTail[%a2]
                            	   169: .00012:
01:00001258 03080880        	   170: 	cmp %cr0,%a0,%a3
01:0000125C 993440E1        	   171: 	beq %cr0,.00011
01:00001260 8F080000        	   172: 	move %a1,%a0										# msg = tmpmsg
01:00001264 6E080000        	   173: 	store %a0,MSGLink[%a0]
01:00001268 1B9CFF7F        	   174: 	b .00012
                            	   175: .00011:
01:0000126C AE183000        	   176: 	store %a1,MBXMQTail[%a2]				# mbx->mq_tail = msg
01:00001270 5B64FF7F        	   177: 	bl FreeMsg										# FreeMsg(tmpmsg)
01:00001274 66184804        	   178: 	load. %a0,MBXMQMissed[%a2]
01:00001278 593486E0        	   179: 	bge %cr0,.00013
01:0000127C 3B18C0A0        	   180: 	amoadd %r0,1,MBXMQMissed[%a2]
                            	   181: .00013:
01:00001280 3BF8C0A0        	   182: 	amoadd %r0,-1,MBXMQCount[%a2]
01:00001284 04010A00        	   183: 	loadi r4,E_QueFull
                            	   184: .00010:
01:00001288 03280A00        	   185: 	cmpi %cr0,%a4,E_QueFull
01:0000128C 593540E1        	   186: 	beq %cr0,.00014
                            	   187: .0002:
01:00001290 66183004        	   188: 	load. %a0,MBXMQTail[%a2]
01:00001294 D83446E1        	   189: 	blt %cr0,.0003
01:00001298 46083800        	   190: 	mulai %a0,%a0,MSG_SIZE						# x bytes per message
01:0000129C 270908A0        	   191: 	loada %a3,messages[%a0]
01:000012A0 AE200000        	   192: 	store %a1,MSGLink[%a3]					# 	message[mbx->mq_tail].link = msg
01:000012A4 1BA2FF7F        	   193: 	b .0004												# else
                            	   194: .0003:
01:000012A8 AE182800        	   195: 	store %a1,MBXMQHead[%a2]				#		mbx->mq_head = msg
                            	   196: .0004:
01:000012AC AE183000        	   197: 	store %a1,MBXMQTail[%a2]				# mbx->mq_tail = msg
01:000012B0 2E10FE7F24000000	   198: 	storei -1,MSGLink[%a1]					# msg->link = -1
01:000012B8 1C00000000405800
                            	   199: .00014:
                            	   200: 	macUnlockMSGSemaphore
01:000012C0 2E000000        	     1M 	store %r0,MSGSEMA
                            	   201: .0001:
01:000012C4 4F280000        	   202: 	move %a0,%a4
01:000012C8 1F060040        	   203: 	pop %a2-%a4
01:000012CC 1F000448        	   204: 	pop %br1
01:000012D0 1B00FE87        	   205: 	blr	
                            	   206: 
                            	   207: # ---------------------------------------------------------------
                            	   208: #	Description:
                            	   209: #		Dequeues a message from a mailbox.
                            	   210: #
                            	   211: #	Assumptions:
                            	   212: #		Mailbox parameter is valid.
                            	   213: #		System semaphore is locked already.
                            	   214: #
                            	   215: #	Called from:
                            	   216: #		FreeMbx - (locks mailbox)
                            	   217: #		WaitMsg	-	"
                            	   218: #		CheckMsg-	"
                            	   219: # Parameters:
                            	   220: #		%a0 = pointer to mailbox
                            	   221: # ---------------------------------------------------------------
                            	   222: 
                            	   223: DequeueMsg:
01:000012D4 1E010040        	   224: 	push %a1-%a2
01:000012D8 8F080000        	   225: 	move %a1,%a0
01:000012DC 44000000        	   226: 	loadi %a0,0
01:000012E0 E6103804        	   227: 	load. %a2,MBXMQCount[%a1]
01:000012E4 D93440E1        	   228: 	beq %cr0,.0001
01:000012E8 3BF8C0A0        	   229: 	amoadd %r0,-1,MBXMQCount[%a1]
01:000012EC 66102804        	   230: 	load. %a0,MBXMQHead[%a1]
01:000012F0 983446E1        	   231: 	blt %cr0,.0001
01:000012F4 E6080004        	   232: 	load. %a2,MSGLink[%a0]
01:000012F8 EE1028001C000000	   233: 	store %a2,MBXMQHead[%a1]
01:00001300 D93386E0        	   234: 	bge %cr0,.0002
01:00001304 2E10FE7F        	   235: 	storei -1,MBXMQTail[%a1]
                            	   236: .0002:
01:00001308 6E080000        	   237: 	store %a0,MSGLink[%a0]
                            	   238: .0001:
01:0000130C 1F010040        	   239: 	pop %a1-%a2
01:00001310 1B00FE87        	   240: 	blr
                            	   241: 
                            	   242: # ---------------------------------------------------------------
                            	   243: #	Description:
                            	   244: #		Dequeues a task from a mailbox. The task will also
                            	   245: #	be removed from the timeout list (if it's present there),
                            	   246: #	and	the timeout list will be adjusted accordingly.
                            	   247: #
                            	   248: #	Assumptions:
                            	   249: #		Mailbox parameter is valid.
                            	   250: # Parameters:
                            	   251: #		%a0 = pointer to mailbox
                            	   252: # Returns:
                            	   253: #		%a0 = error code
                            	   254: #		%a1 = task
                            	   255: # ---------------------------------------------------------------
                            	   256: 
                            	   257: DequeTaskFromMbx:
01:00001314 03080000        	   258: 	cmpi %cr0,%a0,0			# mbx null?
01:00001318 193940E1        	   259: 	beq %cr0,.0001
01:0000131C 1E060040        	   260: 	push %a2-%a4				# save %a2,%a3,%a4
01:00001320 CF080000        	   261: 	move %a2,%a0
01:00001324 4400FE7F        	   262: 	loadi %a0,-1
01:00001328 5A74FB7F        	   263: 	bl LockMSGSemaphore
01:0000132C 183840E1        	   264: 	beq %cr0,.0006
01:00001330 66181000        	   265: 	load %a0,MBXTQHead[%a2]
01:00001334 0310FE7F        	   266: 	cmpi %cr0,%a1,-1
01:00001338 983480E0        	   267: 	bne %cr0,.0002
                            	   268: 	macUnlockMSGSemaphore
01:0000133C 2E000000        	     1M 	store %r0,MSGSEMA
01:00001340 84000000        	   269: 	loadi %a1,0
01:00001344 44000000        	   270: 	loadi %a0,E_NoTask
01:00001348 1F060040        	   271: 	pop %a2-%a4
01:0000134C 1F000448        	   272: 	pop %br1
01:00001350 1B00FE87        	   273: 	blr
                            	   274: .0002:
01:00001354 3BF8C0A0        	   275: 	amoadd %r0,-1,MBXTQCount[%a2]
01:00001358 26191000        	   276: 	load %a3,MBXTQHead[%a2]
01:0000135C 8F200000        	   277: 	move %a1,%a3
01:00001360 66210004        	   278: 	load. %a4,TCBMBQNext[%a3]
01:00001364 6E191000        	   279: 	store %a4,MBXTQHead[%a2]
01:00001368 183448E1        	   280: 	ble %cr0,.0003
01:0000136C EE270000        	   281: 	store -1,TCBMBQPrev[%a3]
01:00001370 1B9EFF7F        	   282: 	b .0004
                            	   283: .0003:
01:00001374 2E18FE7F        	   284: 	storei -1,MBXTQTail[%a2]
                            	   285: .0004:
                            	   286: 	macUnlockMSGSemaphore
01:00001378 2E00000010000000	     1M 	store %r0,MSGSEMA
01:00001380 03200080        	   287: 	cmp %cr0,%a3,0
01:00001384 D83440E1        	   288: 	beq %cr0,.0005
01:00001388 66217805        	   289: 	load %a4,TCBStatus[%a3]
01:0000138C 08800A84        	   290: 	and. %r0,TS_TIMEOUT,%a4
01:00001390 D93340E1        	   291: 	beq %cr0,.0007
01:00001394 4F200000        	   292: 	move %a0,%a3
01:00001398 5AC8FE7F        	   293: 	bl RemoveFromTimeoutList
                            	   294: .0007:
01:0000139C 2E20FE7F        	   295: 	storei -1,TCBMBQNext[%a3]
01:000013A0 2E20FE7F        	   296: 	storei -1,TCBMBQPrev[%a3]
01:000013A4 2E20FE7F        	   297: 	storei -1,TCBhWaitMbx[%a3]	# no longer waiting at mailbox
01:000013A8 3BB800A1        	   298: 	amoandb %r0,~TS_WAITMSG,TCBStatus[%a3]
                            	   299: .0005:
01:000013AC 44000000        	   300: 	loadi %a0,E_Ok
01:000013B0 1F060040        	   301: 	pop %a2-%a4
01:000013B4 1F000448        	   302: 	pop %br1
01:000013B8 1B00FE87BC020000	   303: 	blr
                            	   304: 	# Here the semaphore could not be locked
                            	   305: .0006:
01:000013C0 44000000        	   306: 	loadi %a0,E_Busyed
01:000013C4 1F060040        	   307: 	pop %a2-%a4
01:000013C8 1F000448        	   308: 	pop %br1
01:000013CC 1B00FE87        	   309: 	blr
                            	   310: 	# Here there was a problem with an argument
                            	   311: .0001:
01:000013D0 44000200        	   312: 	loadi %a0,E_Arg
01:000013D4 1B00FE87        	   313:   blr
                            	   314: 
                            	   315: # ---------------------------------------------------------------
                            	   316: #	Description:
                            	   317: #		Allocate a mailbox. The default queue strategy is to
                            	   318: #	queue the eight most recent messages.
                            	   319: #
                            	   320: # Parameters:
                            	   321: #		%a1 = pointer to place to store mailbox handle
                            	   322: # ---------------------------------------------------------------
                            	   323: 
                            	   324: FMTK_AllocMbx:
01:000013D8 03100000        	   325: 	cmpi %cr0,%a1,0
01:000013DC D83380E0        	   326: 	bne %cr0,.0001
01:000013E0 44000200        	   327: 	loadi %a0,E_Arg
01:000013E4 1B00FE87        	   328: 	blr
                            	   329: .0001:
01:000013E8 1E020040        	   330: 	push %a2-%a3					# save %a2,%a3
01:000013EC 4400FE7F        	   331: 	loadi %a0,-1
01:000013F0 5A42FB7F        	   332: 	bl LockMSGSemaphore
01:000013F4 183840E1        	   333: 	beq %cr0,.0002
01:000013F8 66000004        	   334: 	load. %a0,freeMBX
01:000013FC D83340E1        	   335: 	beq %cr0,.0003
01:00001400 0308FE7F        	   336: 	cmpi %cr0,%a0,-1
01:00001404 193480E0        	   337: 	bne %cr0,.0004
                            	   338: .0003:
                            	   339: 	macUnlockMSGSemaphore
01:00001408 2E000000        	     1M 	store %r0,MSGSEMA
01:0000140C 44005000        	   340: 	loadi %a0,E_NoMoreMbx
01:00001410 1F020040        	   341: 	pop %a2-%a3
01:00001414 1F000448        	   342: 	pop %br1
01:00001418 1B00FE87        	   343: 	blr
                            	   344: .0004:
01:0000141C E6080800        	   345: 	load %a2,MBXLink[%a0]
01:00001420 EE000000        	   346: 	store %a2,freeMBX
01:00001424 3BF8C0A0        	   347: 	amoadd %r0,-1,nMailbox
                            	   348: 	macUnlockMSGSemaphore
01:00001428 2E000000        	     1M 	store %r0,MSGSEMA
01:0000142C CF080000        	   349: 	move %a2,%a0
                            	   350: 	macMBXPointerToHandle
01:00001430 4A083080        	     1M 	xor %a0,%a0,0x12345678
01:00001434 07000CE0C000F8FF	   351:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:0000143C 00000800
01:00001440 33000058        	   352:   sync
01:00001444 6E100000        	   353: 	store %a0,[%a1]						# do the store to the proper address space
01:00001448 070008E0        	   354:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:0000144C 33000058        	   355:   sync
01:00001450 8F180000        	   356: 	move %a1,%a2
01:00001454 5A000000        	   357: 	bl GetAppHandle
01:00001458 68100000        	   358: 	stb %a0,MBXOwner[%a1]
01:0000145C 2E10FE7F        	   359: 	storei -1,MBXTQHead[%a1]
01:00001460 2E10FE7F        	   360: 	storei -1,MBXTQTail[%a1]
01:00001464 2E10FE7F        	   361: 	storei -1,MBXMQHead[%a1]
01:00001468 2E10FE7F        	   362: 	storei -1,MBXMQTail[%a1]
01:0000146C 2E102000        	   363: 	store %r0,MBXTQCount[%a1]
01:00001470 2E103800        	   364: 	store %r0,MBXMQCount[%a1]
01:00001474 2E104800        	   365: 	store %r0,MBXMQMissed[%a1]
01:00001478 2E10500000000800	   366: 	storei 8,MBXMQSize[%a1]
01:00001480 2E105000        	   367: 	storei MQS_NEWEST,MBXMQStrategy[%a1]
01:00001484 44000000        	   368: 	loadi %a0,E_Ok
01:00001488 1F020040        	   369: 	pop %a2-%a3
01:0000148C 1F000448        	   370: 	pop %br1
01:00001490 1B00FE87        	   371: 	blr
                            	   372: .0002:
01:00001494 44001C00        	   373: 	loadi %a0,E_Busy
01:00001498 1F020040        	   374: 	pop %a2-%a3
01:0000149C 1F000448        	   375: 	pop %br1
01:000014A0 1B00FE87        	   376: 	blr
                            	   377: 
                            	   378: # ---------------------------------------------------------------
                            	   379: #	Description:
                            	   380: #		Free up a mailbox. When the mailbox is freed any queued
                            	   381: #	messages must be freed. Any queued threads must also be
                            	   382: #	dequeued. 
                            	   383: #
                            	   384: # Parameters:
                            	   385: #		%a1 = handle of mailbox
                            	   386: # ---------------------------------------------------------------
                            	   387: 
                            	   388: FMTK_FreeMbx:
01:000014A4 4F100000        	   389: 	move %a0,%a1
                            	   390: 	macMBXHandleToPointer
01:000014A8 4A083084        	     1M 	xor. %a0,%a0,0x12345678
01:000014AC 193940E1        	   391: 	beq %cr0,.0001
01:000014B0 1E000448        	   392: 	push %br1
01:000014B4 1E010040        	   393: 	push %a1-%a2						# save %a1,%a2
01:000014B8 8F080000        	   394: 	move %a1,%a0
01:000014BC 4400FE7F        	   395: 	loadi %a0,-1
01:000014C0 5A0EFB7F        	   396: 	bl LockMSGSemaphore
01:000014C4 D93740E1        	   397: 	beq %cr0,.0002
01:000014C8 5A000000        	   398: 	bl GetAppHandle
01:000014CC E1100100        	   399: 	ldbz. %a2,MBXOwner[%a1]
01:000014D0 183440E1        	   400: 	beq %cr0,.0003
01:000014D4 03080680        	   401: 	cmp %cr0,%a0,%a2
01:000014D8 D83340E1        	   402: 	beq %cr0,.0003
                            	   403: 	macUnlockMSGSemaphore
01:000014DC 2E000000        	     1M 	store %r0,MSGSEMA
01:000014E0 44001800        	   404: 	loadi %a0,E_NotOwner
01:000014E4 1F010040        	   405: 	pop %a1-%a2
01:000014E8 1F000448        	   406: 	pop %br1
01:000014EC 1B00FE87        	   407: 	blr
                            	   408: 	# Free up any queued messages
                            	   409: .0003:
01:000014F0 4F100000        	   410: 	move %a0,%a1
01:000014F4 5A16FF7F        	   411: 	bl DequeueMsg
01:000014F8 03080000        	   412: 	cmpi %cr0,%a0,0
01:000014FC 593340E1        	   413: 	beq %cr0,.0004
01:00001500 5BC0FE7F        	   414: 	bl FreeMsg
01:00001504 1B92FF7F        	   415: 	b .0003
                            	   416: .0004:
01:00001508 4F100000        	   417: 	move %a0,%a1
01:0000150C CF100000        	   418: 	move %a2,%a1
01:00001510 5A1EFF7F        	   419: 	bl DequeTaskFromMbx
01:00001514 4F100000        	   420: 	move %a0,%a1
01:00001518 8F180000        	   421: 	move %a1,%a2
01:0000151C 183440E1        	   422: 	beq %cr0,.0005
01:00001520 2E085007        	   423: 	storei MT_NONE,TCBMsg+MSGType[%a0]
01:00001524 3B88C1A1        	   424: 	amoand. %r0,TS_TIMEOUT,TCBStatus[%a0]
01:00001528 583340E1        	   425: 	beq %cr0,.0006
01:0000152C 5B62FE7F        	   426: 	bl RemoveFromTimeoutList
                            	   427: .0006:
01:00001530 5A54FE7F        	   428: 	bl InsertIntoReadyQueue
01:00001534 8F180000        	   429: 	move %a1,%a2
01:00001538 1A8CFF7FBC020000	   430: 	b .0004
                            	   431: .0005:
01:00001540 66000000        	   432: 	load %a0,freeMBX
01:00001544 6E100800        	   433: 	store %a0,MBXLink[%a1]
01:00001548 AE000000        	   434: 	store %a1,freeMBX
01:0000154C 3B08C0A0        	   435: 	amoadd %r0,1,nMailbox
                            	   436: 	macUnlockMSGSemaphore
01:00001550 2E000000        	     1M 	store %r0,MSGSEMA
01:00001554 44000000        	   437: 	loadi %a0,E_Ok
01:00001558 1F010040        	   438: 	pop %a1-%a2
01:0000155C 1F000448        	   439: 	pop %br1
01:00001560 1B00FE87        	   440: 	blr
                            	   441: .0002:
01:00001564 44001C00        	   442: 	loadi %a0,E_Busy
01:00001568 1F010040        	   443: 	pop %a1-%a2
01:0000156C 1F000448        	   444: 	pop %br1
01:00001570 1B00FE87        	   445: 	blr
                            	   446: .0001:
01:00001574 44000200        	   447: 	loadi %a0,E_Arg
01:00001578 1B00FE87C000F8FF	   448: 	blr
                            	   449: 	
                            	   450: # ---------------------------------------------------------------
                            	   451: #	Description:
                            	   452: #		Set the mailbox message queueing strategy.
                            	   453: # ---------------------------------------------------------------
                            	   454: 
                            	   455: SetMbxMsgQueStrategy:
01:00001580 03080000        	   456: 	cmpi %cr0,%a0,0
01:00001584 983640E1        	   457: 	beq %cr0,.0001
01:00001588 03120400        	   458: 	cmpai %cr0,%a1,2
01:0000158C 583688E0        	   459: 	bgt %cr0,.0001
01:00001590 1E000448        	   460: 	push %br1
01:00001594 1E040040        	   461: 	push %a3-%a4						# save %a3,%a4
01:00001598 0F090000        	   462: 	move %a3,%a0
01:0000159C 4400FE7F        	   463: 	loadi %a0,-1
01:000015A0 5AD6FA7F        	   464: 	bl LockMSGSemaphore
01:000015A4 183540E1        	   465: 	beq %cr0,.0002
                            	   466: 	# Check if this app owns the mailbox
01:000015A8 5A000000        	   467: 	bl GetAppHandle
01:000015AC D93340E1        	   468: 	beq %cr0,.0003
01:000015B0 61210000        	   469: 	ldbz %a4,MBXOwner[%a3]
01:000015B4 03080880        	   470: 	cmp %cr0,%a0,%a3
01:000015B8 983340E1        	   471: 	beq %cr0,.0003
                            	   472: 	macUnlockMSGSemaphore
01:000015BC 2E000000        	     1M 	store %r0,MSGSEMA
01:000015C0 44001800        	   473: 	loadi %a0,E_NotOwner
01:000015C4 1F040040        	   474: 	pop %a3-%a4
01:000015C8 1F000448        	   475: 	pop %br1
01:000015CC 1B00FE87        	   476: 	blr
                            	   477: .0003:
01:000015D0 AE205000        	   478: 	store %a1,MBXMQStrategy[%a3]
01:000015D4 EE204000        	   479: 	store %a2,MBXMQSize[%a3]
                            	   480: 	macUnlockMSGSemaphore
01:000015D8 2E000000        	     1M 	store %r0,MSGSEMA
01:000015DC 44000000        	   481: 	loadi %a0,E_Ok
01:000015E0 1F040040        	   482: 	pop %a3-%a4
01:000015E4 1F000448        	   483: 	pop %br1
01:000015E8 1B00FE87        	   484: 	blr
                            	   485: .0002:
01:000015EC 44001C00        	   486: 	loadi %a0,E_Busy
01:000015F0 1F040040        	   487: 	pop %a3-%a4
01:000015F4 1F000448        	   488: 	pop %br1
01:000015F8 1B00FE87        	   489: 	blr
                            	   490: .0001:
01:000015FC 44000200        	   491: 	loadi %a0,E_Arg
01:00001600 1B00FE87        	   492: 	blr
                            	   493: 
                            	   494: # ---------------------------------------------------------------
                            	   495: #	Description:
                            	   496: #		Send a message.
                            	   497: # Parameters:
                            	   498: #		%a1 = handle of mailbox
                            	   499: #		%a2 = message data #1
                            	   500: #		%a3 = message data #2
                            	   501: #		%a4 = message data #3
                            	   502: # ---------------------------------------------------------------
                            	   503: 
                            	   504: FMTK_SendMsg:
01:00001604 4F100000        	   505: 	move %a0,%a1
                            	   506: 	macMBXHandleToPointer
01:00001608 4A083084        	     1M 	xor. %a0,%a0,0x12345678
01:0000160C 03080000        	   507: 	cmpi %cr0,%a0,0
01:00001610 593B40E1        	   508: 	beq %cr0,.0001
01:00001614 1E000448        	   509: 	push %br1
01:00001618 1E300040        	   510: 	push %a5-%a7						# Save %a5,%a6,%a7
01:0000161C 04020000        	   511: 	loadi %a7,0							# thrd = null
01:00001620 8F090000        	   512: 	move %a5,%a0
01:00001624 4400FE7F        	   513: 	loadi %a0,-1
01:00001628 5AB4FA7F        	   514: 	bl LockMSGSemaphore
01:0000162C 183740E1        	   515: 	beq %cr0,.0002
01:00001630 66300004        	   516: 	load. %a0,MBXOwner[%a5]
01:00001634 D83386E0        	   517: 	bge %cr0,.0003
01:00001638 03080000        	   518: 	cmpi %cr0,%a0,NR_ACB
01:0000163C 983348E1        	   519: 	ble %cr0,.0003
                            	   520: 	macUnlockMSGSemaphore
01:00001640 2E000000        	     1M 	store %r0,MSGSEMA
01:00001644 44000E00        	   521: 	loadi %a0,E_NotAlloc
01:00001648 1F300040        	   522: 	pop %a5-%a7
01:0000164C 1F000448        	   523: 	pop %br1
01:00001650 1B00FE87        	   524: 	blr
                            	   525: .0003:
01:00001654 66000004        	   526: 	load. %a0,freeMSG
01:00001658 193340E1        	   527: 	beq %cr0,.0005
01:0000165C 0308FE7F        	   528: 	cmpi %cr0,%a0,-1
01:00001660 983380E0        	   529: 	bne %cr0,.0004
                            	   530: .0005:
                            	   531: 	macUnlockMSGSemaphore
01:00001664 2E000000        	     1M 	store %r0,MSGSEMA
01:00001668 44005200        	   532: 	loadi %a0,E_NoMoreMsgBlks
01:0000166C 1F300040        	   533: 	pop %a5-%a7
01:00001670 1F000448        	   534: 	pop %br1
01:00001674 1B00FE87        	   535: 	blr
                            	   536: .0004:
01:00001678 CF090000        	   537: 	move %a6,%a0
01:0000167C 66380000        	   538: 	load %a0,MSGLink[%a6]
01:00001680 6E000000        	   539: 	store %a0,freeMSG
01:00001684 3BF8C0A0        	   540: 	amoadd %r0,-1,nMsgBlk
01:00001688 5A000000        	   541: 	bl GetAppHandle
01:0000168C 68380800        	   542: 	stb %a0,MSGRetAdr[%a6]
01:00001690 AE391000        	   543: 	store %a5,MSGDestAdr[%a6]
01:00001694 2E381800        	   544: 	storei MBT_DATA,MSGType[%a6]
01:00001698 EE382000        	   545: 	store %a2,MSGD1[%a6]
01:0000169C 2E392800        	   546: 	store %a3,MSGD2[%a6]
01:000016A0 6E393000        	   547: 	store %a4,MSGD3[%a6]
01:000016A4 4F380000        	   548: 	move %a0,%a6
01:000016A8 5AB8FE7F        	   549: 	bl DequeTaskFromMbx
01:000016AC 0F120000        	   550: 	move %a7,%a1					# %a7 = pointer to dequeued task
                            	   551: 	macUnlockMSGSemaphore
01:000016B0 2E000000        	     1M 	store %r0,MSGSEMA
                            	   552: .0002:
01:000016B4 03400000        	   553: 	cmpi %cr0,%a7,0
01:000016B8 993380E000000000	   554: 	bne %cr0,.0006
01:000016C0 4F300000        	   555: 	move %a0,%a5					# %a0 = pointer to mailbox
01:000016C4 8F380000        	   556: 	move %a1,%a6					# %a1 = pointer to message
01:000016C8 5B58FE7F        	   557: 	bl QueueMsg
01:000016CC 1F300040        	   558: 	pop %a5-%a7
01:000016D0 1F000448        	   559: 	pop %br1
01:000016D4 1B00FE87        	   560: 	blr
                            	   561: .0006:
01:000016D8 4400FE7F        	   562: 	loadi %a0,-1
01:000016DC 5B86FA7F        	   563: 	bl LockMSGSemaphore
01:000016E0 593440E1        	   564: 	beq %cr0,.0008
01:000016E4 67403807        	   565: 	loada %a0,TCBMsg[%a7]
01:000016E8 8F380000        	   566: 	move %a1,%a6
01:000016EC 5A36FE7F        	   567: 	bl CopyMsg
01:000016F0 5B44FE7F        	   568: 	bl FreeMsg
01:000016F4 66407805        	   569: 	load %a0,TCBStatus[%a7]
01:000016F8 08082084        	   570: 	and. %r0,%a0,TS_TIMEOUT
01:000016FC 183340E1        	   571: 	beq %cr0,.0007
01:00001700 4F400000        	   572: 	move %a0,%a7
01:00001704 5BECFD7F        	   573: 	bl RemoveFromTimeoutList
                            	   574: .0007:
01:00001708 4F400000        	   575: 	move %a0,%a7
01:0000170C 5BDCFD7F        	   576: 	bl InsertIntoReadyQueue
                            	   577: 	macUnlockMSGSemaphore
01:00001710 2E000000        	     1M 	store %r0,MSGSEMA
                            	   578: 	# The ready queue changed, maybe a different task is higher priority,
                            	   579: 	# invoke scheduling
01:00001714 CDADFB7F        	   580: 	bli FemtikiTimerISR
                            	   581: .0008:
01:00001718 44000000        	   582: 	loadi %a0,E_Ok
01:0000171C 1F300040        	   583: 	pop %a5-%a7
01:00001720 1F000448        	   584: 	pop %br1
01:00001724 1B00FE87        	   585: 	blr
                            	   586: .0001:
01:00001728 44000200        	   587: 	loadi %a0,E_Arg
01:0000172C 1B00FE87        	   588: 	blr
                            	   589: 	
                            	   590: 
                            	   591: # ---------------------------------------------------------------
                            	   592: #	Description:
                            	   593: #		PostMsg() is meant to be called in order to send a
                            	   594: #	message without causing the thread to switch. This is
                            	   595: #	useful in some cases. For example interrupts that don't
                            	   596: #	require a low latency. Normally SendMsg() will be called,
                            	   597: #	even from an ISR to allow the OS to prioritize events.
                            	   598: # ---------------------------------------------------------------
                            	   599: 
                            	   600: FMTK_PostMsg:
01:00001730 4F100000        	   601: 	move %a0,%a1
                            	   602: 	macMBXHandleToPointer
01:00001734 4A083084        	     1M 	xor. %a0,%a0,0x12345678
01:00001738 03080000        	   603: 	cmpi %cr0,%a0,0
01:0000173C 193B40E1        	   604: 	beq %cr0,.0001
01:00001740 1E000448        	   605: 	push %br1
01:00001744 1E300040        	   606: 	push %a5-%a7						# Save %a5,%a6,%a7
01:00001748 04020000        	   607: 	loadi %a7,0							# thrd = null
01:0000174C 8F090000        	   608: 	move %a5,%a0
01:00001750 4400FE7F        	   609: 	loadi %a0,-1
01:00001754 5B68FA7F        	   610: 	bl LockMSGSemaphore
01:00001758 D93640E1        	   611: 	beq %cr0,.0002
01:0000175C 66300004        	   612: 	load. %a0,MBXOwner[%a5]
01:00001760 993386E0        	   613: 	bge %cr0,.0003
01:00001764 03080000        	   614: 	cmpi %cr0,%a0,NR_ACB
01:00001768 593348E1        	   615: 	ble %cr0,.0003
                            	   616: 	macUnlockMSGSemaphore
01:0000176C 2E000000        	     1M 	store %r0,MSGSEMA
01:00001770 44000E00        	   617: 	loadi %a0,E_NotAlloc
01:00001774 1F300040        	   618: 	pop %a5-%a7
01:00001778 1F000448        	   619: 	pop %br1
01:0000177C 1B00FE87        	   620: 	blr
                            	   621: .0003:
01:00001780 66000004        	   622: 	load. %a0,freeMSG
01:00001784 183340E1        	   623: 	beq %cr0,.0005
01:00001788 0308FE7F        	   624: 	cmpi %cr0,%a0,-1
01:0000178C 593380E0        	   625: 	bne %cr0,.0004
                            	   626: .0005:
                            	   627: 	macUnlockMSGSemaphore
01:00001790 2E000000        	     1M 	store %r0,MSGSEMA
01:00001794 44005200        	   628: 	loadi %a0,E_NoMoreMsgBlks
01:00001798 1F300040        	   629: 	pop %a5-%a7
01:0000179C 1F000448        	   630: 	pop %br1
01:000017A0 1B00FE87        	   631: 	blr
                            	   632: .0004:
01:000017A4 CF090000        	   633: 	move %a6,%a0
01:000017A8 66380000        	   634: 	load %a0,MSGLink[%a6]
01:000017AC 6E000000        	   635: 	store %a0,freeMSG
01:000017B0 3BF8C0A0        	   636: 	amoadd %r0,-1,nMsgBlk
01:000017B4 5A000000        	   637: 	bl GetAppHandle
01:000017B8 6838080000000000	   638: 	stb %a0,MSGRetAdr[%a6]
01:000017C0 AE391000        	   639: 	store %a5,MSGDestAdr[%a6]
01:000017C4 2E381800        	   640: 	storei MBT_DATA,MSGType[%a6]
01:000017C8 EE382000        	   641: 	store %a2,MSGD1[%a6]
01:000017CC 2E392800        	   642: 	store %a3,MSGD2[%a6]
01:000017D0 6E393000        	   643: 	store %a4,MSGD3[%a6]
01:000017D4 4F380000        	   644: 	move %a0,%a6
01:000017D8 5A6CFE7F        	   645: 	bl DequeTaskFromMbx
01:000017DC 0F120000        	   646: 	move %a7,%a1					# %a7 = pointer to dequeued task
                            	   647: 	macUnlockMSGSemaphore
01:000017E0 2E000000        	     1M 	store %r0,MSGSEMA
                            	   648: .0002:
01:000017E4 03400000        	   649: 	cmpi %cr0,%a7,0
01:000017E8 593380E0        	   650: 	bne %cr0,.0006
01:000017EC 4F300000        	   651: 	move %a0,%a5					# %a0 = pointer to mailbox
01:000017F0 8F380000        	   652: 	move %a1,%a6					# %a1 = pointer to message
01:000017F4 5A0EFE7F        	   653: 	bl QueueMsg
01:000017F8 1F300040        	   654: 	pop %a5-%a7
01:000017FC 1F000448        	   655: 	pop %br1
01:00001800 1B00FE87        	   656: 	blr
                            	   657: .0006:
01:00001804 4400FE7F        	   658: 	loadi %a0,-1
01:00001808 5A3CFA7F        	   659: 	bl LockMSGSemaphore
01:0000180C 193440E1        	   660: 	beq %cr0,.0008
01:00001810 67403807        	   661: 	loada %a0,TCBMsg[%a7]
01:00001814 8F380000        	   662: 	move %a1,%a6
01:00001818 5BEAFD7F        	   663: 	bl CopyMsg
01:0000181C 5AFAFD7F        	   664: 	bl FreeMsg
01:00001820 66407805        	   665: 	load %a0,TCBStatus[%a7]
01:00001824 08082084        	   666: 	and. %r0,%a0,TS_TIMEOUT
01:00001828 D93240E1        	   667: 	beq %cr0,.0007
01:0000182C 4F400000        	   668: 	move %a0,%a7
01:00001830 5AA2FD7F        	   669: 	bl RemoveFromTimeoutList
                            	   670: .0007:
01:00001834 4F400000        	   671: 	move %a0,%a7
01:00001838 5A92FD7F        	   672: 	bl InsertIntoReadyQueue
                            	   673: 	macUnlockMSGSemaphore
01:0000183C 2E000000        	     1M 	store %r0,MSGSEMA
                            	   674: .0008:
01:00001840 44000000        	   675: 	loadi %a0,E_Ok
01:00001844 1F300040        	   676: 	pop %a5-%a7
01:00001848 1F000448        	   677: 	pop %br1
01:0000184C 1B00FE87        	   678: 	blr
                            	   679: .0001:
01:00001850 44000200        	   680: 	loadi %a0,E_Arg
01:00001854 1B00FE87        	   681: 	blr
                            	   682: 
                            	   683: # ---------------------------------------------------------------
                            	   684: #	Description:
                            	   685: #		Wait for message. If timelimit is zero then the thread
                            	   686: #	will wait indefinately for a message.
                            	   687: #
                            	   688: # Parameters:
                            	   689: #		%a1 = mailbox handle
                            	   690: #		%a2 = pointer to place to store D1
                            	   691: #		%a3 = pointer to place to store D2
                            	   692: #		%a4 = pointer to place to store D3
                            	   693: #		%a5 = time limit
                            	   694: # ---------------------------------------------------------------
                            	   695: 
                            	   696: FMTK_WaitMsg:
01:00001858 4F100000        	   697: 	move %a0,%a1
                            	   698: 	macMBXHandleToPointer
01:0000185C 4A083084        	     1M 	xor. %a0,%a0,0x12345678
01:00001860 03080000        	   699: 	cmpi %cr0,%a0,0
01:00001864 98024001        	   700: 	beq %cr0,.0001
01:00001868 1E000448        	   701: 	push %br1
01:0000186C 1E200640        	   702: 	push %a6-%t1						# Save %a6,%a7,%t0,%t1
01:00001870 04020000        	   703: 	loadi %a7,0							# thrd = null
01:00001874 CF090000        	   704: 	move %a6,%a0							# %a6 = pointer to mailbox
01:00001878 4400FE7F        	   705: 	loadi %a0,-1
01:0000187C 5B1EFA7F        	   706: 	bl LockMSGSemaphore
01:00001880 193440E1        	   707: 	beq %cr0,.0002
01:00001884 66380004        	   708: 	load. %a0,MBXOwner[%a6]
01:00001888 983386E0        	   709: 	bge %cr0,.0003
01:0000188C 03080000        	   710: 	cmpi %cr0,%a0,NR_ACB
01:00001890 583348E1        	   711: 	ble %cr0,.0003
                            	   712: 	macUnlockMSGSemaphore
01:00001894 2E000000        	     1M 	store %r0,MSGSEMA
01:00001898 44000E00        	   713: 	loadi %a0,E_NotAlloc
01:0000189C 1F200640        	   714: 	pop %a6-%t1
01:000018A0 1F000448        	   715: 	pop %br1
01:000018A4 1B00FE87        	   716: 	blr
                            	   717: .0003:
01:000018A8 4F380000        	   718: 	move %a0,%a6
01:000018AC 5A28FE7F        	   719: 	bl DequeueMsg
                            	   720: 	macUnlockMSGSemaphore
01:000018B0 2E000000        	     1M 	store %r0,MSGSEMA
                            	   721: .0002:
01:000018B4 03080000        	   722: 	cmpi %cr0,%a0,0
01:000018B8 183740E1        	   723: 	beq %cr0,.0004
01:000018BC 03180000        	   724: 	cmpi %cr0,%a2,0
01:000018C0 593340E1        	   725: 	beq %cr0,.0005
01:000018C4 660A2000        	   726: 	load %t0,MSGD1[%a0]
01:000018C8 070008E0        	   727:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:000018CC 33000058        	   728:   sync
01:000018D0 6E1A0000        	   729: 	store %t0,[%a2]						# do the store to the proper address space
01:000018D4 070008E0        	   730:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:000018D8 33000058        	   731:   sync
                            	   732: .0005:
01:000018DC 03200000        	   733: 	cmpi %cr0,%a3,0
01:000018E0 593340E1        	   734: 	beq %cr0,.0006
01:000018E4 660A2800        	   735: 	load %t0,MSGD2[%a0]
01:000018E8 070008E0        	   736:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:000018EC 33000058        	   737:   sync
01:000018F0 6E220000        	   738: 	store %t0,[%a3]						# do the store to the proper address space
01:000018F4 070008E0        	   739:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:000018F8 3300005800000800	   740:   sync
                            	   741: .0006:
01:00001900 03280080        	   742: 	cmp %cr0,%a4,0
01:00001904 583340E1        	   743: 	beq %cr0,.0007
01:00001908 660A3000        	   744: 	load %t0,MSGD3[%a0]
01:0000190C 070008E0        	   745:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001910 33000058        	   746:   sync
01:00001914 6E2A0000        	   747: 	store %t0,[%a4]						# do the store to the proper address space
01:00001918 070008E0        	   748:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:0000191C 33000058        	   749:   sync
                            	   750: .0007:
01:00001920 4F0A0000        	   751: 	move %t0,%a0
01:00001924 4400FE7F        	   752: 	loadi %a0,-1
01:00001928 5AF4F97F        	   753: 	bl LockMSGSemaphore
01:0000192C D93240E1        	   754: 	beq %cr0,.0008
01:00001930 4F480000        	   755: 	move %a0,%t0
01:00001934 5AB4FD7F        	   756: 	bl FreeMsg
                            	   757: 	macUnlockMSGSemaphore
01:00001938 2E00000000000800	     1M 	store %r0,MSGSEMA
                            	   758: .0008:
01:00001940 44000000        	   759: 	loadi %a0,E_Ok
01:00001944 1F200640        	   760: 	pop %a6-%t1
01:00001948 1F000448        	   761: 	pop %br1
01:0000194C 1B00FE87        	   762: 	blr
                            	   763: 	# Here there was no messag available
                            	   764: .0004:
01:00001950 5A000000        	   765: 	bl GetRunningTCBPtr
01:00001954 5A000000        	   766: 	bl RemoveFromReadyList
01:00001958 3B48C0A2        	   767: 	amoor %r0,TS_WAITMSG,TCBStatus[%a0]
01:0000195C B4080000        	   768: 	stptr %a1,TCBhWaitMbx[%a0]
01:00001960 8402FE7F        	   769: 	loadi %t1,-1
01:00001964 740A0000        	   770: 	stptr %t0,TCBMBQNext[%a0]
01:00001968 4F0A0000        	   771: 	move %t0,%a0								# %t0 = thread
01:0000196C 4400FE7F        	   772: 	loadi %a0,-1
01:00001970 5AE2F97F        	   773: 	bl LockMSGSemaphore
01:00001974 03100000        	   774: 		cmpi %cr0,%a1,0
01:00001978 993240E1BC020000	   775: 		beq %cr0,.0009
01:00001980 0310FE7F        	   776: 		cmpi %cr0,%a1,-1
01:00001984 D93280E0        	   777: 		bne %cr0,.0010
                            	   778: .0009:
01:00001988 B44A0000        	   779: 		stptr %t1,TCBMBXPrev[%t0]
01:0000198C 74121000        	   780: 		stptr %t0,MBXTQHead[%a1]
01:00001990 74121800        	   781: 		stptr %t0,MBXTQTail[%a1]
01:00001994 AE122000        	   782: 		store %t1,MBXTQCount[%a1]
01:00001998 1B96FF7F        	   783: 		b .0011
                            	   784: .0010:
01:0000199C 26121800        	   785: 		load %a7,MBXTQTail[%a1]
01:000019A0 344A0000        	   786: 		stptr %a7,TCBMBXPrev[%t0]
01:000019A4 74420000        	   787: 		stptr %t0,TCBMBQNext[%a7]
01:000019A8 74121800        	   788: 		stptr %t0,MBXTQTail[%a1]
01:000019AC 3B18C0A0        	   789: 		amoadd %r0,1,MBXTQCount[%a1]
                            	   790: .0011:
                            	   791: 	macUnlockMSGSemaphore
01:000019B0 2E000000        	     1M 	store %r0,MSGSEMA
01:000019B4 03300000        	   792: 	cmpi %cr0,%a5,0							# is there a time limit specified?
01:000019B8 D83348E110000000	   793: 	ble %cr0,.0012
01:000019C0 4F480000        	   794: 	move %a0,%t0
01:000019C4 8F300000        	   795: 	move %a1,%a5
01:000019C8 5A000000        	   796: 	bl InsertIntoTimeoutList
                            	   797: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                            	   798:   # Reschedule will cause control to pass to another thread. This thread is
                            	   799:   # waiting.
01:000019CC CDFFFA7F        	   800: 	bli FemtikiTimerISR
                            	   801: 	# Control will return here as a result of a SendMsg or a timeout expiring
                            	   802: 	# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
01:000019D0 5A000000        	   803: 	bl GetRunningTCBPtr
01:000019D4 660A5007        	   804: 	load %t0,TCBMsg+MSGType[%a0]
01:000019D8 03480000        	   805: 	cmpi %cr0,%t0,MT_NONE
01:000019DC 993280E0        	   806: 	bne %cr0,.0012
01:000019E0 44001000        	   807: 	loadi %a0,E_NoMsg
01:000019E4 1F200640        	   808: 	pop %a6-%t1
01:000019E8 1F000448        	   809: 	pop %br1
01:000019EC 1B00FE87        	   810: 	blr
                            	   811: .0012:
01:000019F0 66083807        	   812: 	load %a0,TCBMsg[%a0]
01:000019F4 2E081800        	   813: 	storei MT_NONE,MSGType[%a0]
01:000019F8 8402FE7F        	   814: 	loadi %t1,-1
01:000019FC B40A1000        	   815: 	stptr %t1,MSGDestAdr[%a0]
01:00001A00 B40A0800        	   816: 	stptr %t1,MSGRetAdr[%a0]
01:00001A04 03180000        	   817: 	cmpi %cr0,%a2,0
01:00001A08 D93240E1        	   818: 	beq %cr0,.0013
01:00001A0C 660A2000        	   819: 	load %t0,MSGD1[%a0]
01:00001A10 070008E0        	   820:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001A14 33000058        	   821:   sync
01:00001A18 6E1A0000        	   822: 	store %t0,[%a2]						# do the store to the proper address space
01:00001A1C 070008E0        	   823:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001A20 33000058        	   824:   sync
                            	   825: .0013:
01:00001A24 03200080        	   826: 	cmp %cr0,%a3,0
01:00001A28 D93240E1        	   827: 	beq %cr0,.0014
01:00001A2C 660A2800        	   828: 	load %t0,MSGD2[%a0]
01:00001A30 070008E0        	   829:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001A34 33000058        	   830:   sync
01:00001A38 6E22000000000800	   831: 	store %t0,[%a3]						# do the store to the proper address space
01:00001A40 070008E0        	   832:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001A44 33000058        	   833:   sync
                            	   834: .0014:
01:00001A48 03280000        	   835: 	cmpi %cr0,%a4,0
01:00001A4C D83240E1        	   836: 	beq %cr0,.0015
01:00001A50 660A3000        	   837: 	load %t0,MSGD3[%a0]
01:00001A54 070008E0        	   838:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001A58 33000058        	   839:   sync
01:00001A5C 6E2A0000        	   840: 	store %t0,[%a4]						# do the store to the proper address space
01:00001A60 070008E0        	   841:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001A64 33000058        	   842:   sync
                            	   843: .0015:
01:00001A68 44000000        	   844: 	loadi %a0,E_Ok
01:00001A6C 1F200640        	   845: 	pop %a6-%t1
01:00001A70 1F000448        	   846: 	pop %br1
01:00001A74 1B00FE87        	   847: 	blr
                            	   848: 	# Bad arg return
                            	   849: .0001:
01:00001A78 4400020000000800	   850: 	loadi %a0,E_Arg
01:00001A80 1B00FE87        	   851: 	blr
                            	   852: 
                            	   853: # ----------------------------------------------------------------------------
                            	   854: # PeekMsg()
                            	   855: #     Look for a message in the queue but don't remove it from the queue.
                            	   856: #     This is a convenince wrapper for CheckMsg().
                            	   857: # Parameters:
                            	   858: #		%a1 = mailbox handle
                            	   859: #		%a2 = pointer to place to store D1
                            	   860: #		%a3 = pointer to place to store D2
                            	   861: #		%a4 = pointer to place to store D3
                            	   862: # ----------------------------------------------------------------------------
                            	   863: 
                            	   864: FMTK_PeekMsg:
01:00001A84 84010000        	   865: 	loadi %a5,0
                            	   866: 	# Fall through
                            	   867: 
                            	   868: # ---------------------------------------------------------------
                            	   869: #	Description:
                            	   870: #		Check for message at mailbox. If no message is
                            	   871: #	available return immediately to the caller (CheckMsg() is
                            	   872: #	non blocking). Optionally removes the message from the
                            	   873: #	mailbox.
                            	   874: #
                            	   875: # Parameters:
                            	   876: #		%a1 = mailbox handle
                            	   877: #		%a2 = pointer to place to store D1
                            	   878: #		%a3 = pointer to place to store D2
                            	   879: #		%a4 = pointer to place to store D3
                            	   880: #		%a5 = 1 = remove from queue
                            	   881: # ---------------------------------------------------------------
                            	   882: 
                            	   883: FMTK_CheckMsg:
01:00001A88 4F100000        	   884: 	move %a0,%a1
                            	   885: 	macMBXHandleToPointer
01:00001A8C 4A083084        	     1M 	xor. %a0,%a0,0x12345678
01:00001A90 03080000        	   886: 	cmpi %cr0,%a0,0
01:00001A94 183A40E1        	   887: 	beq %cr0,.0001
01:00001A98 1E000448        	   888: 	push %br1
01:00001A9C 1E200240        	   889: 	push %a6-%t0						# Save %a6,%a7,%t0
01:00001AA0 CF090000        	   890: 	move %a6,%a0							# %a6 = pointer to mailbox
01:00001AA4 04020000        	   891: 	loadi %a7,0
01:00001AA8 4400FE7F        	   892: 	loadi %a0,-1
01:00001AAC 5B92F97F        	   893: 	bl LockMSGSemaphore
01:00001AB0 D93340E1        	   894: 	beq %cr0,.0002
01:00001AB4 66380004        	   895: 	load. %a0,MBXOwner[%a6]
01:00001AB8 D83286E0        	   896: 	bge %cr0,.0003
01:00001ABC 03080000        	   897: 	cmpi %cr0,%a0,NR_ACB
01:00001AC0 983248E1        	   898: 	ble %cr0,.0003
                            	   899: 	macUnlockMSGSemaphore
01:00001AC4 2E000000        	     1M 	store %r0,MSGSEMA
01:00001AC8 44000E00        	   900: 	loadi %a0,E_NotAlloc
01:00001ACC 1F200240        	   901: 	pop %a6-%t0
01:00001AD0 1F000448        	   902: 	pop %br1
01:00001AD4 1B00FE87        	   903: 	blr
                            	   904: .0003:
01:00001AD8 03300200        	   905: 	cmpi %cr0,%a5,1
01:00001ADC 583280E0        	   906: 	bne %cr0,.0004
01:00001AE0 4F380000        	   907: 	move %a0,%a6
01:00001AE4 5A9AFD7F        	   908: 	bl DequeueMsg
01:00001AE8 1A90FF7F        	   909: 	b .0005
                            	   910: .0004:
01:00001AEC 263A2800        	   911: 	load %a7,MBXMQHead[%a6]
                            	   912: .0005:
                            	   913: 	macUnlockMSGSemaphore
01:00001AF0 2E000000        	     1M 	store %r0,MSGSEMA
                            	   914: .0002:
01:00001AF4 03400000        	   915: 	cmpi %cr0,%a7,0
01:00001AF8 593280E0        	   916: 	bne %cr0,.0006
01:00001AFC 44001000        	   917: 	loadi %a0,E_NoMsg
01:00001B00 1F200240        	   918: 	pop %a6-%t0
01:00001B04 1F000448        	   919: 	pop %br1
01:00001B08 1B00FE87        	   920: 	blr
                            	   921: .0006:
01:00001B0C 03180000        	   922: 	cmpi %cr0,%a2,0
01:00001B10 993240E1        	   923: 	beq %cr0,.0013
01:00001B14 66422000        	   924: 	load %t0,MSGD1[%a7]
01:00001B18 070008E0        	   925:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001B1C 33000058        	   926:   sync
01:00001B20 6E1A0000        	   927: 	store %t0,[%a2]						# do the store to the proper address space
01:00001B24 070008E0        	   928:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001B28 33000058        	   929:   sync
                            	   930: .0013:
01:00001B2C 03200000        	   931: 	cmpi %cr0,%a3,0
01:00001B30 993240E1        	   932: 	beq %cr0,.0014
01:00001B34 66422800        	   933: 	load %t0,MSGD2[%a7]
01:00001B38 070008E000000800	   934:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001B40 33000058        	   935:   sync
01:00001B44 6E220000        	   936: 	store %t0,[%a3]						# do the store to the proper address space
01:00001B48 070008E0        	   937:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001B4C 33000058        	   938:   sync
                            	   939: .0014:
01:00001B50 03280000        	   940: 	cmpi %cr0,%a4,0
01:00001B54 983240E1        	   941: 	beq %cr0,.0015
01:00001B58 66423000        	   942: 	load %t0,MSGD3[%a7]
01:00001B5C 070008E0        	   943:   csrrsi %r0,M_SR,0x80000		# set MPRV bit
01:00001B60 33000058        	   944:   sync
01:00001B64 6E2A0000        	   945: 	store %t0,[%a4]						# do the store to the proper address space
01:00001B68 070008E0        	   946:   csrrci %r0,M_SR,0x80000		# reset MPRV bit
01:00001B6C 33000058        	   947:   sync
                            	   948: .0015:
01:00001B70 03300200        	   949: 	cmpi %cr0,%a5,1						# remove msg from que?
01:00001B74 983280E0        	   950: 	bne %cr0,.0016
01:00001B78 4400FE7F00000800	   951: 	loadi %a0,-1
01:00001B80 5A5EF97F        	   952: 	bl LockMSGSemaphore
01:00001B84 183240E1        	   953: 	beq %cr0,.0016
01:00001B88 4F400000        	   954: 	move %a0,%a7
01:00001B8C 5A1EFD7F        	   955: 	bl FreeMsg
                            	   956: 	macUnlockMSGSemaphore
01:00001B90 2E000000        	     1M 	store %r0,MSGSEMA
                            	   957: .0016:
01:00001B94 44000000        	   958: 	loadi %a0,E_Ok
01:00001B98 1F200240        	   959: 	pop %a6-%t0
01:00001B9C 1F000448        	   960: 	pop %br1
01:00001BA0 1B00FE87        	   961: 	blr
                            	   962: 	# Bad arg return
                            	   963: .0001:
01:00001BA4 44000200        	   964: 	loadi %a0,E_Arg
01:00001BA8 1B00FE87        	   965: 	blr
                            	   966: 

Source: "Femtikia.qpa"
                            	  1776: .include "../mem_support.qpa"

Source: "..\mem_support.qpa"
                            	     1: # ============================================================================
                            	     2: #        __
                            	     3: #   \\__/ o\    (C) 2020-2025  Robert Finch, Waterloo
                            	     4: #    \  __ /    All rights reserved.
                            	     5: #     \/_//     robfinch<remove>@finitron.ca
                            	     6: #       ||
                            	     7: #  
                            	     8: #
                            	     9: # BSD 3-Clause License
                            	    10: # Redistribution and use in source and binary forms, with or without
                            	    11: # modification, are permitted provided that the following conditions are met:
                            	    12: #
                            	    13: # 1. Redistributions of source code must retain the above copyright notice, this
                            	    14: #    list of conditions and the following disclaimer.
                            	    15: #
                            	    16: # 2. Redistributions in binary form must reproduce the above copyright notice,
                            	    17: #    this list of conditions and the following disclaimer in the documentation
                            	    18: #    and/or other materials provided with the distribution.
                            	    19: #
                            	    20: # 3. Neither the name of the copyright holder nor the names of its
                            	    21: #    contributors may be used to endorse or promote products derived from
                            	    22: #    this software without specific prior written permission.
                            	    23: #
                            	    24: # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
                            	    25: # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
                            	    26: # IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
                            	    27: # DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
                            	    28: # FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
                            	    29: # DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
                            	    30: # SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
                            	    31: # CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
                            	    32: # OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
                            	    33: # OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
                            	    34: #
                            	    35: # ============================================================================
                            	    36: 
                            	    37: .set MMU_PFA,0xFFF40000
                            	    38: .set MMU_PTBR,0xFFF40028
                            	    39: .set MMU_VADR,0xFFF40040
                            	    40: .set MMU_PADR,0xFFF40050
                            	    41: .set MMU_PADRV,0xFFF40060
                            	    42: 
                            	    43: # ------------------------------------------------------------------------------
                            	    44: # Clear a page of memory
                            	    45: #
                            	    46: # Parameters:
                            	    47: #		%a0 = pointer to page
                            	    48: # Returns:
                            	    49: #		none
                            	    50: # ------------------------------------------------------------------------------
                            	    51: 
                            	    52: _ClearPage:
01:00001BAC 1E010040        	    53: 	push %a1-%a2
01:00001BB0 8F080000        	    54: 	move %a1,%a0
01:00001BB4 C4080000        	    55: 	addi %a2,%a0,PGSIZE
                            	    56: .0001:
01:00001BB8 2E100000        	    57: 	store %r0,[%a1]
01:00001BBC 84100800        	    58: 	addi %a1,%a1,4
01:00001BC0 03100680        	    59: 	cmpa %cr0,%a1,%a2
01:00001BC4 193156E1        	    60: 	blt .0001
01:00001BC8 1F010040        	    61: 	pop %a1-%a2
01:00001BCC 1B00FE87        	    62: 	blr
                            	    63: 
                            	    64: # ------------------------------------------------------------------------------
                            	    65: # Search for a memory page that is not used yet. Mark it as in use and return
                            	    66: # the address. The search proceeds 32-bits at a time.
                            	    67: #
                            	    68: # Parameters:
                            	    69: #		none
                            	    70: # Returns:
                            	    71: #		%a0 = address of page (zero if no page available)
                            	    72: #		%cr0.eq set if no page found, zero otherwise
                            	    73: # ------------------------------------------------------------------------------
                            	    74: 
                            	    75: _FindFreePage:
01:00001BD0 1E070040        	    76: 	push %a1-%a4		# save %a1 to %a4
01:00001BD4 440000A0        	    77: 	loadi %a0,_PAM
01:00001BD8 84000000        	    78: 	loadi %a1,0
                            	    79: 	# search the PAM 32-bits at a time for a free page
                            	    80: .0002:
01:00001BDC E6080000        	    81: 	load %a2,[%a0]		# get alloc status
01:00001BE0 00190080        	    82: 	cntlo %a3,%a2			# find the first zero
01:00001BE4 03200080        	    83: 	cmp %cr0,%a3,32		# 32 1's mean all pages in group allocated
01:00001BE8 593280E0        	    84: 	bne %cr0,.0001
01:00001BEC 44080800        	    85: 	addi %a0,%a0,4			# move to next group
01:00001BF0 030A04A0        	    86: 	cmpai %cr0,%a0,_PAMend	# end of table?
01:00001BF4 D83046E100200000	    87: 	blt %cr0,.0002
01:00001BFC 00400000
01:00001C00 44000004        	    88: 	loadi. %a0,0			# return zero if no pages available
01:00001C04 1F070040        	    89: 	pop %a1-%a4
01:00001C08 1B00FE87        	    90: 	blr
                            	    91: 	# Here there was a page available
                            	    92: .0001:
01:00001C0C 0C213E80        	    93: 	subf %a3,%a3,31		# %a3 was 1 to 31
01:00001C10 42090880        	    94: 	sll %a4,1,%a3
01:00001C14 C9180A80        	    95: 	or %a2,%a2,%a4			# set bit
01:00001C18 EE080000        	    96: 	store %a2,[%a0]		# update PAM, mark page used
01:00001C1C 4C000280        	    97: 	sub %a0,%a0,_PAM	# %a0 = tetra index into PAM
01:00001C20 42080A00        	    98: 	slli %a0,%a0,5			# 32 bits per entry
01:00001C24 44080880        	    99: 	add %a0,%a0,%a3		# add in bit number, %a0 = page number
01:00001C28 42080800        	   100: 	slli %a0,%a0,4			# size of PMT entry
01:00001C2C 44080000        	   101: 	addi %a0,%a0,_PMT
01:00001C30 2B080A00        	   102: 	stwi 1,4[%a0]			# set share count to 1
01:00001C34 2B080E00        	   103: 	stwi 7,[%a0]			# set acr = user, rwx
01:00001C38 44080000        	   104: 	subi %a0,%a0,_PMT
01:00001C3C 42081404        	   105: 	slli. %a0,%a0,LOG_PGSZ-4		# convert to address
01:00001C40 1F070040        	   106: 	pop %a1-%a4
01:00001C44 1B00FE87        	   107: 	blr
                            	   108: 
                            	   109: 
                            	   110: # ------------------------------------------------------------------------------
                            	   111: # Gets the address for the page table entry given the virtual address. Walks
                            	   112: # the page table. Currently assumes a two-level page table.
                            	   113: #
                            	   114: # Side Effects:
                            	   115: # 	Calling this routine may cause a page fault if the address cannot be
                            	   116: #	translated.
                            	   117: #
                            	   118: # Parameters:
                            	   119: #		%a0 = virtual address to translate
                            	   120: # Returns:
                            	   121: #		%a0 = physical address
                            	   122: # ------------------------------------------------------------------------------
                            	   123: 
                            	   124: _GetPageTableEntryAddress:
01:00001C48 1E1F0040        	   125: 	push %a1-%a6
                            	   126: .0001:
01:00001C4C 84011000        	   127: 	loadi %a5,8					# maximum numober of levels of page tables (limits looping)
01:00001C50 A60000A0        	   128: 	load %a1,MMU_PTBR		# %a1 = address of page table
01:00001C54 42D80010        	   129: 	srli %a2,%a0,26				# %a2 = index into root page table
01:00001C58 E7110680        	   130: 	loada %a6,[%a1+%a2*4]	# %a6 = PTE address
01:00001C5C 26390004        	   131: 	load. %a3,[%a6]				# Get the PTE
01:00001C60 993388E0        	   132: 	bgt %cr0,.0002				# check valid bit (bit 31)
                            	   133: .0003:
01:00001C64 8431FE7F        	   134: 	addi. %a5,%a5,-1
01:00001C68 18004801        	   135: 	ble %cr0,.notFound
01:00001C6C 02E90010        	   136: 	srli %a4,%a3,29				# Extra PTE type bits
01:00001C70 48290600        	   137: 	andi %a4,%a4,3
01:00001C74 03280400        	   138: 	cmpi %cr0,%a4,2
01:00001C78 983280E02800F4FF	   139: 	bne %cr0,.0004
                            	   140: 	# Type 2 PTE = PTP
01:00001C80 482100A0        	   141: 	andi %a4,%a3,0x1FFFFFFF	# Extract PPN
01:00001C84 42291C00        	   142: 	slli %a4,%a4,LOG_PGSZ		# Turn into an address
01:00001C88 42780010        	   143: 	srli %a2,%a0,14					# extract vadr bits 14 to 25
01:00001C8C C818FE1F        	   144: 	andi %a2,%a2,0xFFF				# convert to index into page
01:00001C90 C2180400        	   145: 	slli %a2,%a2,2						# convert index to page offset
01:00001C94 C9180A80        	   146: 	or %a2,%a2,%a4						# %a2 = pointer to entry now
01:00001C98 26190000        	   147: 	load %a3,[%a2]					# Load the PTE
01:00001C9C CF190000        	   148: 	move %a6,%a2						# %a6 = PTE address
01:00001CA0 1B7AFF7F        	   149: 	b .0003
                            	   150: 	# Type 1 PTE
                            	   151: .0004:
01:00001CA4 4F380000        	   152: 	move %a0,%a6
01:00001CA8 1F1F0040        	   153: 	pop %a1-%a6
01:00001CAC 1B00FE87        	   154: 	blr
                            	   155: 	# invalid PTE? Assign a page.
                            	   156: .0002:
01:00001CB0 4400FE7F        	   157: 	loadi %a0,-1
01:00001CB4 5A0AF97F        	   158: 	bl LockPMTSemaphore
01:00001CB8 5A52FF7FFFFFFF1F	   159: 	bl _FindFreePage
                            	   160: 	macUnlockPMTSemaphore
01:00001CC0 2E000000        	     1M 	store %r0,PMTSEMA
01:00001CC4 03080000        	   161: 	cmpi %cr0,%a0,0
01:00001CC8 D83140E1        	   162: 	beq %cr0,.0005
01:00001CCC 5A44FF7F        	   163: 	bl _ClearPage
                            	   164: 	# set the PTP to point to the page
01:00001CD0 42780010        	   165: 	srli %a0,%a0,LOG_PGSZ
01:00001CD4 090900A0        	   166: 	ori %a3,%a0,0xC0000000	# set valid bit, and type 2 page
01:00001CD8 2E390000        	   167: 	store %a3,[%a6]				# update the page table
01:00001CDC 1A66FF7F        	   168: 	b .0001
                            	   169: .0005:
01:00001CE0 44000000        	   170: 	loadi %a0,0
01:00001CE4 1F1F0040        	   171: 	pop %a1-%a6
01:00001CE8 1B00FE87        	   172: 	blr
                            	   173: 
                            	   174: # ------------------------------------------------------------------------------
                            	   175: # Page fault handler. Triggered when there is no translation for a virtual
                            	   176: # address. Allocates a page of memory an puts an entry in the page table for it.
                            	   177: # If the PTP was invalid, then a page is allocated for the page table it points
                            	   178: # to and the PTP entry updated in the page table.
                            	   179: #
                            	   180: # Side Effects:
                            	   181: #		Page table is updated.
                            	   182: # Modifies:
                            	   183: #		none
                            	   184: # Parameters:
                            	   185: #		none - it is an ISR
                            	   186: # Returns:
                            	   187: #		none - it is an ISR
                            	   188: # ------------------------------------------------------------------------------
                            	   189: 
                            	   190: _PageFaultHandlerISR:	
01:00001CEC 1E000448        	   191: 	push %br1
01:00001CF0 9E3F0240        	   192: 	push %a0-%t0				# push %a0 to a7, t0
                            	   193: 	# search the PMT for a free page
01:00001CF4 4400FE7F        	   194: 	loadi %a0,-1
01:00001CF8 5BF8F87F000000C0	   195: 	bl LockPMTSemaphore
01:00001D00 5A40FF7F        	   196: 	bl _FindFreePage
01:00001D04 193180E0        	   197: 	bne %cr0,.0001
                            	   198: 	# Here there are no more free pages
                            	   199: 	macUnlockPMTSemaphore
01:00001D08 2E000000        	     1M 	store %r0,PMTSEMA
                            	   200: 	# Here a free page was found
                            	   201: .0001:
                            	   202: 	macUnlockPMTSemaphore
01:00001D0C 2E000000        	     1M 	store %r0,PMTSEMA
01:00001D10 5B32FF7F        	   203: 	bl _ClearPage
                            	   204: 	# Should add the base address of the memory from the region table
01:00001D14 84011000        	   205: 	loadi %a5,8					# maximum numober of levels of page tables (limits looping)
01:00001D18 A60000A0        	   206: 	load %a1,MMU_PTBR		# %a1 = address of page table
01:00001D1C 660204A0        	   207: 	load t0,MMU_PFA			# t0 = fault address (virtual address)
01:00001D20 42DA0010        	   208: 	srli %a2,t0,26				# %a2 = index into root page table
01:00001D24 E7110680        	   209: 	loada %a6,[%a1+%a2*4]	# %a6 = PTE address
01:00001D28 26390004        	   210: 	load. %a3,[%a6]				# Get the PTE
01:00001D2C 193388E0        	   211: 	bgt %cr0,.0002				# check valid bit (bit 31)
                            	   212: .0003:
01:00001D30 02E90010        	   213: 	srli %a4,%a3,29				# Extra PTE type bits
01:00001D34 482906002800F4FF	   214: 	andi %a4,%a4,3
01:00001D3C 0000F4FF
01:00001D40 03280400        	   215: 	cmpi %cr0,%a4,2
01:00001D44 593280E0        	   216: 	bne %cr0,.0002
                            	   217: .0004:
01:00001D48 482100A0        	   218: 	andi %a4,%a3,0x1FFFFFFF	# Extract PPN
01:00001D4C 42291C00        	   219: 	slli %a4,%a4,LOG_PGSZ		# Turn into an address
01:00001D50 427A0010        	   220: 	srli %a2,t0,14					# extract vadr bits 14 to 25
01:00001D54 C818FE1F        	   221: 	andi %a2,%a2,0xFFF				# convert to index into page
01:00001D58 C2180400        	   222: 	slli %a2,%a2,2						# convert index to page offset
01:00001D5C C9190A80        	   223: 	or %a6,%a2,%a4						# %a6 = pointer to entry now
                            	   224: 	# set the PTE to point to the page
01:00001D60 42780010        	   225: 	srli %a0,%a0,LOG_PGSZ
01:00001D64 4808FE3F        	   226: 	andi %a0,%a0,0x1FFF		# Keep only low order bits of page number
01:00001D68 490804A0        	   227: 	ori %a0,%a0,0x8000E000	# set valid bit, and type 0 page, user, rwx=7
01:00001D6C 6E380000        	   228: 	store %a0,[%a6]				# update the page table
01:00001D70 9F3F0240        	   229: 	pop %a0-%t0
01:00001D74 1F000448FFFFFF1F	   230: 	pop %br1
01:00001D7C 00E00080
01:00001D80 77000000        	   231: 	rfi
                            	   232: 	# Here the PTP was invalid, so allocate a new page table and set PTP
                            	   233: .0002:
01:00001D84 4400FE7F        	   234: 	loadi %a0,-1
01:00001D88 5BD4F87F        	   235: 	bl LockPMTSemaphore
01:00001D8C 5B1CFF7F        	   236: 	bl _FindFreePage
                            	   237: 	macUnlockPMTSemaphore
01:00001D90 2E000000        	     1M 	store %r0,PMTSEMA
01:00001D94 03080080        	   238: 	cmp %cr0,%a0,0
01:00001D98 193140E1        	   239: 	beq %cr0,.0005
01:00001D9C 5A10FF7F        	   240: 	bl _ClearPage
                            	   241: 	# set the PTP to point to the page
01:00001DA0 42081C10        	   242: 	srl %a0,%a0,LOG_PGSZ
01:00001DA4 09090080        	   243: 	or %a3,%a0,0xC0000000	# set valid bit, and type 2 page
01:00001DA8 2E390000        	   244: 	store %a3,[%a6]				# update the page table
01:00001DAC 1A6CFF7F        	   245: 	b .0004
                            	   246: 	# Here there was no memory available
                            	   247: .0005:
01:00001DB0 9F3F0240        	   248: 	pop %a0-%t0
01:00001DB4 1F000448        	   249: 	pop %br1
01:00001DB8 77000000        	   250: 	rfi
                            	   251: 	
                            	   252: 
                            	   253: 		

Source: "Femtikia.qpa"
                            	  1777: 
                            	  1778: 


Symbols by name:
.notFound                       external
ACBCursorCol                     S:00000363
ACBCursorRow                     S:00000362
ACBHandleToPointer              01:00000010
ACBHasFocus                      S:000003C8
ACBMid                          external
ACBNormAttr                      S:00000368
ACBObject                        S:00000000
ACBSEMA                         external
ACBTask                         external
ACBTaskList                      S:000003C0
ACBVideoCols                     S:00000361
ACBVideoRows                     S:00000360
ACB_SIZE                         S:00004000
ACBmid                           S:000003CA
ACBpVidMem                       S:00000350
CB_XOR                           S:00312345
ConvertVirtualToPhysical        01:0000030C
CopyMsg                         01:00000FC4
DecrementTimeout                01:0000051C
DequeTaskFromMbx                01:00001188
DequeueMsg                      01:0000114C
DispSpace                       01:00000F60
DispTwoSpace                    01:00000F54
DumpTCBs                        01:00000F70
EPC0                             S:00003108
ESR0                             S:00003080
E_Arg                            S:00000001
E_Busy                           S:0000000E
E_Busyed                        external
E_Func                           S:00000002
E_NoMem                          S:0000002E
E_NoMoreMbx                      S:00000028
E_NoMoreMsgBlks                  S:00000029
E_NoMoreTCBs                     S:0000002D
E_NoMsg                          S:00000008
E_NoTask                        external
E_NotAlloc                       S:00000007
E_NotOwner                       S:0000000C
E_OK                            external
E_Ok                             S:00000000
E_QueFull                        S:00000005
FMTK_AllocMbx                   01:00001244
FMTK_AllocTCB                   01:00000E48
FMTK_CheckMsg                   01:000018C0
FMTK_ExitTask                   01:00000C34
FMTK_FreeMbx                    01:00001304
FMTK_FreeTCB                    01:00000E64
FMTK_GetAppTaskId               01:000003FC
FMTK_GetCurrentMid              01:0000045C
FMTK_GetCurrentTid              01:000002D4
FMTK_GetMid                     01:0000048C
FMTK_GetRunningTCBPointer       01:000004E4
FMTK_GetTaskAppId               01:00000380
FMTK_Init                       01:00000D18
FMTK_Initialize                 01:000002BC
FMTK_KillTask                   01:00000C38
FMTK_PeekMsg                    01:000018BC
FMTK_PostMsg                    01:00001584
FMTK_RetErr                     01:000001D0
FMTK_RetOK                      01:000001D8
FMTK_SendMsg                    01:0000145C
FMTK_SetTaskAppId               01:000003C4
FMTK_SetTaskId                  01:00000448
FMTK_Sleep                      01:00000A4C
FMTK_StartTask                  01:00000B6C
FMTK_WaitMsg                    01:000016A8
FPSR                            external
FPStateBegin                     S:00000003
FPStateEnd                       S:00000004
FemtikiTimerISR                 01:000005C8
FemtikiVars                      S:FFF80020
FemtikiVars_end                  S:FFF80114
FreeMBX                          S:FFF800D0
FreeMSG                          S:FFF800CC
FreeMsg                         01:00001004
FreeTCB                          S:FFF800C8
GetAppHandle                    external
GetAppMid                       01:000001E4
GetCurrentTid                   01:000002CC
GetIRQFlag                      01:00000344
GetRunningTCBPointer            01:000004D4
GetRunningTCBPtr                external
IAllocTCB                       01:00000E2C
IFreeMBX                        external
IFreeTCB                        01:00000E4C
IRQFlag                          S:FFFC0012
InTimerISRFlag                   S:00000001
InitAppOne                      01:00000DAC
InitFreeMailboxList             01:00000CB8
InitFreeMessageList             01:00000C88
InitFreeTCBList                 01:00000CE8
InitTaskOne                     01:00000DF8
InsertIntoReadyQueue            01:00000E80
InsertIntoTimeoutList           external
LOG_ACBSZ                        S:0000000E
LOG_PGSZ                         S:0000000E
LOG_TCBSZ                        S:0000000A
LockACBSemaphore                01:000000C0
LockMMUSemaphore                01:000000A4
LockMSGSemaphore                01:000000F8
LockPMTSemaphore                01:000000DC
LockSemaphore                   01:00000058
LockSysSemaphore                01:00000088
MAXVPG                          external
MBT_DATA                        external
MBXLink                          S:00000004
MBXMQCount                       S:0000001C
MBXMQHead                        S:00000014
MBXMQMissed                      S:00000024
MBXMQSize                        S:00000020
MBXMQStrategy                    S:00000028
MBXMQTail                        S:00000018
MBXOwner                        external
MBXTQCount                       S:00000010
MBXTQHead                        S:00000008
MBXTQTail                        S:0000000C
MBX_LINK                        external
MBX_SIZE                         S:0000002C
MF_CRLF                         external
MF_DisplayByteAsHex             external
MF_DisplayTetraAsHex            external
MF_IncreaseStackSize            external
MF_OUTCH                        external
MMUSEMA                         external
MMU_PFA                          S:FFF40000
MMU_PTBR                         S:FFF40028
MMUxPADRV                        S:FFF40060
MMUxPHYSADR                      S:FFF40050
MMUxVIRTADR                      S:FFF40040
MQS_NEWEST                      external
MQS_OLDEST                      external
MQS_UNLIMITED                   external
MSGD1                            S:00000010
MSGD2                            S:00000014
MSGD3                            S:00000018
MSGDEstAdr                      external
MSGDestAdr                       S:00000008
MSGLink                          S:00000000
MSGRetAdr                        S:00000004
MSGSEMA                         external
MSGType                          S:0000000C
MSG_LINK                        external
MSG_SIZE                         S:0000001C
MT_FREE                         external
MT_NONE                         external
M_SEMA                           S:0000300C
M_SR                             S:00003004
MidStackBottoms                  S:FFF800AC
NR_ACB                          external
OBJMagic                         S:00000000
OSActive                         S:FFF80110
OSCall                          01:0000013C
OSCallBadFunc                   01:000001C0
OSCallBadFunc2                  01:000001CC
OSCallTable                     01:000001F4
OSCallTableLimit                external
OSExit                          01:00000194
OSSEMA                          external
PGSIZE                          external
PGSZ                            external
PMTSEMA                         external
PopTimeoutList                  01:00000F14
PrevRunningID                   external
QueueMsg                        01:0000102C
RDYQ                            external
RemoveFromReadyList             external
RemoveFromReadyQueue            01:00000EA4
RemoveFromTimeoutList           01:00000EB8
RunningAID                       S:FFF80024
RunningID                        S:FFF80028
SCRATCH                         external
SR                              external
SchedulerIRQHelper              01:00000550
SelectTaskToRun                 01:00000AA4
SetIRQFlag                      01:00000374
SetMbxMsgQueStrategy            01:000013D8
SwitchTask                      01:00000678
TBCNext                         external
TCBA                            external
TCBAcbNext                       S:00000350
TCBAffinity                      S:00000314
TCBClearStatusBit               01:00000040
TCBEndTick                       S:000002EC
TCBException                     S:000002FC
TCBHandleToPointer              01:00000000
TCBHasFocus                      S:000002C4
TCBMBQNext                      external
TCBMBQPrev                      external
TCBMBXPrev                      external
TCBMsg                           S:0000039C
TCBNext                          S:00000304
TCBPointerToHandle              01:00000020
TCBPrev                          S:0000030C
TCBPriority                      S:000002BD
TCBPriorty                      external
TCBRsResp                       external
TCBSEMA                         external
TCBSetStatusBit                 01:00000030
TCBStartTick                     S:000002E4
TCBStatus                        S:000002BC
TCBTicks                         S:000002F4
TCBTimeout                       S:0000031C
TCBTsCmd                         S:00000358
TCBTsCmdParm                     S:00000368
TCBTsResp                        S:00000360
TCB_SIZE                         S:00000400
TCBappid                         S:0000032C
TCBbrk                           S:00000398
TCBhMailboxes                    S:00000370
TCBhWaitMbx                     external
TCBtid                           S:00000324
TCBxA0                           S:00000040
TCBxA1                           S:00000048
TCBxA2                           S:00000050
TCBxA3                           S:00000058
TCBxA4                           S:00000060
TCBxA5                           S:00000068
TCBxA6                           S:00000070
TCBxA7                           S:00000078
TCBxBR1                          S:00000010
TCBxBR2                          S:00000018
TCBxBR3                          S:00000020
TCBxBR4                          S:00000028
TCBxBR5                          S:00000030
TCBxBR6                          S:00000038
TCBxCR0                          S:00000004
TCBxCR1                          S:00000005
TCBxCR2                          S:00000006
TCBxCR3                          S:00000007
TCBxCR4                          S:00000008
TCBxCR5                          S:00000009
TCBxCR6                          S:0000000A
TCBxCR7                          S:0000000B
TCBxF0                           S:00000150
TCBxF1                           S:00000158
TCBxF10                          S:000001A0
TCBxF11                          S:000001A8
TCBxF12                          S:000001B0
TCBxF13                          S:000001B8
TCBxF14                          S:000001C0
TCBxF15                          S:000001C8
TCBxF16                          S:000001D0
TCBxF17                          S:000001D8
TCBxF18                          S:000001E0
TCBxF19                          S:000001E8
TCBxF2                           S:00000160
TCBxF20                          S:000001F0
TCBxF21                          S:000001F8
TCBxF22                          S:00000200
TCBxF23                          S:00000208
TCBxF24                          S:00000210
TCBxF25                          S:00000218
TCBxF26                          S:00000220
TCBxF27                          S:00000228
TCBxF28                          S:00000230
TCBxF29                          S:00000238
TCBxF3                           S:00000168
TCBxF30                          S:00000240
TCBxF31                          S:00000248
TCBxF4                           S:00000170
TCBxF5                           S:00000178
TCBxF6                           S:00000180
TCBxF7                           S:00000188
TCBxF8                           S:00000190
TCBxF9                           S:00000198
TCBxFP                           S:00000128
TCBxFPSR                         S:000002A0
TCBxGP                           S:00000120
TCBxHSP                          S:00000140
TCBxLC                           S:00000148
TCBxPC                           S:00000250
TCBxS0                           S:000000D0
TCBxS1                           S:000000D8
TCBxS2                           S:000000E0
TCBxS3                           S:000000E8
TCBxS4                           S:000000F0
TCBxS5                           S:000000F8
TCBxS6                           S:00000100
TCBxS7                           S:00000108
TCBxS8                           S:00000110
TCBxS9                           S:00000118
TCBxSP                          external
TCBxSR                           S:00000298
TCBxSSP                          S:00000138
TCBxT0                           S:00000080
TCBxT1                           S:00000088
TCBxT2                           S:00000090
TCBxT3                           S:00000098
TCBxT4                           S:000000A0
TCBxT5                           S:000000A8
TCBxT6                           S:000000B0
TCBxT7                           S:000000B8
TCBxT8                           S:000000C0
TCBxT9                           S:000000C8
TCBxUSP                          S:00000130
TCBxXH                           S:00000258
TImeoutList                     external
TSC_ALLOCTCB                     S:00000001
TSC_FREE                        external
TSC_FREETCB                      S:00000002
TSC_SLEEP                        S:00000003
TS_PREEMPT                       S:00000020
TS_READY                         S:00000001
TS_RUNNING                       S:00000080
TS_TIMEOUT                       S:00000010
TS_WAITMSG                       S:00000008
TimeoutList                      S:FFF800D4
_ClearPage                      01:000019DC
_FindFreePage                   01:00001A00
_GetPageTableEntryAddress       01:00001A70
_PAM                             S:00002000
_PAMend                          S:00004000
_PMT                            external
_PageFaultHandlerISR            01:00001B0C
_UnlockACBSemaphore             01:00000124
_UnlockMMUSemaphore             01:0000011C
_UnlockMSGSemaphore             01:00000134
_UnlockPMTSemaphore             01:0000012C
_UnlockSysSemaphore             01:00000114
acbs                             S:00104000
freeMBX                         external
freeMSG                         external
mailboxes                        S:00684000
mailboxes_end                    S:006E4000
messages                         S:00584000
messages_end                     S:00684000
milliseconds                    external
missed_ticks                    external
nMailbox                         S:FFF800C0
nMsgBlk                         external
tcb_ends                        external
tcbs                             S:00184000

Symbols by value:
FFF40000 MMU_PFA
FFF40028 MMU_PTBR
FFF40040 MMUxVIRTADR
FFF40050 MMUxPHYSADR
FFF40060 MMUxPADRV
FFF80020 FemtikiVars
FFF80024 RunningAID
FFF80028 RunningID
FFF800AC MidStackBottoms
FFF800C0 nMailbox
FFF800C8 FreeTCB
FFF800CC FreeMSG
FFF800D0 FreeMBX
FFF800D4 TimeoutList
FFF80110 OSActive
FFF80114 FemtikiVars_end
FFFC0012 IRQFlag
00000000 TCBHandleToPointer
00000000 E_Ok
00000000 OBJMagic
00000000 MSGLink
00000000 ACBObject
00000001 InTimerISRFlag
00000001 TSC_ALLOCTCB
00000001 E_Arg
00000001 TS_READY
00000002 TSC_FREETCB
00000002 E_Func
00000003 FPStateBegin
00000003 TSC_SLEEP
00000004 TCBxCR0
00000004 FPStateEnd
00000004 MSGRetAdr
00000004 MBXLink
00000005 TCBxCR1
00000005 E_QueFull
00000006 TCBxCR2
00000007 E_NotAlloc
00000007 TCBxCR3
00000008 TS_WAITMSG
00000008 E_NoMsg
00000008 MBXTQHead
00000008 MSGDestAdr
00000008 TCBxCR4
00000009 TCBxCR5
0000000A TCBxCR6
0000000A LOG_TCBSZ
0000000B TCBxCR7
0000000C MSGType
0000000C E_NotOwner
0000000C MBXTQTail
0000000E LOG_ACBSZ
0000000E E_Busy
0000000E LOG_PGSZ
00000010 ACBHandleToPointer
00000010 MSGD1
00000010 TS_TIMEOUT
00000010 MBXTQCount
00000010 TCBxBR1
00000014 MBXMQHead
00000014 MSGD2
00000018 MBXMQTail
00000018 TCBxBR2
00000018 MSGD3
0000001C MSG_SIZE
0000001C MBXMQCount
00000020 TS_PREEMPT
00000020 TCBxBR3
00000020 MBXMQSize
00000020 TCBPointerToHandle
00000024 MBXMQMissed
00000028 MBXMQStrategy
00000028 TCBxBR4
00000028 E_NoMoreMbx
00000029 E_NoMoreMsgBlks
0000002C MBX_SIZE
0000002D E_NoMoreTCBs
0000002E E_NoMem
00000030 TCBxBR5
00000030 TCBSetStatusBit
00000038 TCBxBR6
00000040 TCBxA0
00000040 TCBClearStatusBit
00000048 TCBxA1
00000050 TCBxA2
00000058 LockSemaphore
00000058 TCBxA3
00000060 TCBxA4
00000068 TCBxA5
00000070 TCBxA6
00000078 TCBxA7
00000080 TS_RUNNING
00000080 TCBxT0
00000088 TCBxT1
00000088 LockSysSemaphore
00000090 TCBxT2
00000098 TCBxT3
000000A0 TCBxT4
000000A4 LockMMUSemaphore
000000A8 TCBxT5
000000B0 TCBxT6
000000B8 TCBxT7
000000C0 TCBxT8
000000C0 LockACBSemaphore
000000C8 TCBxT9
000000D0 TCBxS0
000000D8 TCBxS1
000000DC LockPMTSemaphore
000000E0 TCBxS2
000000E8 TCBxS3
000000F0 TCBxS4
000000F8 TCBxS5
000000F8 LockMSGSemaphore
00000100 TCBxS6
00000108 TCBxS7
00000110 TCBxS8
00000114 _UnlockSysSemaphore
00000118 TCBxS9
0000011C _UnlockMMUSemaphore
00000120 TCBxGP
00000124 _UnlockACBSemaphore
00000128 TCBxFP
0000012C _UnlockPMTSemaphore
00000130 TCBxUSP
00000134 _UnlockMSGSemaphore
00000138 TCBxSSP
0000013C OSCall
00000140 TCBxHSP
00000148 TCBxLC
00000150 TCBxF0
00000158 TCBxF1
00000160 TCBxF2
00000168 TCBxF3
00000170 TCBxF4
00000178 TCBxF5
00000180 TCBxF6
00000188 TCBxF7
00000190 TCBxF8
00000194 OSExit
00000198 TCBxF9
000001A0 TCBxF10
000001A8 TCBxF11
000001B0 TCBxF12
000001B8 TCBxF13
000001C0 OSCallBadFunc
000001C0 TCBxF14
000001C8 TCBxF15
000001CC OSCallBadFunc2
000001D0 FMTK_RetErr
000001D0 TCBxF16
000001D8 FMTK_RetOK
000001D8 TCBxF17
000001E0 TCBxF18
000001E4 GetAppMid
000001E8 TCBxF19
000001F0 TCBxF20
000001F4 OSCallTable
000001F8 TCBxF21
00000200 TCBxF22
00000208 TCBxF23
00000210 TCBxF24
00000218 TCBxF25
00000220 TCBxF26
00000228 TCBxF27
00000230 TCBxF28
00000238 TCBxF29
00000240 TCBxF30
00000248 TCBxF31
00000250 TCBxPC
00000258 TCBxXH
00000298 TCBxSR
000002A0 TCBxFPSR
000002BC TCBStatus
000002BC FMTK_Initialize
000002BD TCBPriority
000002C4 TCBHasFocus
000002CC GetCurrentTid
000002D4 FMTK_GetCurrentTid
000002E4 TCBStartTick
000002EC TCBEndTick
000002F4 TCBTicks
000002FC TCBException
00000304 TCBNext
0000030C TCBPrev
0000030C ConvertVirtualToPhysical
00000314 TCBAffinity
0000031C TCBTimeout
00000324 TCBtid
0000032C TCBappid
00000344 GetIRQFlag
00000350 ACBpVidMem
00000350 TCBAcbNext
00000358 TCBTsCmd
00000360 ACBVideoRows
00000360 TCBTsResp
00000361 ACBVideoCols
00000362 ACBCursorRow
00000363 ACBCursorCol
00000368 TCBTsCmdParm
00000368 ACBNormAttr
00000370 TCBhMailboxes
00000374 SetIRQFlag
00000380 FMTK_GetTaskAppId
00000398 TCBbrk
0000039C TCBMsg
000003C0 ACBTaskList
000003C4 FMTK_SetTaskAppId
000003C8 ACBHasFocus
000003CA ACBmid
000003FC FMTK_GetAppTaskId
00000400 TCB_SIZE
00000448 FMTK_SetTaskId
0000045C FMTK_GetCurrentMid
0000048C FMTK_GetMid
000004D4 GetRunningTCBPointer
000004E4 FMTK_GetRunningTCBPointer
0000051C DecrementTimeout
00000550 SchedulerIRQHelper
000005C8 FemtikiTimerISR
00000678 SwitchTask
00000A4C FMTK_Sleep
00000AA4 SelectTaskToRun
00000B6C FMTK_StartTask
00000C34 FMTK_ExitTask
00000C38 FMTK_KillTask
00000C88 InitFreeMessageList
00000CB8 InitFreeMailboxList
00000CE8 InitFreeTCBList
00000D18 FMTK_Init
00000DAC InitAppOne
00000DF8 InitTaskOne
00000E2C IAllocTCB
00000E48 FMTK_AllocTCB
00000E4C IFreeTCB
00000E64 FMTK_FreeTCB
00000E80 InsertIntoReadyQueue
00000EA4 RemoveFromReadyQueue
00000EB8 RemoveFromTimeoutList
00000F14 PopTimeoutList
00000F54 DispTwoSpace
00000F60 DispSpace
00000F70 DumpTCBs
00000FC4 CopyMsg
00001004 FreeMsg
0000102C QueueMsg
0000114C DequeueMsg
00001188 DequeTaskFromMbx
00001244 FMTK_AllocMbx
00001304 FMTK_FreeMbx
000013D8 SetMbxMsgQueStrategy
0000145C FMTK_SendMsg
00001584 FMTK_PostMsg
000016A8 FMTK_WaitMsg
000018BC FMTK_PeekMsg
000018C0 FMTK_CheckMsg
000019DC _ClearPage
00001A00 _FindFreePage
00001A70 _GetPageTableEntryAddress
00001B0C _PageFaultHandlerISR
00002000 _PAM
00003004 M_SR
0000300C M_SEMA
00003080 ESR0
00003108 EPC0
00004000 ACB_SIZE
00004000 _PAMend
00104000 acbs
00184000 tcbs
00312345 CB_XOR
00584000 messages
00684000 mailboxes
00684000 messages_end
006E4000 mailboxes_end
